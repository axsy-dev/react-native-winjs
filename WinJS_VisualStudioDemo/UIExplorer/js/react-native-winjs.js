/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp"];
/******/ 	window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, callbacks = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId])
/******/ 				callbacks.push.apply(callbacks, installedChunks[chunkId]);
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			var _m = moreModules[moduleId];
/******/
/******/ 			// Check if module is deduplicated
/******/ 			switch(typeof _m) {
/******/ 			case "object":
/******/ 				// Module can be created from a template
/******/ 				modules[moduleId] = (function(_m) {
/******/ 					var args = _m.slice(1), templateId = _m[0];
/******/ 					return function (a,b,c) {
/******/ 						modules[templateId].apply(this, [a,b,c].concat(args));
/******/ 					};
/******/ 				}(_m));
/******/ 				break;
/******/ 			case "function":
/******/ 				// Normal module
/******/ 				modules[moduleId] = _m;
/******/ 				break;
/******/ 			default:
/******/ 				// Module is a copy of another module
/******/ 				modules[moduleId] = modules[_m];
/******/ 				break;
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);
/******/ 		while(callbacks.length)
/******/ 			callbacks.shift().call(null, __webpack_require__);
/******/ 		if(moreModules[0]) {
/******/ 			installedModules[0] = 0;
/******/ 			return __webpack_require__(0);
/******/ 		}
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// "0" means "already loaded"
/******/ 	// Array means "loading", array contains callbacks
/******/ 	var installedChunks = {
/******/ 		2:0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId, callback) {
/******/ 		// "0" is the signal for "already loaded"
/******/ 		if(installedChunks[chunkId] === 0)
/******/ 			return callback.call(null, __webpack_require__);
/******/
/******/ 		// an array means "currently loading".
/******/ 		if(installedChunks[chunkId] !== undefined) {
/******/ 			installedChunks[chunkId].push(callback);
/******/ 		} else {
/******/ 			// start chunk loading
/******/ 			installedChunks[chunkId] = [callback];
/******/ 			var head = document.getElementsByTagName('head')[0];
/******/ 			var script = document.createElement('script');
/******/ 			script.type = 'text/javascript';
/******/ 			script.charset = 'utf-8';
/******/ 			script.async = true;
/******/
/******/ 			script.src = __webpack_require__.p + "" + chunkId + "." + ({"0":"game2048","1":"movies","3":"tictactoe","4":"uiexplorer"}[chunkId]||chunkId) + ".js";
/******/ 			head.appendChild(script);
/******/ 		}
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ((function(modules) {
	// Check all modules for deduplicated modules
	for(var i in modules) {
		if(Object.prototype.hasOwnProperty.call(modules, i)) {
			switch(typeof modules[i]) {
			case "function": break;
			case "object":
				// Module can be created from a template
				modules[i] = (function(_m) {
					var args = _m.slice(1), fn = modules[_m[0]];
					return function (a,b,c) {
						fn.apply(this, [a,b,c].concat(args));
					};
				}(modules[i]));
				break;
			default:
				// Module is a copy of another module
				modules[i] = modules[modules[i]];
				break;
			}
		}
	}
	return modules;
}([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @providesModule ReactNativeWinJS
	 */
	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _ReactStyleSheet = __webpack_require__(154);
	
	var _ReactStyleSheet2 = _interopRequireDefault(_ReactStyleSheet);
	
	// proxy origin react createElement
	_ReactStyleSheet2['default'].extendCreateElement(_react2['default']);
	
	var ReactNativeWinJS = _extends(Object.defineProperties({}, {
	  ActivityIndicatorIOS: {
	    // Components
	
	    get: function get() {
	      return __webpack_require__(163);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  DatePickerIOS: {
	    get: function get() {
	      return null;
	    },
	    configurable: true,
	    enumerable: true
	  },
	  DrawerLayoutAndroid: {
	    get: function get() {
	      return __webpack_require__(172);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  Image: {
	    get: function get() {
	      return __webpack_require__(233);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  ListView: {
	    get: function get() {
	      return __webpack_require__(248);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  Modal: {
	    get: function get() {
	      return __webpack_require__(255);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  Navigator: {
	    get: function get() {
	      return __webpack_require__(256);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  PickerIOS: {
	    get: function get() {
	      return __webpack_require__(306);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  ProgressViewIOS: {
	    get: function get() {
	      return __webpack_require__(307);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  ScrollView: {
	    get: function get() {
	      return __webpack_require__(308);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  SegmentedControlIOS: {
	    get: function get() {
	      return __webpack_require__(311);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  SliderIOS: {
	    get: function get() {
	      return __webpack_require__(312);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  Switch: {
	    get: function get() {
	      return __webpack_require__(313);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  SwitchAndroid: {
	    get: function get() {
	      return __webpack_require__(313);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  SwitchIOS: {
	    get: function get() {
	      return __webpack_require__(313);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  TabBarIOS: {
	    get: function get() {
	      return __webpack_require__(314);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  Text: {
	    get: function get() {
	      return __webpack_require__(236);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  TextInput: {
	    get: function get() {
	      return __webpack_require__(318);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  ToastAndroid: {
	    get: function get() {
	      return __webpack_require__(319);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  Touchable: {
	    get: function get() {
	      return __webpack_require__(237);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  TouchableHighlight: {
	    get: function get() {
	      return __webpack_require__(321);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  TouchableOpacity: {
	    get: function get() {
	      return __webpack_require__(323);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  TouchableWithoutFeedback: {
	    get: function get() {
	      return __webpack_require__(322);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  View: {
	    get: function get() {
	      return __webpack_require__(164);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  ViewPagerAndroid: {
	    get: function get() {
	      return __webpack_require__(324);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  Alert: {
	
	    // APIs
	
	    get: function get() {
	      return __webpack_require__(326);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  AlertIOS: {
	    get: function get() {
	      return __webpack_require__(326);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  Animated: {
	    get: function get() {
	      return __webpack_require__(173);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  AppRegistry: {
	    get: function get() {
	      return __webpack_require__(327);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  AsyncStorage: {
	    get: function get() {
	      return __webpack_require__(329);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  Dimensions: {
	    get: function get() {
	      return __webpack_require__(247);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  Easing: {
	    get: function get() {
	      return __webpack_require__(175);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  InteractionManager: {
	    get: function get() {
	      return __webpack_require__(178);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  PanResponder: {
	    get: function get() {
	      return __webpack_require__(240);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  PixelRatio: {
	    get: function get() {
	      return __webpack_require__(282);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  StyleSheet: {
	    get: function get() {
	      return __webpack_require__(154);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  NativeModules: {
	
	    // Plugins
	
	    get: function get() {
	      return __webpack_require__(335);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  Platform: {
	    get: function get() {
	      return __webpack_require__(278);
	    },
	    configurable: true,
	    enumerable: true
	  },
	  processColor: {
	    get: function get() {
	      return __webpack_require__(336);
	    },
	    configurable: true,
	    enumerable: true
	  }
	}), _react2['default']);
	
	module.exports = ReactNativeWinJS;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(3);


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule React
	 */
	
	'use strict';
	
	var ReactDOM = __webpack_require__(4);
	var ReactDOMServer = __webpack_require__(144);
	var ReactIsomorphic = __webpack_require__(148);
	
	var assign = __webpack_require__(39);
	var deprecated = __webpack_require__(153);
	
	// `version` will be added here by ReactIsomorphic.
	var React = {};
	
	assign(React, ReactIsomorphic);
	
	assign(React, {
	  // ReactDOM
	  findDOMNode: deprecated('findDOMNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.findDOMNode),
	  render: deprecated('render', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.render),
	  unmountComponentAtNode: deprecated('unmountComponentAtNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.unmountComponentAtNode),
	
	  // ReactDOMServer
	  renderToString: deprecated('renderToString', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToString),
	  renderToStaticMarkup: deprecated('renderToStaticMarkup', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToStaticMarkup)
	});
	
	React.__SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOM;
	React.__SECRET_DOM_SERVER_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOMServer;
	
	module.exports = React;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOM
	 */
	
	/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(5);
	var ReactDOMTextComponent = __webpack_require__(6);
	var ReactDefaultInjection = __webpack_require__(71);
	var ReactInstanceHandles = __webpack_require__(45);
	var ReactMount = __webpack_require__(28);
	var ReactPerf = __webpack_require__(18);
	var ReactReconciler = __webpack_require__(50);
	var ReactUpdates = __webpack_require__(54);
	var ReactVersion = __webpack_require__(142);
	
	var findDOMNode = __webpack_require__(91);
	var renderSubtreeIntoContainer = __webpack_require__(143);
	var warning = __webpack_require__(25);
	
	ReactDefaultInjection.inject();
	
	var render = ReactPerf.measure('React', 'render', ReactMount.render);
	
	var React = {
	  findDOMNode: findDOMNode,
	  render: render,
	  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
	  version: ReactVersion,
	
	  /* eslint-disable camelcase */
	  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
	  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
	};
	
	// Inject the runtime into a devtools global hook regardless of browser.
	// Allows for debugging when the hook is injected on the page.
	/* eslint-enable camelcase */
	if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
	    CurrentOwner: ReactCurrentOwner,
	    InstanceHandles: ReactInstanceHandles,
	    Mount: ReactMount,
	    Reconciler: ReactReconciler,
	    TextComponent: ReactDOMTextComponent
	  });
	}
	
	if (false) {
	  var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
	  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
	
	    // First check if devtools is not installed
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
	      // If we're in Chrome or Firefox, provide a download link if not installed.
	      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
	        console.debug('Download the React DevTools for a better development experience: ' + 'https://fb.me/react-devtools');
	      }
	    }
	
	    // If we're in IE8, check to see if we are in compatibility mode and provide
	    // information on preventing compatibility mode
	    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;
	
	    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : undefined;
	
	    var expectedFeatures = [
	    // shims
	    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim,
	
	    // shams
	    Object.create, Object.freeze];
	
	    for (var i = 0; i < expectedFeatures.length; i++) {
	      if (!expectedFeatures[i]) {
	        console.error('One or more ES5 shim/shams expected by React are not available: ' + 'https://fb.me/react-warning-polyfills');
	        break;
	      }
	    }
	  }
	}
	
	module.exports = React;

/***/ },
/* 5 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCurrentOwner
	 */
	
	'use strict';
	
	/**
	 * Keeps track of the current owner.
	 *
	 * The current owner is the component who should own any components that are
	 * currently being constructed.
	 */
	var ReactCurrentOwner = {
	
	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null
	
	};
	
	module.exports = ReactCurrentOwner;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextComponent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(7);
	var DOMPropertyOperations = __webpack_require__(22);
	var ReactComponentBrowserEnvironment = __webpack_require__(26);
	var ReactMount = __webpack_require__(28);
	
	var assign = __webpack_require__(39);
	var escapeTextContentForBrowser = __webpack_require__(21);
	var setTextContent = __webpack_require__(20);
	var validateDOMNesting = __webpack_require__(70);
	
	/**
	 * Text nodes violate a couple assumptions that React makes about components:
	 *
	 *  - When mounting text into the DOM, adjacent text nodes are merged.
	 *  - Text nodes cannot be assigned a React root ID.
	 *
	 * This component is used to wrap strings in elements so that they can undergo
	 * the same reconciliation that is applied to elements.
	 *
	 * TODO: Investigate representing React components in the DOM with text nodes.
	 *
	 * @class ReactDOMTextComponent
	 * @extends ReactComponent
	 * @internal
	 */
	var ReactDOMTextComponent = function (props) {
	  // This constructor and its argument is currently used by mocks.
	};
	
	assign(ReactDOMTextComponent.prototype, {
	
	  /**
	   * @param {ReactText} text
	   * @internal
	   */
	  construct: function (text) {
	    // TODO: This is really a ReactText (ReactNode), not a ReactElement
	    this._currentElement = text;
	    this._stringText = '' + text;
	
	    // Properties
	    this._rootNodeID = null;
	    this._mountIndex = 0;
	  },
	
	  /**
	   * Creates the markup for this text node. This node is not intended to have
	   * any features besides containing text content.
	   *
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} Markup for this text node.
	   * @internal
	   */
	  mountComponent: function (rootID, transaction, context) {
	    if (false) {
	      if (context[validateDOMNesting.ancestorInfoContextKey]) {
	        validateDOMNesting('span', null, context[validateDOMNesting.ancestorInfoContextKey]);
	      }
	    }
	
	    this._rootNodeID = rootID;
	    if (transaction.useCreateElement) {
	      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
	      var el = ownerDocument.createElement('span');
	      DOMPropertyOperations.setAttributeForID(el, rootID);
	      // Populate node cache
	      ReactMount.getID(el);
	      setTextContent(el, this._stringText);
	      return el;
	    } else {
	      var escapedText = escapeTextContentForBrowser(this._stringText);
	
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd wrap this in a `span` for the reasons stated above, but
	        // since this is a situation where React won't take over (static pages),
	        // we can simply return the text as it is.
	        return escapedText;
	      }
	
	      return '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>';
	    }
	  },
	
	  /**
	   * Updates this component by updating the text content.
	   *
	   * @param {ReactText} nextText The next text content
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  receiveComponent: function (nextText, transaction) {
	    if (nextText !== this._currentElement) {
	      this._currentElement = nextText;
	      var nextStringText = '' + nextText;
	      if (nextStringText !== this._stringText) {
	        // TODO: Save this as pending props and use performUpdateIfNecessary
	        // and/or updateComponent to do the actual update for consistency with
	        // other component types?
	        this._stringText = nextStringText;
	        var node = ReactMount.getNode(this._rootNodeID);
	        DOMChildrenOperations.updateTextContent(node, nextStringText);
	      }
	    }
	  },
	
	  unmountComponent: function () {
	    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
	  }
	
	});
	
	module.exports = ReactDOMTextComponent;

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMChildrenOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var Danger = __webpack_require__(8);
	var ReactMultiChildUpdateTypes = __webpack_require__(16);
	var ReactPerf = __webpack_require__(18);
	
	var setInnerHTML = __webpack_require__(19);
	var setTextContent = __webpack_require__(20);
	var invariant = __webpack_require__(13);
	
	/**
	 * Inserts `childNode` as a child of `parentNode` at the `index`.
	 *
	 * @param {DOMElement} parentNode Parent node in which to insert.
	 * @param {DOMElement} childNode Child node to insert.
	 * @param {number} index Index at which to insert the child.
	 * @internal
	 */
	function insertChildAt(parentNode, childNode, index) {
	  // By exploiting arrays returning `undefined` for an undefined index, we can
	  // rely exclusively on `insertBefore(node, null)` instead of also using
	  // `appendChild(node)`. However, using `undefined` is not allowed by all
	  // browsers so we must replace it with `null`.
	
	  // fix render order error in safari
	  // IE8 will throw error when index out of list size.
	  var beforeChild = index >= parentNode.childNodes.length ? null : parentNode.childNodes.item(index);
	
	  parentNode.insertBefore(childNode, beforeChild);
	}
	
	/**
	 * Operations for updating with DOM children.
	 */
	var DOMChildrenOperations = {
	
	  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,
	
	  updateTextContent: setTextContent,
	
	  /**
	   * Updates a component's children by processing a series of updates. The
	   * update configurations are each expected to have a `parentNode` property.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @param {array<string>} markupList List of markup strings.
	   * @internal
	   */
	  processUpdates: function (updates, markupList) {
	    var update;
	    // Mapping from parent IDs to initial child orderings.
	    var initialChildren = null;
	    // List of children that will be moved or removed.
	    var updatedChildren = null;
	
	    for (var i = 0; i < updates.length; i++) {
	      update = updates[i];
	      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
	        var updatedIndex = update.fromIndex;
	        var updatedChild = update.parentNode.childNodes[updatedIndex];
	        var parentID = update.parentID;
	
	        !updatedChild ?  false ? invariant(false, 'processUpdates(): Unable to find child %s of element. This ' + 'probably means the DOM was unexpectedly mutated (e.g., by the ' + 'browser), usually due to forgetting a <tbody> when using tables, ' + 'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' + 'in an <svg> parent. Try inspecting the child nodes of the element ' + 'with React ID `%s`.', updatedIndex, parentID) : invariant(false) : undefined;
	
	        initialChildren = initialChildren || {};
	        initialChildren[parentID] = initialChildren[parentID] || [];
	        initialChildren[parentID][updatedIndex] = updatedChild;
	
	        updatedChildren = updatedChildren || [];
	        updatedChildren.push(updatedChild);
	      }
	    }
	
	    var renderedMarkup;
	    // markupList is either a list of markup or just a list of elements
	    if (markupList.length && typeof markupList[0] === 'string') {
	      renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);
	    } else {
	      renderedMarkup = markupList;
	    }
	
	    // Remove updated children first so that `toIndex` is consistent.
	    if (updatedChildren) {
	      for (var j = 0; j < updatedChildren.length; j++) {
	        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
	      }
	    }
	
	    for (var k = 0; k < updates.length; k++) {
	      update = updates[k];
	      switch (update.type) {
	        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
	          insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);
	          break;
	        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
	          insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
	          break;
	        case ReactMultiChildUpdateTypes.SET_MARKUP:
	          setInnerHTML(update.parentNode, update.content);
	          break;
	        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
	          setTextContent(update.parentNode, update.content);
	          break;
	        case ReactMultiChildUpdateTypes.REMOVE_NODE:
	          // Already removed by the for-loop above.
	          break;
	      }
	    }
	  }
	
	};
	
	ReactPerf.measureMethods(DOMChildrenOperations, 'DOMChildrenOperations', {
	  updateTextContent: 'updateTextContent'
	});
	
	module.exports = DOMChildrenOperations;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Danger
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var createNodesFromMarkup = __webpack_require__(10);
	var emptyFunction = __webpack_require__(15);
	var getMarkupWrap = __webpack_require__(14);
	var invariant = __webpack_require__(13);
	
	var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
	var RESULT_INDEX_ATTR = 'data-danger-index';
	
	/**
	 * Extracts the `nodeName` from a string of markup.
	 *
	 * NOTE: Extracting the `nodeName` does not require a regular expression match
	 * because we make assumptions about React-generated markup (i.e. there are no
	 * spaces surrounding the opening tag and there is at least one attribute).
	 *
	 * @param {string} markup String of markup.
	 * @return {string} Node name of the supplied markup.
	 * @see http://jsperf.com/extract-nodename
	 */
	function getNodeName(markup) {
	  return markup.substring(1, markup.indexOf(' '));
	}
	
	var Danger = {
	
	  /**
	   * Renders markup into an array of nodes. The markup is expected to render
	   * into a list of root nodes. Also, the length of `resultList` and
	   * `markupList` should be the same.
	   *
	   * @param {array<string>} markupList List of markup strings to render.
	   * @return {array<DOMElement>} List of rendered nodes.
	   * @internal
	   */
	  dangerouslyRenderMarkup: function (markupList) {
	    !ExecutionEnvironment.canUseDOM ?  false ? invariant(false, 'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' + 'thread. Make sure `window` and `document` are available globally ' + 'before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString for server rendering.') : invariant(false) : undefined;
	    var nodeName;
	    var markupByNodeName = {};
	    // Group markup by `nodeName` if a wrap is necessary, else by '*'.
	    for (var i = 0; i < markupList.length; i++) {
	      !markupList[i] ?  false ? invariant(false, 'dangerouslyRenderMarkup(...): Missing markup.') : invariant(false) : undefined;
	      nodeName = getNodeName(markupList[i]);
	      nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
	      markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
	      markupByNodeName[nodeName][i] = markupList[i];
	    }
	    var resultList = [];
	    var resultListAssignmentCount = 0;
	    for (nodeName in markupByNodeName) {
	      if (!markupByNodeName.hasOwnProperty(nodeName)) {
	        continue;
	      }
	      var markupListByNodeName = markupByNodeName[nodeName];
	
	      // This for-in loop skips the holes of the sparse array. The order of
	      // iteration should follow the order of assignment, which happens to match
	      // numerical index order, but we don't rely on that.
	      var resultIndex;
	      for (resultIndex in markupListByNodeName) {
	        if (markupListByNodeName.hasOwnProperty(resultIndex)) {
	          var markup = markupListByNodeName[resultIndex];
	
	          // Push the requested markup with an additional RESULT_INDEX_ATTR
	          // attribute.  If the markup does not start with a < character, it
	          // will be discarded below (with an appropriate console.error).
	          markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP,
	          // This index will be parsed back out below.
	          '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" ');
	        }
	      }
	
	      // Render each group of markup with similar wrapping `nodeName`.
	      var renderNodes = createNodesFromMarkup(markupListByNodeName.join(''), emptyFunction // Do nothing special with <script> tags.
	      );
	
	      for (var j = 0; j < renderNodes.length; ++j) {
	        var renderNode = renderNodes[j];
	        if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {
	
	          resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
	          renderNode.removeAttribute(RESULT_INDEX_ATTR);
	
	          !!resultList.hasOwnProperty(resultIndex) ?  false ? invariant(false, 'Danger: Assigning to an already-occupied result index.') : invariant(false) : undefined;
	
	          resultList[resultIndex] = renderNode;
	
	          // This should match resultList.length and markupList.length when
	          // we're done.
	          resultListAssignmentCount += 1;
	        } else if (false) {
	          console.error('Danger: Discarding unexpected node:', renderNode);
	        }
	      }
	    }
	
	    // Although resultList was populated out of order, it should now be a dense
	    // array.
	    !(resultListAssignmentCount === resultList.length) ?  false ? invariant(false, 'Danger: Did not assign to every index of resultList.') : invariant(false) : undefined;
	
	    !(resultList.length === markupList.length) ?  false ? invariant(false, 'Danger: Expected markup to render %s nodes, but rendered %s.', markupList.length, resultList.length) : invariant(false) : undefined;
	
	    return resultList;
	  },
	
	  /**
	   * Replaces a node with a string of markup at its current position within its
	   * parent. The markup must render into a single root node.
	   *
	   * @param {DOMElement} oldChild Child node to replace.
	   * @param {string} markup Markup to render in place of the child node.
	   * @internal
	   */
	  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
	    !ExecutionEnvironment.canUseDOM ?  false ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' + 'worker thread. Make sure `window` and `document` are available ' + 'globally before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;
	    !markup ?  false ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(false) : undefined;
	    !(oldChild.tagName.toLowerCase() !== 'html') ?  false ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' + '<html> node. This is because browser quirks make this unreliable ' + 'and/or slow. If you want to render to the root you must use ' + 'server rendering. See ReactDOMServer.renderToString().') : invariant(false) : undefined;
	
	    var newChild;
	    if (typeof markup === 'string') {
	      newChild = createNodesFromMarkup(markup, emptyFunction)[0];
	    } else {
	      newChild = markup;
	    }
	    oldChild.parentNode.replaceChild(newChild, oldChild);
	  }
	
	};
	
	module.exports = Danger;

/***/ },
/* 9 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ExecutionEnvironment
	 */
	
	'use strict';
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {
	
	  canUseDOM: canUseDOM,
	
	  canUseWorkers: typeof Worker !== 'undefined',
	
	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
	
	  canUseViewport: canUseDOM && !!window.screen,
	
	  isInWorker: !canUseDOM // For now, this is true - might change in the future.
	
	};
	
	module.exports = ExecutionEnvironment;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createNodesFromMarkup
	 * @typechecks
	 */
	
	/*eslint-disable fb-www/unsafe-html*/
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var createArrayFromMixed = __webpack_require__(11);
	var getMarkupWrap = __webpack_require__(14);
	var invariant = __webpack_require__(13);
	
	/**
	 * Dummy container used to render all markup.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Pattern used by `getNodeName`.
	 */
	var nodeNamePattern = /^\s*<(\w+)/;
	
	/**
	 * Extracts the `nodeName` of the first element in a string of markup.
	 *
	 * @param {string} markup String of markup.
	 * @return {?string} Node name of the supplied markup.
	 */
	function getNodeName(markup) {
	  var nodeNameMatch = markup.match(nodeNamePattern);
	  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
	}
	
	/**
	 * Creates an array containing the nodes rendered from the supplied markup. The
	 * optionally supplied `handleScript` function will be invoked once for each
	 * <script> element that is rendered. If no `handleScript` function is supplied,
	 * an exception is thrown if any <script> elements are rendered.
	 *
	 * @param {string} markup A string of valid HTML markup.
	 * @param {?function} handleScript Invoked once for each rendered <script>.
	 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
	 */
	function createNodesFromMarkup(markup, handleScript) {
	  var node = dummyNode;
	  !!!dummyNode ?  false ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : undefined;
	  var nodeName = getNodeName(markup);
	
	  var wrap = nodeName && getMarkupWrap(nodeName);
	  if (wrap) {
	    node.innerHTML = wrap[1] + markup + wrap[2];
	
	    var wrapDepth = wrap[0];
	    while (wrapDepth--) {
	      node = node.lastChild;
	    }
	  } else {
	    node.innerHTML = markup;
	  }
	
	  var scripts = node.getElementsByTagName('script');
	  if (scripts.length) {
	    !handleScript ?  false ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : undefined;
	    createArrayFromMixed(scripts).forEach(handleScript);
	  }
	
	  var nodes = createArrayFromMixed(node.childNodes);
	  while (node.lastChild) {
	    node.removeChild(node.lastChild);
	  }
	  return nodes;
	}
	
	module.exports = createNodesFromMarkup;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createArrayFromMixed
	 * @typechecks
	 */
	
	'use strict';
	
	var toArray = __webpack_require__(12);
	
	/**
	 * Perform a heuristic test to determine if an object is "array-like".
	 *
	 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
	 *   Joshu replied: "Mu."
	 *
	 * This function determines if its argument has "array nature": it returns
	 * true if the argument is an actual array, an `arguments' object, or an
	 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
	 *
	 * It will return false for other array-like objects like Filelist.
	 *
	 * @param {*} obj
	 * @return {boolean}
	 */
	function hasArrayNature(obj) {
	  return(
	    // not null/false
	    !!obj && (
	    // arrays are objects, NodeLists are functions in Safari
	    typeof obj == 'object' || typeof obj == 'function') &&
	    // quacks like an array
	    'length' in obj &&
	    // not window
	    !('setInterval' in obj) &&
	    // no DOM node should be considered an array-like
	    // a 'select' element has 'length' and 'item' properties on IE8
	    typeof obj.nodeType != 'number' && (
	    // a real array
	    Array.isArray(obj) ||
	    // arguments
	    'callee' in obj ||
	    // HTMLCollection/NodeList
	    'item' in obj)
	  );
	}
	
	/**
	 * Ensure that the argument is an array by wrapping it in an array if it is not.
	 * Creates a copy of the argument if it is already an array.
	 *
	 * This is mostly useful idiomatically:
	 *
	 *   var createArrayFromMixed = require('createArrayFromMixed');
	 *
	 *   function takesOneOrMoreThings(things) {
	 *     things = createArrayFromMixed(things);
	 *     ...
	 *   }
	 *
	 * This allows you to treat `things' as an array, but accept scalars in the API.
	 *
	 * If you need to convert an array-like object, like `arguments`, into an array
	 * use toArray instead.
	 *
	 * @param {*} obj
	 * @return {array}
	 */
	function createArrayFromMixed(obj) {
	  if (!hasArrayNature(obj)) {
	    return [obj];
	  } else if (Array.isArray(obj)) {
	    return obj.slice();
	  } else {
	    return toArray(obj);
	  }
	}
	
	module.exports = createArrayFromMixed;

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule toArray
	 * @typechecks
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(13);
	
	/**
	 * Convert array-like objects to arrays.
	 *
	 * This API assumes the caller knows the contents of the data type. For less
	 * well defined inputs use createArrayFromMixed.
	 *
	 * @param {object|function|filelist} obj
	 * @return {array}
	 */
	function toArray(obj) {
	  var length = obj.length;
	
	  // Some browse builtin objects can report typeof 'function' (e.g. NodeList in
	  // old versions of Safari).
	  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ?  false ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : undefined;
	
	  !(typeof length === 'number') ?  false ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : undefined;
	
	  !(length === 0 || length - 1 in obj) ?  false ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : undefined;
	
	  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
	  // without method will throw during the slice call and skip straight to the
	  // fallback.
	  if (obj.hasOwnProperty) {
	    try {
	      return Array.prototype.slice.call(obj);
	    } catch (e) {
	      // IE < 9 does not support Array#slice on collections objects
	    }
	  }
	
	  // Fall back to copying key by key. This assumes all keys have a value,
	  // so will not preserve sparsely populated inputs.
	  var ret = Array(length);
	  for (var ii = 0; ii < length; ii++) {
	    ret[ii] = obj[ii];
	  }
	  return ret;
	}
	
	module.exports = toArray;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule invariant
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	function invariant(condition, format, a, b, c, d, e, f) {
	  if (false) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}
	
	module.exports = invariant;

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getMarkupWrap
	 */
	
	/*eslint-disable fb-www/unsafe-html */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var invariant = __webpack_require__(13);
	
	/**
	 * Dummy container used to detect which wraps are necessary.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Some browsers cannot use `innerHTML` to render certain elements standalone,
	 * so we wrap them, render the wrapped nodes, then extract the desired node.
	 *
	 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
	 */
	
	var shouldWrap = {};
	
	var selectWrap = [1, '<select multiple="true">', '</select>'];
	var tableWrap = [1, '<table>', '</table>'];
	var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];
	
	var markupWrap = {
	  '*': [1, '?<div>', '</div>'],
	
	  'area': [1, '<map>', '</map>'],
	  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
	  'legend': [1, '<fieldset>', '</fieldset>'],
	  'param': [1, '<object>', '</object>'],
	  'tr': [2, '<table><tbody>', '</tbody></table>'],
	
	  'optgroup': selectWrap,
	  'option': selectWrap,
	
	  'caption': tableWrap,
	  'colgroup': tableWrap,
	  'tbody': tableWrap,
	  'tfoot': tableWrap,
	  'thead': tableWrap,
	
	  'td': trWrap,
	  'th': trWrap
	};
	
	// Initialize the SVG elements since we know they'll always need to be wrapped
	// consistently. If they are created inside a <div> they will be initialized in
	// the wrong namespace (and will not display).
	var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
	svgElements.forEach(function (nodeName) {
	  markupWrap[nodeName] = svgWrap;
	  shouldWrap[nodeName] = true;
	});
	
	/**
	 * Gets the markup wrap configuration for the supplied `nodeName`.
	 *
	 * NOTE: This lazily detects which wraps are necessary for the current browser.
	 *
	 * @param {string} nodeName Lowercase `nodeName`.
	 * @return {?array} Markup wrap configuration, if applicable.
	 */
	function getMarkupWrap(nodeName) {
	  !!!dummyNode ?  false ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : undefined;
	  if (!markupWrap.hasOwnProperty(nodeName)) {
	    nodeName = '*';
	  }
	  if (!shouldWrap.hasOwnProperty(nodeName)) {
	    if (nodeName === '*') {
	      dummyNode.innerHTML = '<link />';
	    } else {
	      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
	    }
	    shouldWrap[nodeName] = !dummyNode.firstChild;
	  }
	  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
	}
	
	module.exports = getMarkupWrap;

/***/ },
/* 15 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyFunction
	 */
	
	"use strict";
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	function emptyFunction() {}
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChildUpdateTypes
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(17);
	
	/**
	 * When a component's children are updated, a series of update configuration
	 * objects are created in order to batch and serialize the required changes.
	 *
	 * Enumerates all the possible types of update configurations.
	 *
	 * @internal
	 */
	var ReactMultiChildUpdateTypes = keyMirror({
	  INSERT_MARKUP: null,
	  MOVE_EXISTING: null,
	  REMOVE_NODE: null,
	  SET_MARKUP: null,
	  TEXT_CONTENT: null
	});
	
	module.exports = ReactMultiChildUpdateTypes;

/***/ },
/* 17 */
[390, 13],
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPerf
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * ReactPerf is a general AOP system designed to measure performance. This
	 * module only has the hooks: see ReactDefaultPerf for the analysis tool.
	 */
	var ReactPerf = {
	  /**
	   * Boolean to enable/disable measurement. Set to false by default to prevent
	   * accidental logging and perf loss.
	   */
	  enableMeasure: false,
	
	  /**
	   * Holds onto the measure function in use. By default, don't measure
	   * anything, but we'll override this if we inject a measure function.
	   */
	  storedMeasure: _noMeasure,
	
	  /**
	   * @param {object} object
	   * @param {string} objectName
	   * @param {object<string>} methodNames
	   */
	  measureMethods: function (object, objectName, methodNames) {
	    if (false) {
	      for (var key in methodNames) {
	        if (!methodNames.hasOwnProperty(key)) {
	          continue;
	        }
	        object[key] = ReactPerf.measure(objectName, methodNames[key], object[key]);
	      }
	    }
	  },
	
	  /**
	   * Use this to wrap methods you want to measure. Zero overhead in production.
	   *
	   * @param {string} objName
	   * @param {string} fnName
	   * @param {function} func
	   * @return {function}
	   */
	  measure: function (objName, fnName, func) {
	    if (false) {
	      var measuredFunc = null;
	      var wrapper = function () {
	        if (ReactPerf.enableMeasure) {
	          if (!measuredFunc) {
	            measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
	          }
	          return measuredFunc.apply(this, arguments);
	        }
	        return func.apply(this, arguments);
	      };
	      wrapper.displayName = objName + '_' + fnName;
	      return wrapper;
	    }
	    return func;
	  },
	
	  injection: {
	    /**
	     * @param {function} measure
	     */
	    injectMeasure: function (measure) {
	      ReactPerf.storedMeasure = measure;
	    }
	  }
	};
	
	/**
	 * Simply passes through the measured function, without measuring it.
	 *
	 * @param {string} objName
	 * @param {string} fnName
	 * @param {function} func
	 * @return {function}
	 */
	function _noMeasure(objName, fnName, func) {
	  return func;
	}
	
	module.exports = ReactPerf;

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setInnerHTML
	 */
	
	/* globals MSApp */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var WHITESPACE_TEST = /^[ \r\n\t\f]/;
	var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
	
	/**
	 * Set the innerHTML property of a node, ensuring that whitespace is preserved
	 * even in IE8.
	 *
	 * @param {DOMElement} node
	 * @param {string} html
	 * @internal
	 */
	var setInnerHTML = function (node, html) {
	  node.innerHTML = html;
	};
	
	// Win8 apps: Allow all html to be inserted
	if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
	  setInnerHTML = function (node, html) {
	    MSApp.execUnsafeLocalFunction(function () {
	      node.innerHTML = html;
	    });
	  };
	}
	
	if (ExecutionEnvironment.canUseDOM) {
	  // IE8: When updating a just created node with innerHTML only leading
	  // whitespace is removed. When updating an existing node with innerHTML
	  // whitespace in root TextNodes is also collapsed.
	  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html
	
	  // Feature detection; only IE8 is known to behave improperly like this.
	  var testElement = document.createElement('div');
	  testElement.innerHTML = ' ';
	  if (testElement.innerHTML === '') {
	    setInnerHTML = function (node, html) {
	      // Magic theory: IE8 supposedly differentiates between added and updated
	      // nodes when processing innerHTML, innerHTML on updated nodes suffers
	      // from worse whitespace behavior. Re-adding a node like this triggers
	      // the initial and more favorable whitespace behavior.
	      // TODO: What to do on a detached node?
	      if (node.parentNode) {
	        node.parentNode.replaceChild(node, node);
	      }
	
	      // We also implement a workaround for non-visible tags disappearing into
	      // thin air on IE8, this only happens if there is no visible text
	      // in-front of the non-visible tags. Piggyback on the whitespace fix
	      // and simply check if any non-visible tags appear in the source.
	      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
	        // Recover leading whitespace by temporarily prepending any character.
	        // \uFEFF has the potential advantage of being zero-width/invisible.
	        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
	        // in hopes that this is preserved even if "\uFEFF" is transformed to
	        // the actual Unicode character (by Babel, for example).
	        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
	        node.innerHTML = String.fromCharCode(0xFEFF) + html;
	
	        // deleteData leaves an empty `TextNode` which offsets the index of all
	        // children. Definitely want to avoid this.
	        var textNode = node.firstChild;
	        if (textNode.data.length === 1) {
	          node.removeChild(textNode);
	        } else {
	          textNode.deleteData(0, 1);
	        }
	      } else {
	        node.innerHTML = html;
	      }
	    };
	  }
	}
	
	module.exports = setInnerHTML;

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setTextContent
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	var escapeTextContentForBrowser = __webpack_require__(21);
	var setInnerHTML = __webpack_require__(19);
	
	/**
	 * Set the textContent property of a node, ensuring that whitespace is preserved
	 * even in IE8. innerText is a poor substitute for textContent and, among many
	 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
	 * as it should.
	 *
	 * @param {DOMElement} node
	 * @param {string} text
	 * @internal
	 */
	var setTextContent = function (node, text) {
	  node.textContent = text;
	};
	
	if (ExecutionEnvironment.canUseDOM) {
	  if (!('textContent' in document.documentElement)) {
	    setTextContent = function (node, text) {
	      setInnerHTML(node, escapeTextContentForBrowser(text));
	    };
	  }
	}
	
	module.exports = setTextContent;

/***/ },
/* 21 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule escapeTextContentForBrowser
	 */
	
	'use strict';
	
	var ESCAPE_LOOKUP = {
	  '&': '&amp;',
	  '>': '&gt;',
	  '<': '&lt;',
	  '"': '&quot;',
	  '\'': '&#x27;'
	};
	
	var ESCAPE_REGEX = /[&><"']/g;
	
	function escaper(match) {
	  return ESCAPE_LOOKUP[match];
	}
	
	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escapeTextContentForBrowser(text) {
	  return ('' + text).replace(ESCAPE_REGEX, escaper);
	}
	
	module.exports = escapeTextContentForBrowser;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMPropertyOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(23);
	var ReactPerf = __webpack_require__(18);
	
	var quoteAttributeValueForBrowser = __webpack_require__(24);
	var warning = __webpack_require__(25);
	
	// Simplified subset
	var VALID_ATTRIBUTE_NAME_REGEX = /^[a-zA-Z_][\w\.\-]*$/;
	var illegalAttributeNameCache = {};
	var validatedAttributeNameCache = {};
	
	function isAttributeNameSafe(attributeName) {
	  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
	    return true;
	  }
	  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
	    return false;
	  }
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
	    validatedAttributeNameCache[attributeName] = true;
	    return true;
	  }
	  illegalAttributeNameCache[attributeName] = true;
	   false ? warning(false, 'Invalid attribute name: `%s`', attributeName) : undefined;
	  return false;
	}
	
	function shouldIgnoreValue(propertyInfo, value) {
	  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
	}
	
	if (false) {
	  var reactProps = {
	    children: true,
	    dangerouslySetInnerHTML: true,
	    key: true,
	    ref: true
	  };
	  var warnedProperties = {};
	
	  var warnUnknownProperty = function (name) {
	    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	      return;
	    }
	
	    warnedProperties[name] = true;
	    var lowerCasedName = name.toLowerCase();
	
	    // data-* attributes should be lowercase; suggest the lowercase version
	    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
	
	    // For now, only warn when we have a suggested correction. This prevents
	    // logging too much when using transferPropsTo.
	    process.env.NODE_ENV !== 'production' ? warning(standardName == null, 'Unknown DOM property %s. Did you mean %s?', name, standardName) : undefined;
	  };
	}
	
	/**
	 * Operations for dealing with DOM properties.
	 */
	var DOMPropertyOperations = {
	
	  /**
	   * Creates markup for the ID property.
	   *
	   * @param {string} id Unescaped ID.
	   * @return {string} Markup string.
	   */
	  createMarkupForID: function (id) {
	    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
	  },
	
	  setAttributeForID: function (node, id) {
	    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
	  },
	
	  /**
	   * Creates markup for a property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {?string} Markup string, or null if the property was invalid.
	   */
	  createMarkupForProperty: function (name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      if (shouldIgnoreValue(propertyInfo, value)) {
	        return '';
	      }
	      var attributeName = propertyInfo.attributeName;
	      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	        return attributeName + '=""';
	      }
	      return attributeName + '=' + quoteAttributeValueForBrowser(value);
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      if (value == null) {
	        return '';
	      }
	      return name + '=' + quoteAttributeValueForBrowser(value);
	    } else if (false) {
	      warnUnknownProperty(name);
	    }
	    return null;
	  },
	
	  /**
	   * Creates markup for a custom property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {string} Markup string, or empty string if the property was invalid.
	   */
	  createMarkupForCustomAttribute: function (name, value) {
	    if (!isAttributeNameSafe(name) || value == null) {
	      return '';
	    }
	    return name + '=' + quoteAttributeValueForBrowser(value);
	  },
	
	  /**
	   * Sets the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   * @param {*} value
	   */
	  setValueForProperty: function (node, name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, value);
	      } else if (shouldIgnoreValue(propertyInfo, value)) {
	        this.deleteValueForProperty(node, name);
	      } else if (propertyInfo.mustUseAttribute) {
	        var attributeName = propertyInfo.attributeName;
	        var namespace = propertyInfo.attributeNamespace;
	        // `setAttribute` with objects becomes only `[object]` in IE8/9,
	        // ('' + value) makes it output the correct toString()-value.
	        if (namespace) {
	          node.setAttributeNS(namespace, attributeName, '' + value);
	        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	          node.setAttribute(attributeName, '');
	        } else {
	          node.setAttribute(attributeName, '' + value);
	        }
	      } else {
	        var propName = propertyInfo.propertyName;
	        // Must explicitly cast values for HAS_SIDE_EFFECTS-properties to the
	        // property type before comparing; only `value` does and is string.
	        if (!propertyInfo.hasSideEffects || '' + node[propName] !== '' + value) {
	          // Contrary to `setAttribute`, object properties are properly
	          // `toString`ed by IE8/9.
	          node[propName] = value;
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      DOMPropertyOperations.setValueForAttribute(node, name, value);
	    } else if (false) {
	      warnUnknownProperty(name);
	    }
	  },
	
	  setValueForAttribute: function (node, name, value) {
	    if (!isAttributeNameSafe(name)) {
	      return;
	    }
	    if (value == null) {
	      node.removeAttribute(name);
	    } else {
	      node.setAttribute(name, '' + value);
	    }
	  },
	
	  /**
	   * Deletes the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForProperty: function (node, name) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, undefined);
	      } else if (propertyInfo.mustUseAttribute) {
	        node.removeAttribute(propertyInfo.attributeName);
	      } else {
	        var propName = propertyInfo.propertyName;
	        var defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);
	        if (!propertyInfo.hasSideEffects || '' + node[propName] !== defaultValue) {
	          node[propName] = defaultValue;
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      node.removeAttribute(name);
	    } else if (false) {
	      warnUnknownProperty(name);
	    }
	  }
	
	};
	
	ReactPerf.measureMethods(DOMPropertyOperations, 'DOMPropertyOperations', {
	  setValueForProperty: 'setValueForProperty',
	  setValueForAttribute: 'setValueForAttribute',
	  deleteValueForProperty: 'deleteValueForProperty'
	});
	
	module.exports = DOMPropertyOperations;

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMProperty
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(13);
	
	function checkMask(value, bitmask) {
	  return (value & bitmask) === bitmask;
	}
	
	var DOMPropertyInjection = {
	  /**
	   * Mapping from normalized, camelcased property names to a configuration that
	   * specifies how the associated DOM property should be accessed or rendered.
	   */
	  MUST_USE_ATTRIBUTE: 0x1,
	  MUST_USE_PROPERTY: 0x2,
	  HAS_SIDE_EFFECTS: 0x4,
	  HAS_BOOLEAN_VALUE: 0x8,
	  HAS_NUMERIC_VALUE: 0x10,
	  HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,
	  HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,
	
	  /**
	   * Inject some specialized knowledge about the DOM. This takes a config object
	   * with the following properties:
	   *
	   * isCustomAttribute: function that given an attribute name will return true
	   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
	   * attributes where it's impossible to enumerate all of the possible
	   * attribute names,
	   *
	   * Properties: object mapping DOM property name to one of the
	   * DOMPropertyInjection constants or null. If your attribute isn't in here,
	   * it won't get written to the DOM.
	   *
	   * DOMAttributeNames: object mapping React attribute name to the DOM
	   * attribute name. Attribute names not specified use the **lowercase**
	   * normalized name.
	   *
	   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
	   * attribute namespace URL. (Attribute names not specified use no namespace.)
	   *
	   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
	   * Property names not specified use the normalized name.
	   *
	   * DOMMutationMethods: Properties that require special mutation methods. If
	   * `value` is undefined, the mutation method should unset the property.
	   *
	   * @param {object} domPropertyConfig the config as described above.
	   */
	  injectDOMPropertyConfig: function (domPropertyConfig) {
	    var Injection = DOMPropertyInjection;
	    var Properties = domPropertyConfig.Properties || {};
	    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
	    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
	    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
	    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
	
	    if (domPropertyConfig.isCustomAttribute) {
	      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
	    }
	
	    for (var propName in Properties) {
	      !!DOMProperty.properties.hasOwnProperty(propName) ?  false ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' + '\'%s\' which has already been injected. You may be accidentally ' + 'injecting the same DOM property config twice, or you may be ' + 'injecting two configs that have conflicting property names.', propName) : invariant(false) : undefined;
	
	      var lowerCased = propName.toLowerCase();
	      var propConfig = Properties[propName];
	
	      var propertyInfo = {
	        attributeName: lowerCased,
	        attributeNamespace: null,
	        propertyName: propName,
	        mutationMethod: null,
	
	        mustUseAttribute: checkMask(propConfig, Injection.MUST_USE_ATTRIBUTE),
	        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
	        hasSideEffects: checkMask(propConfig, Injection.HAS_SIDE_EFFECTS),
	        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
	        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
	        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
	        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
	      };
	
	      !(!propertyInfo.mustUseAttribute || !propertyInfo.mustUseProperty) ?  false ? invariant(false, 'DOMProperty: Cannot require using both attribute and property: %s', propName) : invariant(false) : undefined;
	      !(propertyInfo.mustUseProperty || !propertyInfo.hasSideEffects) ?  false ? invariant(false, 'DOMProperty: Properties that have side effects must use property: %s', propName) : invariant(false) : undefined;
	      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ?  false ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or ' + 'numeric value, but not a combination: %s', propName) : invariant(false) : undefined;
	
	      if (false) {
	        DOMProperty.getPossibleStandardName[lowerCased] = propName;
	      }
	
	      if (DOMAttributeNames.hasOwnProperty(propName)) {
	        var attributeName = DOMAttributeNames[propName];
	        propertyInfo.attributeName = attributeName;
	        if (false) {
	          DOMProperty.getPossibleStandardName[attributeName] = propName;
	        }
	      }
	
	      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
	        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
	      }
	
	      if (DOMPropertyNames.hasOwnProperty(propName)) {
	        propertyInfo.propertyName = DOMPropertyNames[propName];
	      }
	
	      if (DOMMutationMethods.hasOwnProperty(propName)) {
	        propertyInfo.mutationMethod = DOMMutationMethods[propName];
	      }
	
	      DOMProperty.properties[propName] = propertyInfo;
	    }
	  }
	};
	var defaultValueCache = {};
	
	/**
	 * DOMProperty exports lookup objects that can be used like functions:
	 *
	 *   > DOMProperty.isValid['id']
	 *   true
	 *   > DOMProperty.isValid['foobar']
	 *   undefined
	 *
	 * Although this may be confusing, it performs better in general.
	 *
	 * @see http://jsperf.com/key-exists
	 * @see http://jsperf.com/key-missing
	 */
	var DOMProperty = {
	
	  ID_ATTRIBUTE_NAME: 'data-reactid',
	
	  /**
	   * Map from property "standard name" to an object with info about how to set
	   * the property in the DOM. Each object contains:
	   *
	   * attributeName:
	   *   Used when rendering markup or with `*Attribute()`.
	   * attributeNamespace
	   * propertyName:
	   *   Used on DOM node instances. (This includes properties that mutate due to
	   *   external factors.)
	   * mutationMethod:
	   *   If non-null, used instead of the property or `setAttribute()` after
	   *   initial render.
	   * mustUseAttribute:
	   *   Whether the property must be accessed and mutated using `*Attribute()`.
	   *   (This includes anything that fails `<propName> in <element>`.)
	   * mustUseProperty:
	   *   Whether the property must be accessed and mutated as an object property.
	   * hasSideEffects:
	   *   Whether or not setting a value causes side effects such as triggering
	   *   resources to be loaded or text selection changes. If true, we read from
	   *   the DOM before updating to ensure that the value is only set if it has
	   *   changed.
	   * hasBooleanValue:
	   *   Whether the property should be removed when set to a falsey value.
	   * hasNumericValue:
	   *   Whether the property must be numeric or parse as a numeric and should be
	   *   removed when set to a falsey value.
	   * hasPositiveNumericValue:
	   *   Whether the property must be positive numeric or parse as a positive
	   *   numeric and should be removed when set to a falsey value.
	   * hasOverloadedBooleanValue:
	   *   Whether the property can be used as a flag as well as with a value.
	   *   Removed when strictly equal to false; present without a value when
	   *   strictly equal to true; present with a value otherwise.
	   */
	  properties: {},
	
	  /**
	   * Mapping from lowercase property names to the properly cased version, used
	   * to warn in the case of missing properties. Available only in __DEV__.
	   * @type {Object}
	   */
	  getPossibleStandardName:  false ? {} : null,
	
	  /**
	   * All of the isCustomAttribute() functions that have been injected.
	   */
	  _isCustomAttributeFunctions: [],
	
	  /**
	   * Checks whether a property name is a custom attribute.
	   * @method
	   */
	  isCustomAttribute: function (attributeName) {
	    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
	      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
	      if (isCustomAttributeFn(attributeName)) {
	        return true;
	      }
	    }
	    return false;
	  },
	
	  /**
	   * Returns the default property value for a DOM property (i.e., not an
	   * attribute). Most default values are '' or false, but not all. Worse yet,
	   * some (in particular, `type`) vary depending on the type of element.
	   *
	   * TODO: Is it better to grab all the possible properties when creating an
	   * element to avoid having to create the same element twice?
	   */
	  getDefaultValueForProperty: function (nodeName, prop) {
	    var nodeDefaults = defaultValueCache[nodeName];
	    var testElement;
	    if (!nodeDefaults) {
	      defaultValueCache[nodeName] = nodeDefaults = {};
	    }
	    if (!(prop in nodeDefaults)) {
	      testElement = document.createElement(nodeName);
	      nodeDefaults[prop] = testElement[prop];
	    }
	    return nodeDefaults[prop];
	  },
	
	  injection: DOMPropertyInjection
	};
	
	module.exports = DOMProperty;

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule quoteAttributeValueForBrowser
	 */
	
	'use strict';
	
	var escapeTextContentForBrowser = __webpack_require__(21);
	
	/**
	 * Escapes attribute value to prevent scripting attacks.
	 *
	 * @param {*} value Value to escape.
	 * @return {string} An escaped string.
	 */
	function quoteAttributeValueForBrowser(value) {
	  return '"' + escapeTextContentForBrowser(value) + '"';
	}
	
	module.exports = quoteAttributeValueForBrowser;

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule warning
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(15);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if (false) {
	  warning = function (condition, format) {
	    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      args[_key - 2] = arguments[_key];
	    }
	
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	
	    if (format.indexOf('Failed Composite propType: ') === 0) {
	      return; // Ignore CompositeComponent proptype check.
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    }
	  };
	}
	
	module.exports = warning;

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentBrowserEnvironment
	 */
	
	'use strict';
	
	var ReactDOMIDOperations = __webpack_require__(27);
	var ReactMount = __webpack_require__(28);
	
	/**
	 * Abstracts away all functionality of the reconciler that requires knowledge of
	 * the browser context. TODO: These callers should be refactored to avoid the
	 * need for this injection.
	 */
	var ReactComponentBrowserEnvironment = {
	
	  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
	
	  replaceNodeWithMarkupByID: ReactDOMIDOperations.dangerouslyReplaceNodeWithMarkupByID,
	
	  /**
	   * If a particular environment requires that some resources be cleaned up,
	   * specify this in the injected Mixin. In the DOM, we would likely want to
	   * purge any cached node ID lookups.
	   *
	   * @private
	   */
	  unmountIDFromEnvironment: function (rootNodeID) {
	    ReactMount.purgeID(rootNodeID);
	  }
	
	};
	
	module.exports = ReactComponentBrowserEnvironment;

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMIDOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(7);
	var DOMPropertyOperations = __webpack_require__(22);
	var ReactMount = __webpack_require__(28);
	var ReactPerf = __webpack_require__(18);
	
	var invariant = __webpack_require__(13);
	
	/**
	 * Errors for properties that should not be updated with `updatePropertyByID()`.
	 *
	 * @type {object}
	 * @private
	 */
	var INVALID_PROPERTY_ERRORS = {
	  dangerouslySetInnerHTML: '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
	  style: '`style` must be set using `updateStylesByID()`.'
	};
	
	/**
	 * Operations used to process updates to DOM nodes.
	 */
	var ReactDOMIDOperations = {
	
	  /**
	   * Updates a DOM node with new property values. This should only be used to
	   * update DOM properties in `DOMProperty`.
	   *
	   * @param {string} id ID of the node to update.
	   * @param {string} name A valid property name, see `DOMProperty`.
	   * @param {*} value New value of the property.
	   * @internal
	   */
	  updatePropertyByID: function (id, name, value) {
	    var node = ReactMount.getNode(id);
	    !!INVALID_PROPERTY_ERRORS.hasOwnProperty(name) ?  false ? invariant(false, 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(false) : undefined;
	
	    // If we're updating to null or undefined, we should remove the property
	    // from the DOM node instead of inadvertantly setting to a string. This
	    // brings us in line with the same behavior we have on initial render.
	    if (value != null) {
	      DOMPropertyOperations.setValueForProperty(node, name, value);
	    } else {
	      DOMPropertyOperations.deleteValueForProperty(node, name);
	    }
	  },
	
	  /**
	   * Replaces a DOM node that exists in the document with markup.
	   *
	   * @param {string} id ID of child to be replaced.
	   * @param {string} markup Dangerous markup to inject in place of child.
	   * @internal
	   * @see {Danger.dangerouslyReplaceNodeWithMarkup}
	   */
	  dangerouslyReplaceNodeWithMarkupByID: function (id, markup) {
	    var node = ReactMount.getNode(id);
	    DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
	  },
	
	  /**
	   * Updates a component's children by processing a series of updates.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @param {array<string>} markup List of markup strings.
	   * @internal
	   */
	  dangerouslyProcessChildrenUpdates: function (updates, markup) {
	    for (var i = 0; i < updates.length; i++) {
	      updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
	    }
	    DOMChildrenOperations.processUpdates(updates, markup);
	  }
	};
	
	ReactPerf.measureMethods(ReactDOMIDOperations, 'ReactDOMIDOperations', {
	  dangerouslyReplaceNodeWithMarkupByID: 'dangerouslyReplaceNodeWithMarkupByID',
	  dangerouslyProcessChildrenUpdates: 'dangerouslyProcessChildrenUpdates'
	});
	
	module.exports = ReactDOMIDOperations;

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMount
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(23);
	var ReactBrowserEventEmitter = __webpack_require__(29);
	var ReactCurrentOwner = __webpack_require__(5);
	var ReactDOMFeatureFlags = __webpack_require__(41);
	var ReactElement = __webpack_require__(42);
	var ReactEmptyComponentRegistry = __webpack_require__(44);
	var ReactInstanceHandles = __webpack_require__(45);
	var ReactInstanceMap = __webpack_require__(47);
	var ReactMarkupChecksum = __webpack_require__(48);
	var ReactPerf = __webpack_require__(18);
	var ReactReconciler = __webpack_require__(50);
	var ReactUpdateQueue = __webpack_require__(53);
	var ReactUpdates = __webpack_require__(54);
	
	var assign = __webpack_require__(39);
	var emptyObject = __webpack_require__(58);
	var containsNode = __webpack_require__(59);
	var instantiateReactComponent = __webpack_require__(62);
	var invariant = __webpack_require__(13);
	var setInnerHTML = __webpack_require__(19);
	var shouldUpdateReactComponent = __webpack_require__(67);
	var validateDOMNesting = __webpack_require__(70);
	var warning = __webpack_require__(25);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var nodeCache = {};
	
	var ELEMENT_NODE_TYPE = 1;
	var DOC_NODE_TYPE = 9;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	var ownerDocumentContextKey = '__ReactMount_ownerDocument$' + Math.random().toString(36).slice(2);
	
	/** Mapping from reactRootID to React component instance. */
	var instancesByReactRootID = {};
	
	/** Mapping from reactRootID to `container` nodes. */
	var containersByReactRootID = {};
	
	if (false) {
	  /** __DEV__-only mapping from reactRootID to root elements. */
	  var rootElementsByReactRootID = {};
	}
	
	// Used to store breadth-first search state in findComponentRoot.
	var findComponentRootReusableArray = [];
	
	/**
	 * Finds the index of the first character
	 * that's not common between the two given strings.
	 *
	 * @return {number} the index of the character where the strings diverge
	 */
	function firstDifferenceIndex(string1, string2) {
	  var minLen = Math.min(string1.length, string2.length);
	  for (var i = 0; i < minLen; i++) {
	    if (string1.charAt(i) !== string2.charAt(i)) {
	      return i;
	    }
	  }
	  return string1.length === string2.length ? -1 : minLen;
	}
	
	/**
	 * @param {DOMElement|DOMDocument} container DOM element that may contain
	 * a React component
	 * @return {?*} DOM element that may have the reactRoot ID, or null.
	 */
	function getReactRootElementInContainer(container) {
	  if (!container) {
	    return null;
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    return container.documentElement;
	  } else {
	    return container.firstChild;
	  }
	}
	
	/**
	 * @param {DOMElement} container DOM element that may contain a React component.
	 * @return {?string} A "reactRoot" ID, if a React component is rendered.
	 */
	function getReactRootID(container) {
	  var rootElement = getReactRootElementInContainer(container);
	  return rootElement && ReactMount.getID(rootElement);
	}
	
	/**
	 * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form
	 * element can return its control whose name or ID equals ATTR_NAME. All
	 * DOM nodes support `getAttributeNode` but this can also get called on
	 * other objects so just return '' if we're given something other than a
	 * DOM node (such as window).
	 *
	 * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.
	 * @return {string} ID of the supplied `domNode`.
	 */
	function getID(node) {
	  var id = internalGetID(node);
	  if (id) {
	    if (nodeCache.hasOwnProperty(id)) {
	      var cached = nodeCache[id];
	      if (cached !== node) {
	        !!isValid(cached, id) ?  false ? invariant(false, 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(false) : undefined;
	
	        nodeCache[id] = node;
	      }
	    } else {
	      nodeCache[id] = node;
	    }
	  }
	
	  return id;
	}
	
	function internalGetID(node) {
	  // If node is something like a window, document, or text node, none of
	  // which support attributes or a .getAttribute method, gracefully return
	  // the empty string, as if the attribute were missing.
	  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
	}
	
	/**
	 * Sets the React-specific ID of the given node.
	 *
	 * @param {DOMElement} node The DOM node whose ID will be set.
	 * @param {string} id The value of the ID attribute.
	 */
	function setID(node, id) {
	  var oldID = internalGetID(node);
	  if (oldID !== id) {
	    delete nodeCache[oldID];
	  }
	  node.setAttribute(ATTR_NAME, id);
	  nodeCache[id] = node;
	}
	
	/**
	 * Finds the node with the supplied React-generated DOM ID.
	 *
	 * @param {string} id A React-generated DOM ID.
	 * @return {DOMElement} DOM node with the suppled `id`.
	 * @internal
	 */
	function getNode(id) {
	  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
	    nodeCache[id] = ReactMount.findReactNodeByID(id);
	  }
	  return nodeCache[id];
	}
	
	/**
	 * Finds the node with the supplied public React instance.
	 *
	 * @param {*} instance A public React instance.
	 * @return {?DOMElement} DOM node with the suppled `id`.
	 * @internal
	 */
	function getNodeFromInstance(instance) {
	  var id = ReactInstanceMap.get(instance)._rootNodeID;
	  if (ReactEmptyComponentRegistry.isNullComponentID(id)) {
	    return null;
	  }
	  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
	    nodeCache[id] = ReactMount.findReactNodeByID(id);
	  }
	  return nodeCache[id];
	}
	
	/**
	 * A node is "valid" if it is contained by a currently mounted container.
	 *
	 * This means that the node does not have to be contained by a document in
	 * order to be considered valid.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @param {string} id The expected ID of the node.
	 * @return {boolean} Whether the node is contained by a mounted container.
	 */
	function isValid(node, id) {
	  if (node) {
	    !(internalGetID(node) === id) ?  false ? invariant(false, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(false) : undefined;
	
	    var container = ReactMount.findReactContainerForID(id);
	    if (container && containsNode(container, node)) {
	      return true;
	    }
	  }
	
	  return false;
	}
	
	/**
	 * Causes the cache to forget about one React-specific ID.
	 *
	 * @param {string} id The ID to forget.
	 */
	function purgeID(id) {
	  delete nodeCache[id];
	}
	
	var deepestNodeSoFar = null;
	function findDeepestCachedAncestorImpl(ancestorID) {
	  var ancestor = nodeCache[ancestorID];
	  if (ancestor && isValid(ancestor, ancestorID)) {
	    deepestNodeSoFar = ancestor;
	  } else {
	    // This node isn't populated in the cache, so presumably none of its
	    // descendants are. Break out of the loop.
	    return false;
	  }
	}
	
	/**
	 * Return the deepest cached node whose ID is a prefix of `targetID`.
	 */
	function findDeepestCachedAncestor(targetID) {
	  deepestNodeSoFar = null;
	  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);
	
	  var foundNode = deepestNodeSoFar;
	  deepestNodeSoFar = null;
	  return foundNode;
	}
	
	/**
	 * Mounts this component and inserts it into the DOM.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {string} rootID DOM ID of the root node.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {ReactReconcileTransaction} transaction
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {
	  if (ReactDOMFeatureFlags.useCreateElement) {
	    context = assign({}, context);
	    if (container.nodeType === DOC_NODE_TYPE) {
	      context[ownerDocumentContextKey] = container;
	    } else {
	      context[ownerDocumentContextKey] = container.ownerDocument;
	    }
	  }
	  if (false) {
	    if (context === emptyObject) {
	      context = {};
	    }
	    var tag = container.nodeName.toLowerCase();
	    context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(null, tag, null);
	  }
	  var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, context);
	  componentInstance._renderedComponent._topLevelWrapper = componentInstance;
	  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup, transaction);
	}
	
	/**
	 * Batched mount.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {string} rootID DOM ID of the root node.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup, context) {
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* forceHTML */shouldReuseMarkup);
	  transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	}
	
	/**
	 * Unmounts a component and removes it from the DOM.
	 *
	 * @param {ReactComponent} instance React component instance.
	 * @param {DOMElement} container DOM element to unmount from.
	 * @final
	 * @internal
	 * @see {ReactMount.unmountComponentAtNode}
	 */
	function unmountComponentFromNode(instance, container) {
	  ReactReconciler.unmountComponent(instance);
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    container = container.documentElement;
	  }
	
	  // http://jsperf.com/emptying-a-node
	  while (container.lastChild) {
	    container.removeChild(container.lastChild);
	  }
	}
	
	/**
	 * True if the supplied DOM node has a direct React-rendered child that is
	 * not a React root element. Useful for warning in `render`,
	 * `unmountComponentAtNode`, etc.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM element contains a direct child that was
	 * rendered by React but is not a root element.
	 * @internal
	 */
	function hasNonRootReactChild(node) {
	  var reactRootID = getReactRootID(node);
	  return reactRootID ? reactRootID !== ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID) : false;
	}
	
	/**
	 * Returns the first (deepest) ancestor of a node which is rendered by this copy
	 * of React.
	 */
	function findFirstReactDOMImpl(node) {
	  // This node might be from another React instance, so we make sure not to
	  // examine the node cache here
	  for (; node && node.parentNode !== node; node = node.parentNode) {
	    if (node.nodeType !== 1) {
	      // Not a DOMElement, therefore not a React component
	      continue;
	    }
	    var nodeID = internalGetID(node);
	    if (!nodeID) {
	      continue;
	    }
	    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
	
	    // If containersByReactRootID contains the container we find by crawling up
	    // the tree, we know that this instance of React rendered the node.
	    // nb. isValid's strategy (with containsNode) does not work because render
	    // trees may be nested and we don't want a false positive in that case.
	    var current = node;
	    var lastID;
	    do {
	      lastID = internalGetID(current);
	      current = current.parentNode;
	      if (current == null) {
	        // The passed-in node has been detached from the container it was
	        // originally rendered into.
	        return null;
	      }
	    } while (lastID !== reactRootID);
	
	    if (current === containersByReactRootID[reactRootID]) {
	      return node;
	    }
	  }
	  return null;
	}
	
	/**
	 * Temporary (?) hack so that we can store all top-level pending updates on
	 * composites instead of having to worry about different types of components
	 * here.
	 */
	var TopLevelWrapper = function () {};
	TopLevelWrapper.prototype.isReactComponent = {};
	if (false) {
	  TopLevelWrapper.displayName = 'TopLevelWrapper';
	}
	TopLevelWrapper.prototype.render = function () {
	  // this.props is actually a ReactElement
	  return this.props;
	};
	
	/**
	 * Mounting is the process of initializing a React component by creating its
	 * representative DOM elements and inserting them into a supplied `container`.
	 * Any prior content inside `container` is destroyed in the process.
	 *
	 *   ReactMount.render(
	 *     component,
	 *     document.getElementById('container')
	 *   );
	 *
	 *   <div id="container">                   <-- Supplied `container`.
	 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
	 *       // ...                                 component.
	 *     </div>
	 *   </div>
	 *
	 * Inside of `container`, the first element rendered is the "reactRoot".
	 */
	var ReactMount = {
	
	  TopLevelWrapper: TopLevelWrapper,
	
	  /** Exposed for debugging purposes **/
	  _instancesByReactRootID: instancesByReactRootID,
	
	  /**
	   * This is a hook provided to support rendering React components while
	   * ensuring that the apparent scroll position of its `container` does not
	   * change.
	   *
	   * @param {DOMElement} container The `container` being rendered into.
	   * @param {function} renderCallback This must be called once to do the render.
	   */
	  scrollMonitor: function (container, renderCallback) {
	    renderCallback();
	  },
	
	  /**
	   * Take a component that's already mounted into the DOM and replace its props
	   * @param {ReactComponent} prevComponent component instance already in the DOM
	   * @param {ReactElement} nextElement component instance to render
	   * @param {DOMElement} container container to render into
	   * @param {?function} callback function triggered on completion
	   */
	  _updateRootComponent: function (prevComponent, nextElement, container, callback) {
	    ReactMount.scrollMonitor(container, function () {
	      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);
	      if (callback) {
	        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
	      }
	    });
	
	    if (false) {
	      // Record the root element in case it later gets transplanted.
	      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);
	    }
	
	    return prevComponent;
	  },
	
	  /**
	   * Register a component into the instance map and starts scroll value
	   * monitoring
	   * @param {ReactComponent} nextComponent component instance to render
	   * @param {DOMElement} container container to render into
	   * @return {string} reactRoot ID prefix
	   */
	  _registerComponent: function (nextComponent, container) {
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ?  false ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : undefined;
	
	    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
	
	    var reactRootID = ReactMount.registerContainer(container);
	    instancesByReactRootID[reactRootID] = nextComponent;
	    return reactRootID;
	  },
	
	  /**
	   * Render a new component into the DOM.
	   * @param {ReactElement} nextElement element to render
	   * @param {DOMElement} container container to render into
	   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
	   * @return {ReactComponent} nextComponent
	   */
	  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case.
	     false ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;
	
	    var componentInstance = instantiateReactComponent(nextElement, null);
	    var reactRootID = ReactMount._registerComponent(componentInstance, container);
	
	    // The initial render is synchronous but any updates that happen during
	    // rendering, in componentWillMount or componentDidMount, will be batched
	    // according to the current batching strategy.
	
	    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup, context);
	
	    if (false) {
	      // Record the root element in case it later gets transplanted.
	      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);
	    }
	
	    return componentInstance;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    !(parentComponent != null && parentComponent._reactInternalInstance != null) ?  false ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : undefined;
	    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
	  },
	
	  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    !ReactElement.isValidElement(nextElement) ?  false ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' :
	    // Check if it quacks like an element
	    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : undefined;
	
	     false ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : undefined;
	
	    var nextWrappedElement = new ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);
	
	    var prevComponent = instancesByReactRootID[getReactRootID(container)];
	
	    if (prevComponent) {
	      var prevWrappedElement = prevComponent._currentElement;
	      var prevElement = prevWrappedElement.props;
	      if (shouldUpdateReactComponent(prevElement, nextElement)) {
	        var publicInst = prevComponent._renderedComponent.getPublicInstance();
	        var updatedCallback = callback && function () {
	          callback.call(publicInst);
	        };
	        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, container, updatedCallback);
	        return publicInst;
	      } else {
	        ReactMount.unmountComponentAtNode(container);
	      }
	    }
	
	    var reactRootElement = getReactRootElementInContainer(container);
	    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
	    var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	    if (false) {
	      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : undefined;
	
	      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
	        var rootElementSibling = reactRootElement;
	        while (rootElementSibling) {
	          if (internalGetID(rootElementSibling)) {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : undefined;
	            break;
	          }
	          rootElementSibling = rootElementSibling.nextSibling;
	        }
	      }
	    }
	
	    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
	    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject)._renderedComponent.getPublicInstance();
	    if (callback) {
	      callback.call(component);
	    }
	    return component;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  render: function (nextElement, container, callback) {
	    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
	  },
	
	  /**
	   * Registers a container node into which React components will be rendered.
	   * This also creates the "reactRoot" ID that will be assigned to the element
	   * rendered within.
	   *
	   * @param {DOMElement} container DOM element to register as a container.
	   * @return {string} The "reactRoot" ID of elements rendered within.
	   */
	  registerContainer: function (container) {
	    var reactRootID = getReactRootID(container);
	    if (reactRootID) {
	      // If one exists, make sure it is a valid "reactRoot" ID.
	      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
	    }
	    if (!reactRootID) {
	      // No valid "reactRoot" ID found, create one.
	      reactRootID = ReactInstanceHandles.createReactRootID();
	    }
	    containersByReactRootID[reactRootID] = container;
	    return reactRootID;
	  },
	
	  /**
	   * Unmounts and destroys the React component rendered in the `container`.
	   *
	   * @param {DOMElement} container DOM element containing a React component.
	   * @return {boolean} True if a component was found in and unmounted from
	   *                   `container`
	   */
	  unmountComponentAtNode: function (container) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case. (Strictly speaking, unmounting won't cause a
	    // render but we still don't expect to be in a render call here.)
	     false ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;
	
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ?  false ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : undefined;
	
	    var reactRootID = getReactRootID(container);
	    var component = instancesByReactRootID[reactRootID];
	    if (!component) {
	      // Check if the node being unmounted was rendered by React, but isn't a
	      // root node.
	      var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	      // Check if the container itself is a React root node.
	      var containerID = internalGetID(container);
	      var isContainerReactRoot = containerID && containerID === ReactInstanceHandles.getReactRootIDFromNodeID(containerID);
	
	      if (false) {
	        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : undefined;
	      }
	
	      return false;
	    }
	    ReactUpdates.batchedUpdates(unmountComponentFromNode, component, container);
	    delete instancesByReactRootID[reactRootID];
	    delete containersByReactRootID[reactRootID];
	    if (false) {
	      delete rootElementsByReactRootID[reactRootID];
	    }
	    return true;
	  },
	
	  /**
	   * Finds the container DOM element that contains React component to which the
	   * supplied DOM `id` belongs.
	   *
	   * @param {string} id The ID of an element rendered by a React component.
	   * @return {?DOMElement} DOM element that contains the `id`.
	   */
	  findReactContainerForID: function (id) {
	    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
	    var container = containersByReactRootID[reactRootID];
	
	    if (false) {
	      var rootElement = rootElementsByReactRootID[reactRootID];
	      if (rootElement && rootElement.parentNode !== container) {
	        process.env.NODE_ENV !== 'production' ? warning(
	        // Call internalGetID here because getID calls isValid which calls
	        // findReactContainerForID (this function).
	        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : undefined;
	        var containerChild = container.firstChild;
	        if (containerChild && reactRootID === internalGetID(containerChild)) {
	          // If the container has a new child with the same ID as the old
	          // root element, then rootElementsByReactRootID[reactRootID] is
	          // just stale and needs to be updated. The case that deserves a
	          // warning is when the container is empty.
	          rootElementsByReactRootID[reactRootID] = containerChild;
	        } else {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container: %s', rootElement.parentNode) : undefined;
	        }
	      }
	    }
	
	    return container;
	  },
	
	  /**
	   * Finds an element rendered by React with the supplied ID.
	   *
	   * @param {string} id ID of a DOM node in the React component.
	   * @return {DOMElement} Root DOM node of the React component.
	   */
	  findReactNodeByID: function (id) {
	    var reactRoot = ReactMount.findReactContainerForID(id);
	    return ReactMount.findComponentRoot(reactRoot, id);
	  },
	
	  /**
	   * Traverses up the ancestors of the supplied node to find a node that is a
	   * DOM representation of a React component rendered by this copy of React.
	   *
	   * @param {*} node
	   * @return {?DOMEventTarget}
	   * @internal
	   */
	  getFirstReactDOM: function (node) {
	    return findFirstReactDOMImpl(node);
	  },
	
	  /**
	   * Finds a node with the supplied `targetID` inside of the supplied
	   * `ancestorNode`.  Exploits the ID naming scheme to perform the search
	   * quickly.
	   *
	   * @param {DOMEventTarget} ancestorNode Search from this root.
	   * @pararm {string} targetID ID of the DOM representation of the component.
	   * @return {DOMEventTarget} DOM node with the supplied `targetID`.
	   * @internal
	   */
	  findComponentRoot: function (ancestorNode, targetID) {
	    var firstChildren = findComponentRootReusableArray;
	    var childIndex = 0;
	
	    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;
	
	    if (false) {
	      // This will throw on the next line; give an early warning
	      process.env.NODE_ENV !== 'production' ? warning(deepestAncestor != null, 'React can\'t find the root component node for data-reactid value ' + '`%s`. If you\'re seeing this message, it probably means that ' + 'you\'ve loaded two copies of React on the page. At this time, only ' + 'a single copy of React can be loaded at a time.', targetID) : undefined;
	    }
	
	    firstChildren[0] = deepestAncestor.firstChild;
	    firstChildren.length = 1;
	
	    while (childIndex < firstChildren.length) {
	      var child = firstChildren[childIndex++];
	      var targetChild;
	
	      while (child) {
	        var childID = ReactMount.getID(child);
	        if (childID) {
	          // Even if we find the node we're looking for, we finish looping
	          // through its siblings to ensure they're cached so that we don't have
	          // to revisit this node again. Otherwise, we make n^2 calls to getID
	          // when visiting the many children of a single node in order.
	
	          if (targetID === childID) {
	            targetChild = child;
	          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
	            // If we find a child whose ID is an ancestor of the given ID,
	            // then we can be sure that we only want to search the subtree
	            // rooted at this child, so we can throw out the rest of the
	            // search state.
	            firstChildren.length = childIndex = 0;
	            firstChildren.push(child.firstChild);
	          }
	        } else {
	          // If this child had no ID, then there's a chance that it was
	          // injected automatically by the browser, as when a `<table>`
	          // element sprouts an extra `<tbody>` child as a side effect of
	          // `.innerHTML` parsing. Optimistically continue down this
	          // branch, but not before examining the other siblings.
	          firstChildren.push(child.firstChild);
	        }
	
	        child = child.nextSibling;
	      }
	
	      if (targetChild) {
	        // Emptying firstChildren/findComponentRootReusableArray is
	        // not necessary for correctness, but it helps the GC reclaim
	        // any nodes that were left at the end of the search.
	        firstChildren.length = 0;
	
	        return targetChild;
	      }
	    }
	
	    firstChildren.length = 0;
	
	     true ?  false ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false) : undefined;
	  },
	
	  _mountImageIntoNode: function (markup, container, shouldReuseMarkup, transaction) {
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ?  false ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : undefined;
	
	    if (shouldReuseMarkup) {
	      var rootElement = getReactRootElementInContainer(container);
	      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
	        return;
	      } else {
	        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	
	        var rootMarkup = rootElement.outerHTML;
	        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
	
	        var normalizedMarkup = markup;
	        if (false) {
	          // because rootMarkup is retrieved from the DOM, various normalizations
	          // will have occurred which will not be present in `markup`. Here,
	          // insert markup into a <div> or <iframe> depending on the container
	          // type to perform the same normalizations before comparing.
	          var normalizer;
	          if (container.nodeType === ELEMENT_NODE_TYPE) {
	            normalizer = document.createElement('div');
	            normalizer.innerHTML = markup;
	            normalizedMarkup = normalizer.innerHTML;
	          } else {
	            normalizer = document.createElement('iframe');
	            document.body.appendChild(normalizer);
	            normalizer.contentDocument.write(markup);
	            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
	            document.body.removeChild(normalizer);
	          }
	        }
	
	        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
	        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
	
	        !(container.nodeType !== DOC_NODE_TYPE) ?  false ? invariant(false, 'You\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\n%s', difference) : invariant(false) : undefined;
	
	        if (false) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : undefined;
	        }
	      }
	    }
	
	    !(container.nodeType !== DOC_NODE_TYPE) ?  false ? invariant(false, 'You\'re trying to render a component to the document but ' + 'you didn\'t use server rendering. We can\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;
	
	    if (transaction.useCreateElement) {
	      while (container.lastChild) {
	        container.removeChild(container.lastChild);
	      }
	      container.appendChild(markup);
	    } else {
	      setInnerHTML(container, markup);
	    }
	  },
	
	  ownerDocumentContextKey: ownerDocumentContextKey,
	
	  /**
	   * React ID utilities.
	   */
	
	  getReactRootID: getReactRootID,
	
	  getID: getID,
	
	  setID: setID,
	
	  getNode: getNode,
	
	  getNodeFromInstance: getNodeFromInstance,
	
	  isValid: isValid,
	
	  purgeID: purgeID
	};
	
	ReactPerf.measureMethods(ReactMount, 'ReactMount', {
	  _renderNewRootComponent: '_renderNewRootComponent',
	  _mountImageIntoNode: '_mountImageIntoNode'
	});
	
	module.exports = ReactMount;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserEventEmitter
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(30);
	var EventPluginHub = __webpack_require__(31);
	var EventPluginRegistry = __webpack_require__(32);
	var ReactEventEmitterMixin = __webpack_require__(37);
	var ReactPerf = __webpack_require__(18);
	var ViewportMetrics = __webpack_require__(38);
	
	var assign = __webpack_require__(39);
	var isEventSupported = __webpack_require__(40);
	
	/**
	 * Summary of `ReactBrowserEventEmitter` event handling:
	 *
	 *  - Top-level delegation is used to trap most native browser events. This
	 *    may only occur in the main thread and is the responsibility of
	 *    ReactEventListener, which is injected and can therefore support pluggable
	 *    event sources. This is the only work that occurs in the main thread.
	 *
	 *  - We normalize and de-duplicate events to account for browser quirks. This
	 *    may be done in the worker thread.
	 *
	 *  - Forward these native events (with the associated top-level type used to
	 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
	 *    to extract any synthetic events.
	 *
	 *  - The `EventPluginHub` will then process each event by annotating them with
	 *    "dispatches", a sequence of listeners and IDs that care about that event.
	 *
	 *  - The `EventPluginHub` then dispatches the events.
	 *
	 * Overview of React and the event system:
	 *
	 * +------------+    .
	 * |    DOM     |    .
	 * +------------+    .
	 *       |           .
	 *       v           .
	 * +------------+    .
	 * | ReactEvent |    .
	 * |  Listener  |    .
	 * +------------+    .                         +-----------+
	 *       |           .               +--------+|SimpleEvent|
	 *       |           .               |         |Plugin     |
	 * +-----|------+    .               v         +-----------+
	 * |     |      |    .    +--------------+                    +------------+
	 * |     +-----------.--->|EventPluginHub|                    |    Event   |
	 * |            |    .    |              |     +-----------+  | Propagators|
	 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
	 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
	 * |            |    .    |              |     +-----------+  |  utilities |
	 * |     +-----------.--->|              |                    +------------+
	 * |     |      |    .    +--------------+
	 * +-----|------+    .                ^        +-----------+
	 *       |           .                |        |Enter/Leave|
	 *       +           .                +-------+|Plugin     |
	 * +-------------+   .                         +-----------+
	 * | application |   .
	 * |-------------|   .
	 * |             |   .
	 * |             |   .
	 * +-------------+   .
	 *                   .
	 *    React Core     .  General Purpose Event Plugin System
	 */
	
	var alreadyListeningTo = {};
	var isMonitoringScrollValue = false;
	var reactTopListenersCounter = 0;
	
	// For events like 'submit' which don't consistently bubble (which we trap at a
	// lower node than `document`), binding at `document` would cause duplicate
	// events so we don't include them here
	var topEventMapping = {
	  topAbort: 'abort',
	  topBlur: 'blur',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topChange: 'change',
	  topClick: 'click',
	  topCompositionEnd: 'compositionend',
	  topCompositionStart: 'compositionstart',
	  topCompositionUpdate: 'compositionupdate',
	  topContextMenu: 'contextmenu',
	  topCopy: 'copy',
	  topCut: 'cut',
	  topDoubleClick: 'dblclick',
	  topDrag: 'drag',
	  topDragEnd: 'dragend',
	  topDragEnter: 'dragenter',
	  topDragExit: 'dragexit',
	  topDragLeave: 'dragleave',
	  topDragOver: 'dragover',
	  topDragStart: 'dragstart',
	  topDrop: 'drop',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topFocus: 'focus',
	  topInput: 'input',
	  topKeyDown: 'keydown',
	  topKeyPress: 'keypress',
	  topKeyUp: 'keyup',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topMouseDown: 'mousedown',
	  topMouseMove: 'mousemove',
	  topMouseOut: 'mouseout',
	  topMouseOver: 'mouseover',
	  topMouseUp: 'mouseup',
	  topPaste: 'paste',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topScroll: 'scroll',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topSelectionChange: 'selectionchange',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTextInput: 'textInput',
	  topTimeUpdate: 'timeupdate',
	  topTouchCancel: 'touchcancel',
	  topTouchEnd: 'touchend',
	  topTouchMove: 'touchmove',
	  topTouchStart: 'touchstart',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting',
	  topWheel: 'wheel'
	};
	
	/**
	 * To ensure no conflicts with other potential React instances on the page
	 */
	var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
	
	function getListeningForDocument(mountAt) {
	  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
	  // directly.
	  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
	    mountAt[topListenersIDKey] = reactTopListenersCounter++;
	    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
	  }
	  return alreadyListeningTo[mountAt[topListenersIDKey]];
	}
	
	/**
	 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
	 * example:
	 *
	 *   ReactBrowserEventEmitter.putListener('myID', 'onClick', myFunction);
	 *
	 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
	 *
	 * @internal
	 */
	var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {
	
	  /**
	   * Injectable event backend
	   */
	  ReactEventListener: null,
	
	  injection: {
	    /**
	     * @param {object} ReactEventListener
	     */
	    injectReactEventListener: function (ReactEventListener) {
	      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
	      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
	    }
	  },
	
	  /**
	   * Sets whether or not any created callbacks should be enabled.
	   *
	   * @param {boolean} enabled True if callbacks should be enabled.
	   */
	  setEnabled: function (enabled) {
	    if (ReactBrowserEventEmitter.ReactEventListener) {
	      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
	    }
	  },
	
	  /**
	   * @return {boolean} True if callbacks are enabled.
	   */
	  isEnabled: function () {
	    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
	  },
	
	  /**
	   * We listen for bubbled touch events on the document object.
	   *
	   * Firefox v8.01 (and possibly others) exhibited strange behavior when
	   * mounting `onmousemove` events at some node that was not the document
	   * element. The symptoms were that if your mouse is not moving over something
	   * contained within that mount point (for example on the background) the
	   * top-level listeners for `onmousemove` won't be called. However, if you
	   * register the `mousemove` on the document object, then it will of course
	   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
	   * top-level listeners to the document object only, at least for these
	   * movement types of events and possibly all events.
	   *
	   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	   *
	   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
	   * they bubble to document.
	   *
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {object} contentDocumentHandle Document which owns the container
	   */
	  listenTo: function (registrationName, contentDocumentHandle) {
	    var mountAt = contentDocumentHandle;
	    var isListening = getListeningForDocument(mountAt);
	    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
	
	    var topLevelTypes = EventConstants.topLevelTypes;
	    for (var i = 0; i < dependencies.length; i++) {
	      var dependency = dependencies[i];
	      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
	        if (dependency === topLevelTypes.topWheel) {
	          if (isEventSupported('wheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
	          } else if (isEventSupported('mousewheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
	          } else {
	            // Firefox needs to capture a different mouse scroll event.
	            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
	          }
	        } else if (dependency === topLevelTypes.topScroll) {
	
	          if (isEventSupported('scroll', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
	          } else {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
	          }
	        } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {
	
	          if (isEventSupported('focus', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
	          } else if (isEventSupported('focusin')) {
	            // IE has `focusin` and `focusout` events which bubble.
	            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
	          }
	
	          // to make sure blur and focus event listeners are only attached once
	          isListening[topLevelTypes.topBlur] = true;
	          isListening[topLevelTypes.topFocus] = true;
	        } else if (topEventMapping.hasOwnProperty(dependency)) {
	          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
	        }
	
	        isListening[dependency] = true;
	      }
	    }
	  },
	
	  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  /**
	   * Listens to window scroll and resize events. We cache scroll values so that
	   * application code can access them without triggering reflows.
	   *
	   * NOTE: Scroll events do not bubble.
	   *
	   * @see http://www.quirksmode.org/dom/events/scroll.html
	   */
	  ensureScrollValueMonitoring: function () {
	    if (!isMonitoringScrollValue) {
	      var refresh = ViewportMetrics.refreshScrollValues;
	      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
	      isMonitoringScrollValue = true;
	    }
	  },
	
	  eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,
	
	  registrationNameModules: EventPluginHub.registrationNameModules,
	
	  putListener: EventPluginHub.putListener,
	
	  getListener: EventPluginHub.getListener,
	
	  deleteListener: EventPluginHub.deleteListener,
	
	  deleteAllListeners: EventPluginHub.deleteAllListeners
	
	});
	
	ReactPerf.measureMethods(ReactBrowserEventEmitter, 'ReactBrowserEventEmitter', {
	  putListener: 'putListener',
	  deleteListener: 'deleteListener'
	});
	
	module.exports = ReactBrowserEventEmitter;

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventConstants
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(17);
	
	var PropagationPhases = keyMirror({ bubbled: null, captured: null });
	
	/**
	 * Types of raw signals from the browser caught at the top level.
	 */
	var topLevelTypes = keyMirror({
	  topAbort: null,
	  topBlur: null,
	  topCanPlay: null,
	  topCanPlayThrough: null,
	  topChange: null,
	  topClick: null,
	  topCompositionEnd: null,
	  topCompositionStart: null,
	  topCompositionUpdate: null,
	  topContextMenu: null,
	  topCopy: null,
	  topCut: null,
	  topDoubleClick: null,
	  topDrag: null,
	  topDragEnd: null,
	  topDragEnter: null,
	  topDragExit: null,
	  topDragLeave: null,
	  topDragOver: null,
	  topDragStart: null,
	  topDrop: null,
	  topDurationChange: null,
	  topEmptied: null,
	  topEncrypted: null,
	  topEnded: null,
	  topError: null,
	  topFocus: null,
	  topInput: null,
	  topKeyDown: null,
	  topKeyPress: null,
	  topKeyUp: null,
	  topLoad: null,
	  topLoadedData: null,
	  topLoadedMetadata: null,
	  topLoadStart: null,
	  topMouseDown: null,
	  topMouseMove: null,
	  topMouseOut: null,
	  topMouseOver: null,
	  topMouseUp: null,
	  topPaste: null,
	  topPause: null,
	  topPlay: null,
	  topPlaying: null,
	  topProgress: null,
	  topRateChange: null,
	  topReset: null,
	  topScroll: null,
	  topSeeked: null,
	  topSeeking: null,
	  topSelectionChange: null,
	  topStalled: null,
	  topSubmit: null,
	  topSuspend: null,
	  topTextInput: null,
	  topTimeUpdate: null,
	  topTouchCancel: null,
	  topTouchEnd: null,
	  topTouchMove: null,
	  topTouchStart: null,
	  topVolumeChange: null,
	  topWaiting: null,
	  topWheel: null
	});
	
	var EventConstants = {
	  topLevelTypes: topLevelTypes,
	  PropagationPhases: PropagationPhases
	};
	
	module.exports = EventConstants;

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginHub
	 */
	
	'use strict';
	
	var EventPluginRegistry = __webpack_require__(32);
	var EventPluginUtils = __webpack_require__(33);
	var ReactErrorUtils = __webpack_require__(34);
	
	var accumulateInto = __webpack_require__(35);
	var forEachAccumulated = __webpack_require__(36);
	var invariant = __webpack_require__(13);
	var warning = __webpack_require__(25);
	
	/**
	 * Internal store for event listeners
	 */
	var listenerBank = {};
	
	/**
	 * Internal queue of events that have accumulated their dispatches and are
	 * waiting to have their dispatches executed.
	 */
	var eventQueue = null;
	
	/**
	 * Dispatches an event and releases it back into the pool, unless persistent.
	 *
	 * @param {?object} event Synthetic event to be dispatched.
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @private
	 */
	var executeDispatchesAndRelease = function (event, simulated) {
	  if (event) {
	    EventPluginUtils.executeDispatchesInOrder(event, simulated);
	
	    if (!event.isPersistent()) {
	      event.constructor.release(event);
	    }
	  }
	};
	var executeDispatchesAndReleaseSimulated = function (e) {
	  return executeDispatchesAndRelease(e, true);
	};
	var executeDispatchesAndReleaseTopLevel = function (e) {
	  return executeDispatchesAndRelease(e, false);
	};
	
	/**
	 * - `InstanceHandle`: [required] Module that performs logical traversals of DOM
	 *   hierarchy given ids of the logical DOM elements involved.
	 */
	var InstanceHandle = null;
	
	function validateInstanceHandle() {
	  var valid = InstanceHandle && InstanceHandle.traverseTwoPhase && InstanceHandle.traverseEnterLeave;
	   false ? warning(valid, 'InstanceHandle not injected before use!') : undefined;
	}
	
	/**
	 * This is a unified interface for event plugins to be installed and configured.
	 *
	 * Event plugins can implement the following properties:
	 *
	 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
	 *     Required. When a top-level event is fired, this method is expected to
	 *     extract synthetic events that will in turn be queued and dispatched.
	 *
	 *   `eventTypes` {object}
	 *     Optional, plugins that fire events must publish a mapping of registration
	 *     names that are used to register listeners. Values of this mapping must
	 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
	 *
	 *   `executeDispatch` {function(object, function, string)}
	 *     Optional, allows plugins to override how an event gets dispatched. By
	 *     default, the listener is simply invoked.
	 *
	 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
	 *
	 * @public
	 */
	var EventPluginHub = {
	
	  /**
	   * Methods for injecting dependencies.
	   */
	  injection: {
	
	    /**
	     * @param {object} InjectedMount
	     * @public
	     */
	    injectMount: EventPluginUtils.injection.injectMount,
	
	    /**
	     * @param {object} InjectedInstanceHandle
	     * @public
	     */
	    injectInstanceHandle: function (InjectedInstanceHandle) {
	      InstanceHandle = InjectedInstanceHandle;
	      if (false) {
	        validateInstanceHandle();
	      }
	    },
	
	    getInstanceHandle: function () {
	      if (false) {
	        validateInstanceHandle();
	      }
	      return InstanceHandle;
	    },
	
	    /**
	     * @param {array} InjectedEventPluginOrder
	     * @public
	     */
	    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
	
	    /**
	     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	     */
	    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
	
	  },
	
	  eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,
	
	  registrationNameModules: EventPluginRegistry.registrationNameModules,
	
	  /**
	   * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.
	   *
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {?function} listener The callback to store.
	   */
	  putListener: function (id, registrationName, listener) {
	    !(typeof listener === 'function') ?  false ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : invariant(false) : undefined;
	
	    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
	    bankForRegistrationName[id] = listener;
	
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.didPutListener) {
	      PluginModule.didPutListener(id, registrationName, listener);
	    }
	  },
	
	  /**
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @return {?function} The stored callback.
	   */
	  getListener: function (id, registrationName) {
	    var bankForRegistrationName = listenerBank[registrationName];
	    return bankForRegistrationName && bankForRegistrationName[id];
	  },
	
	  /**
	   * Deletes a listener from the registration bank.
	   *
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   */
	  deleteListener: function (id, registrationName) {
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.willDeleteListener) {
	      PluginModule.willDeleteListener(id, registrationName);
	    }
	
	    var bankForRegistrationName = listenerBank[registrationName];
	    // TODO: This should never be null -- when is it?
	    if (bankForRegistrationName) {
	      delete bankForRegistrationName[id];
	    }
	  },
	
	  /**
	   * Deletes all listeners for the DOM element with the supplied ID.
	   *
	   * @param {string} id ID of the DOM element.
	   */
	  deleteAllListeners: function (id) {
	    for (var registrationName in listenerBank) {
	      if (!listenerBank[registrationName][id]) {
	        continue;
	      }
	
	      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	      if (PluginModule && PluginModule.willDeleteListener) {
	        PluginModule.willDeleteListener(id, registrationName);
	      }
	
	      delete listenerBank[registrationName][id];
	    }
	  },
	
	  /**
	   * Allows registered plugins an opportunity to extract events from top-level
	   * native browser events.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @internal
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var events;
	    var plugins = EventPluginRegistry.plugins;
	    for (var i = 0; i < plugins.length; i++) {
	      // Not every plugin in the ordering may be loaded at runtime.
	      var possiblePlugin = plugins[i];
	      if (possiblePlugin) {
	        var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
	        if (extractedEvents) {
	          events = accumulateInto(events, extractedEvents);
	        }
	      }
	    }
	    return events;
	  },
	
	  /**
	   * Enqueues a synthetic event that should be dispatched when
	   * `processEventQueue` is invoked.
	   *
	   * @param {*} events An accumulation of synthetic events.
	   * @internal
	   */
	  enqueueEvents: function (events) {
	    if (events) {
	      eventQueue = accumulateInto(eventQueue, events);
	    }
	  },
	
	  /**
	   * Dispatches all synthetic events on the event queue.
	   *
	   * @internal
	   */
	  processEventQueue: function (simulated) {
	    // Set `eventQueue` to null before processing it so that we can tell if more
	    // events get enqueued while processing.
	    var processingEventQueue = eventQueue;
	    eventQueue = null;
	    if (simulated) {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
	    } else {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
	    }
	    !!eventQueue ?  false ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.') : invariant(false) : undefined;
	    // This would be a good time to rethrow if any of the event handlers threw.
	    ReactErrorUtils.rethrowCaughtError();
	  },
	
	  /**
	   * These are needed for tests only. Do not use!
	   */
	  __purge: function () {
	    listenerBank = {};
	  },
	
	  __getListenerBank: function () {
	    return listenerBank;
	  }
	
	};
	
	module.exports = EventPluginHub;

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginRegistry
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(13);
	
	/**
	 * Injectable ordering of event plugins.
	 */
	var EventPluginOrder = null;
	
	/**
	 * Injectable mapping from names to event plugin modules.
	 */
	var namesToPlugins = {};
	
	/**
	 * Recomputes the plugin list using the injected plugins and plugin ordering.
	 *
	 * @private
	 */
	function recomputePluginOrdering() {
	  if (!EventPluginOrder) {
	    // Wait until an `EventPluginOrder` is injected.
	    return;
	  }
	  for (var pluginName in namesToPlugins) {
	    var PluginModule = namesToPlugins[pluginName];
	    var pluginIndex = EventPluginOrder.indexOf(pluginName);
	    !(pluginIndex > -1) ?  false ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(false) : undefined;
	    if (EventPluginRegistry.plugins[pluginIndex]) {
	      continue;
	    }
	    !PluginModule.extractEvents ?  false ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(false) : undefined;
	    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
	    var publishedEvents = PluginModule.eventTypes;
	    for (var eventName in publishedEvents) {
	      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ?  false ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(false) : undefined;
	    }
	  }
	}
	
	/**
	 * Publishes an event so that it can be dispatched by the supplied plugin.
	 *
	 * @param {object} dispatchConfig Dispatch configuration for the event.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @return {boolean} True if the event was successfully published.
	 * @private
	 */
	function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
	  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ?  false ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(false) : undefined;
	  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
	
	  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	  if (phasedRegistrationNames) {
	    for (var phaseName in phasedRegistrationNames) {
	      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
	        var phasedRegistrationName = phasedRegistrationNames[phaseName];
	        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
	      }
	    }
	    return true;
	  } else if (dispatchConfig.registrationName) {
	    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
	    return true;
	  }
	  return false;
	}
	
	/**
	 * Publishes a registration name that is used to identify dispatched events and
	 * can be used with `EventPluginHub.putListener` to register listeners.
	 *
	 * @param {string} registrationName Registration name to add.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @private
	 */
	function publishRegistrationName(registrationName, PluginModule, eventName) {
	  !!EventPluginRegistry.registrationNameModules[registrationName] ?  false ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(false) : undefined;
	  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
	  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
	}
	
	/**
	 * Registers plugins so that they can extract and dispatch events.
	 *
	 * @see {EventPluginHub}
	 */
	var EventPluginRegistry = {
	
	  /**
	   * Ordered list of injected plugins.
	   */
	  plugins: [],
	
	  /**
	   * Mapping from event name to dispatch config
	   */
	  eventNameDispatchConfigs: {},
	
	  /**
	   * Mapping from registration name to plugin module
	   */
	  registrationNameModules: {},
	
	  /**
	   * Mapping from registration name to event name
	   */
	  registrationNameDependencies: {},
	
	  /**
	   * Injects an ordering of plugins (by plugin name). This allows the ordering
	   * to be decoupled from injection of the actual plugins so that ordering is
	   * always deterministic regardless of packaging, on-the-fly injection, etc.
	   *
	   * @param {array} InjectedEventPluginOrder
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginOrder}
	   */
	  injectEventPluginOrder: function (InjectedEventPluginOrder) {
	    !!EventPluginOrder ?  false ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(false) : undefined;
	    // Clone the ordering so it cannot be dynamically mutated.
	    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
	    recomputePluginOrdering();
	  },
	
	  /**
	   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
	   * in the ordering injected by `injectEventPluginOrder`.
	   *
	   * Plugins can be injected as part of page initialization or on-the-fly.
	   *
	   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginsByName}
	   */
	  injectEventPluginsByName: function (injectedNamesToPlugins) {
	    var isOrderingDirty = false;
	    for (var pluginName in injectedNamesToPlugins) {
	      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
	        continue;
	      }
	      var PluginModule = injectedNamesToPlugins[pluginName];
	      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
	        !!namesToPlugins[pluginName] ?  false ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(false) : undefined;
	        namesToPlugins[pluginName] = PluginModule;
	        isOrderingDirty = true;
	      }
	    }
	    if (isOrderingDirty) {
	      recomputePluginOrdering();
	    }
	  },
	
	  /**
	   * Looks up the plugin for the supplied event.
	   *
	   * @param {object} event A synthetic event.
	   * @return {?object} The plugin that created the supplied event.
	   * @internal
	   */
	  getPluginModuleForEvent: function (event) {
	    var dispatchConfig = event.dispatchConfig;
	    if (dispatchConfig.registrationName) {
	      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
	    }
	    for (var phase in dispatchConfig.phasedRegistrationNames) {
	      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
	        continue;
	      }
	      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
	      if (PluginModule) {
	        return PluginModule;
	      }
	    }
	    return null;
	  },
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _resetEventPlugins: function () {
	    EventPluginOrder = null;
	    for (var pluginName in namesToPlugins) {
	      if (namesToPlugins.hasOwnProperty(pluginName)) {
	        delete namesToPlugins[pluginName];
	      }
	    }
	    EventPluginRegistry.plugins.length = 0;
	
	    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
	    for (var eventName in eventNameDispatchConfigs) {
	      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
	        delete eventNameDispatchConfigs[eventName];
	      }
	    }
	
	    var registrationNameModules = EventPluginRegistry.registrationNameModules;
	    for (var registrationName in registrationNameModules) {
	      if (registrationNameModules.hasOwnProperty(registrationName)) {
	        delete registrationNameModules[registrationName];
	      }
	    }
	  }
	
	};
	
	module.exports = EventPluginRegistry;

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginUtils
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(30);
	var ReactErrorUtils = __webpack_require__(34);
	
	var invariant = __webpack_require__(13);
	var warning = __webpack_require__(25);
	
	/**
	 * Injected dependencies:
	 */
	
	/**
	 * - `Mount`: [required] Module that can convert between React dom IDs and
	 *   actual node references.
	 */
	var injection = {
	  Mount: null,
	  injectMount: function (InjectedMount) {
	    injection.Mount = InjectedMount;
	    if (false) {
	      process.env.NODE_ENV !== 'production' ? warning(InjectedMount && InjectedMount.getNode && InjectedMount.getID, 'EventPluginUtils.injection.injectMount(...): Injected Mount ' + 'module is missing getNode or getID.') : undefined;
	    }
	  }
	};
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	function isEndish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
	}
	
	function isMoveish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
	}
	function isStartish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
	}
	
	var validateEventDispatches;
	if (false) {
	  validateEventDispatches = function (event) {
	    var dispatchListeners = event._dispatchListeners;
	    var dispatchIDs = event._dispatchIDs;
	
	    var listenersIsArr = Array.isArray(dispatchListeners);
	    var idsIsArr = Array.isArray(dispatchIDs);
	    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
	    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(idsIsArr === listenersIsArr && IDsLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : undefined;
	  };
	}
	
	/**
	 * Dispatch the event to the listener.
	 * @param {SyntheticEvent} event SyntheticEvent to handle
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @param {function} listener Application-level callback
	 * @param {string} domID DOM id to pass to the callback.
	 */
	function executeDispatch(event, simulated, listener, domID) {
	  var type = event.type || 'unknown-event';
	  event.currentTarget = injection.Mount.getNode(domID);
	  if (simulated) {
	    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event, domID);
	  } else {
	    ReactErrorUtils.invokeGuardedCallback(type, listener, event, domID);
	  }
	  event.currentTarget = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches.
	 */
	function executeDispatchesInOrder(event, simulated) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchIDs = event._dispatchIDs;
	  if (false) {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and IDs are two parallel arrays that are always in sync.
	      executeDispatch(event, simulated, dispatchListeners[i], dispatchIDs[i]);
	    }
	  } else if (dispatchListeners) {
	    executeDispatch(event, simulated, dispatchListeners, dispatchIDs);
	  }
	  event._dispatchListeners = null;
	  event._dispatchIDs = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches, but stops
	 * at the first dispatch execution returning true, and returns that id.
	 *
	 * @return {?string} id of the first dispatch execution who's listener returns
	 * true, or null if no listener returned true.
	 */
	function executeDispatchesInOrderStopAtTrueImpl(event) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchIDs = event._dispatchIDs;
	  if (false) {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and IDs are two parallel arrays that are always in sync.
	      if (dispatchListeners[i](event, dispatchIDs[i])) {
	        return dispatchIDs[i];
	      }
	    }
	  } else if (dispatchListeners) {
	    if (dispatchListeners(event, dispatchIDs)) {
	      return dispatchIDs;
	    }
	  }
	  return null;
	}
	
	/**
	 * @see executeDispatchesInOrderStopAtTrueImpl
	 */
	function executeDispatchesInOrderStopAtTrue(event) {
	  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
	  event._dispatchIDs = null;
	  event._dispatchListeners = null;
	  return ret;
	}
	
	/**
	 * Execution of a "direct" dispatch - there must be at most one dispatch
	 * accumulated on the event or it is considered an error. It doesn't really make
	 * sense for an event with multiple dispatches (bubbled) to keep track of the
	 * return values at each dispatch execution, but it does tend to make sense when
	 * dealing with "direct" dispatches.
	 *
	 * @return {*} The return value of executing the single dispatch.
	 */
	function executeDirectDispatch(event) {
	  if (false) {
	    validateEventDispatches(event);
	  }
	  var dispatchListener = event._dispatchListeners;
	  var dispatchID = event._dispatchIDs;
	  !!Array.isArray(dispatchListener) ?  false ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : invariant(false) : undefined;
	  var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
	  event._dispatchListeners = null;
	  event._dispatchIDs = null;
	  return res;
	}
	
	/**
	 * @param {SyntheticEvent} event
	 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
	 */
	function hasDispatches(event) {
	  return !!event._dispatchListeners;
	}
	
	/**
	 * General utilities that are useful in creating custom Event Plugins.
	 */
	var EventPluginUtils = {
	  isEndish: isEndish,
	  isMoveish: isMoveish,
	  isStartish: isStartish,
	
	  executeDirectDispatch: executeDirectDispatch,
	  executeDispatchesInOrder: executeDispatchesInOrder,
	  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
	  hasDispatches: hasDispatches,
	
	  getNode: function (id) {
	    return injection.Mount.getNode(id);
	  },
	  getID: function (node) {
	    return injection.Mount.getID(node);
	  },
	
	  injection: injection
	};
	
	module.exports = EventPluginUtils;

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactErrorUtils
	 * @typechecks
	 */
	
	'use strict';
	
	var caughtError = null;
	
	/**
	 * Call a function while guarding against errors that happens within it.
	 *
	 * @param {?String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} a First argument
	 * @param {*} b Second argument
	 */
	function invokeGuardedCallback(name, func, a, b) {
	  try {
	    return func(a, b);
	  } catch (x) {
	    if (caughtError === null) {
	      caughtError = x;
	    }
	    return undefined;
	  }
	}
	
	var ReactErrorUtils = {
	  invokeGuardedCallback: invokeGuardedCallback,
	
	  /**
	   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
	   * handler are sure to be rethrown by rethrowCaughtError.
	   */
	  invokeGuardedCallbackWithCatch: invokeGuardedCallback,
	
	  /**
	   * During execution of guarded functions we will capture the first error which
	   * we will rethrow to be handled by the top level error handler.
	   */
	  rethrowCaughtError: function () {
	    if (caughtError) {
	      var error = caughtError;
	      caughtError = null;
	      throw error;
	    }
	  }
	};
	
	if (false) {
	  /**
	   * To help development we can get better devtools integration by simulating a
	   * real browser event.
	   */
	  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
	    var fakeNode = document.createElement('react');
	    ReactErrorUtils.invokeGuardedCallback = function (name, func, a, b) {
	      var boundFunc = func.bind(null, a, b);
	      var evtType = 'react-' + name;
	      fakeNode.addEventListener(evtType, boundFunc, false);
	      var evt = document.createEvent('Event');
	      evt.initEvent(evtType, false, false);
	      fakeNode.dispatchEvent(evt);
	      fakeNode.removeEventListener(evtType, boundFunc, false);
	    };
	  }
	}
	
	module.exports = ReactErrorUtils;

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule accumulateInto
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(13);
	
	/**
	 *
	 * Accumulates items that must not be null or undefined into the first one. This
	 * is used to conserve memory by avoiding array allocations, and thus sacrifices
	 * API cleanness. Since `current` can be null before being passed in and not
	 * null after this function, make sure to assign it back to `current`:
	 *
	 * `a = accumulateInto(a, b);`
	 *
	 * This API should be sparingly used. Try `accumulate` for something cleaner.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */
	
	function accumulateInto(current, next) {
	  !(next != null) ?  false ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : invariant(false) : undefined;
	  if (current == null) {
	    return next;
	  }
	
	  // Both are not empty. Warning: Never call x.concat(y) when you are not
	  // certain that x is an Array (x could be a string with concat method).
	  var currentIsArray = Array.isArray(current);
	  var nextIsArray = Array.isArray(next);
	
	  if (currentIsArray && nextIsArray) {
	    current.push.apply(current, next);
	    return current;
	  }
	
	  if (currentIsArray) {
	    current.push(next);
	    return current;
	  }
	
	  if (nextIsArray) {
	    // A bit too dangerous to mutate `next`.
	    return [current].concat(next);
	  }
	
	  return [current, next];
	}
	
	module.exports = accumulateInto;

/***/ },
/* 36 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule forEachAccumulated
	 */
	
	'use strict';
	
	/**
	 * @param {array} arr an "accumulation" of items which is either an Array or
	 * a single item. Useful when paired with the `accumulate` module. This is a
	 * simple utility that allows us to reason about a collection of items, but
	 * handling the case when there is exactly one item (and we do not need to
	 * allocate an array).
	 */
	var forEachAccumulated = function (arr, cb, scope) {
	  if (Array.isArray(arr)) {
	    arr.forEach(cb, scope);
	  } else if (arr) {
	    cb.call(scope, arr);
	  }
	};
	
	module.exports = forEachAccumulated;

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventEmitterMixin
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(31);
	
	function runEventQueueInBatch(events) {
	  EventPluginHub.enqueueEvents(events);
	  EventPluginHub.processEventQueue(false);
	}
	
	var ReactEventEmitterMixin = {
	
	  /**
	   * Streams a fired top-level event to `EventPluginHub` where plugins have the
	   * opportunity to create `ReactEvent`s to be dispatched.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {object} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native environment event.
	   */
	  handleTopLevel: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
	    runEventQueueInBatch(events);
	  }
	};
	
	module.exports = ReactEventEmitterMixin;

/***/ },
/* 38 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ViewportMetrics
	 */
	
	'use strict';
	
	var ViewportMetrics = {
	
	  currentScrollLeft: 0,
	
	  currentScrollTop: 0,
	
	  refreshScrollValues: function (scrollPosition) {
	    ViewportMetrics.currentScrollLeft = scrollPosition.x;
	    ViewportMetrics.currentScrollTop = scrollPosition.y;
	  }
	
	};
	
	module.exports = ViewportMetrics;

/***/ },
/* 39 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Object.assign
	 */
	
	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign
	
	'use strict';
	
	function assign(target, sources) {
	  if (target == null) {
	    throw new TypeError('Object.assign target cannot be null or undefined');
	  }
	
	  var to = Object(target);
	  var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
	    var nextSource = arguments[nextIndex];
	    if (nextSource == null) {
	      continue;
	    }
	
	    var from = Object(nextSource);
	
	    // We don't currently support accessors nor proxies. Therefore this
	    // copy cannot throw. If we ever supported this then we must handle
	    // exceptions and side-effects. We don't support symbols so they won't
	    // be transferred.
	
	    for (var key in from) {
	      if (hasOwnProperty.call(from, key)) {
	        to[key] = from[key];
	      }
	    }
	  }
	
	  return to;
	}
	
	module.exports = assign;

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isEventSupported
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var useHasFeature;
	if (ExecutionEnvironment.canUseDOM) {
	  useHasFeature = document.implementation && document.implementation.hasFeature &&
	  // always returns true in newer browsers as per the standard.
	  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	  document.implementation.hasFeature('', '') !== true;
	}
	
	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @param {?boolean} capture Check if the capture phase is supported.
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix, capture) {
	  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
	    return false;
	  }
	
	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = (eventName in document);
	
	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }
	
	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }
	
	  return isSupported;
	}
	
	module.exports = isEventSupported;

/***/ },
/* 41 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFeatureFlags
	 */
	
	'use strict';
	
	var ReactDOMFeatureFlags = {
	  useCreateElement: false
	};
	
	module.exports = ReactDOMFeatureFlags;

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElement
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(5);
	
	var assign = __webpack_require__(39);
	var canDefineProperty = __webpack_require__(43);
	
	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
	
	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};
	
	/**
	 * Base constructor for all React elements. This is only used to make this
	 * work with a dynamic instanceof check. Nothing should live on this prototype.
	 *
	 * @param {*} type
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @param {*} owner
	 * @param {*} props
	 * @internal
	 */
	var ReactElement = function (type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allow us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,
	
	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,
	
	    // Record the component responsible for creating this element.
	    _owner: owner
	  };
	
	  if (false) {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {};
	
	    // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.
	    if (canDefineProperty) {
	      Object.defineProperty(element._store, 'validated', {
	        configurable: false,
	        enumerable: false,
	        writable: true,
	        value: false
	      });
	      // self and source are DEV only properties.
	      Object.defineProperty(element, '_self', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: self
	      });
	      // Two elements created in two different places should be considered
	      // equal for testing purposes and therefore we hide it from enumeration.
	      Object.defineProperty(element, '_source', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: source
	      });
	    } else {
	      element._store.validated = false;
	      element._self = self;
	      element._source = source;
	    }
	    Object.freeze(element.props);
	    Object.freeze(element);
	  }
	
	  return element;
	};
	
	ReactElement.createElement = function (type, config, children) {
	  var propName;
	
	  // Reserved names are extracted
	  var props = {};
	
	  var key = null;
	  var ref = null;
	  var self = null;
	  var source = null;
	
	  if (config != null) {
	    ref = config.ref === undefined ? null : config.ref;
	    key = config.key === undefined ? null : '' + config.key;
	    self = config.__self === undefined ? null : config.__self;
	    source = config.__source === undefined ? null : config.__source;
	    // Remaining properties are added to a new props object
	    for (propName in config) {
	      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  // Resolve default props
	  if (type && type.defaultProps) {
	    var defaultProps = type.defaultProps;
	    for (propName in defaultProps) {
	      if (typeof props[propName] === 'undefined') {
	        props[propName] = defaultProps[propName];
	      }
	    }
	  }
	
	  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	};
	
	ReactElement.createFactory = function (type) {
	  var factory = ReactElement.createElement.bind(null, type);
	  // Expose the type on the factory and the prototype so that it can be
	  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
	  // This should not be named `constructor` since this may not be the function
	  // that created the element, and it may not even be a constructor.
	  // Legacy hook TODO: Warn if this is accessed
	  factory.type = type;
	  return factory;
	};
	
	ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
	  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
	
	  return newElement;
	};
	
	ReactElement.cloneAndReplaceProps = function (oldElement, newProps) {
	  var newElement = ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, newProps);
	
	  if (false) {
	    // If the key on the original is valid, then the clone is valid
	    newElement._store.validated = oldElement._store.validated;
	  }
	
	  return newElement;
	};
	
	ReactElement.cloneElement = function (element, config, children) {
	  var propName;
	
	  // Original props are copied
	  var props = assign({}, element.props);
	
	  // Reserved names are extracted
	  var key = element.key;
	  var ref = element.ref;
	  // Self is preserved since the owner is preserved.
	  var self = element._self;
	  // Source is preserved since cloneElement is unlikely to be targeted by a
	  // transpiler, and the original source is probably a better indicator of the
	  // true owner.
	  var source = element._source;
	
	  // Owner will be preserved, unless ref is overridden
	  var owner = element._owner;
	
	  if (config != null) {
	    if (config.ref !== undefined) {
	      // Silently steal the ref from the parent.
	      ref = config.ref;
	      owner = ReactCurrentOwner.current;
	    }
	    if (config.key !== undefined) {
	      key = '' + config.key;
	    }
	    // Remaining properties override existing props
	    for (propName in config) {
	      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  return ReactElement(element.type, key, ref, self, source, owner, props);
	};
	
	/**
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid component.
	 * @final
	 */
	ReactElement.isValidElement = function (object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	};
	
	module.exports = ReactElement;

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule canDefineProperty
	 */
	
	'use strict';
	
	var canDefineProperty = false;
	if (false) {
	  try {
	    Object.defineProperty({}, 'x', { get: function () {} });
	    canDefineProperty = true;
	  } catch (x) {
	    // IE will fail on defineProperty
	  }
	}
	
	module.exports = canDefineProperty;

/***/ },
/* 44 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEmptyComponentRegistry
	 */
	
	'use strict';
	
	// This registry keeps track of the React IDs of the components that rendered to
	// `null` (in reality a placeholder such as `noscript`)
	var nullComponentIDsRegistry = {};
	
	/**
	 * @param {string} id Component's `_rootNodeID`.
	 * @return {boolean} True if the component is rendered to null.
	 */
	function isNullComponentID(id) {
	  return !!nullComponentIDsRegistry[id];
	}
	
	/**
	 * Mark the component as having rendered to null.
	 * @param {string} id Component's `_rootNodeID`.
	 */
	function registerNullComponentID(id) {
	  nullComponentIDsRegistry[id] = true;
	}
	
	/**
	 * Unmark the component as having rendered to null: it renders to something now.
	 * @param {string} id Component's `_rootNodeID`.
	 */
	function deregisterNullComponentID(id) {
	  delete nullComponentIDsRegistry[id];
	}
	
	var ReactEmptyComponentRegistry = {
	  isNullComponentID: isNullComponentID,
	  registerNullComponentID: registerNullComponentID,
	  deregisterNullComponentID: deregisterNullComponentID
	};
	
	module.exports = ReactEmptyComponentRegistry;

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceHandles
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactRootIndex = __webpack_require__(46);
	
	var invariant = __webpack_require__(13);
	
	var SEPARATOR = '.';
	var SEPARATOR_LENGTH = SEPARATOR.length;
	
	/**
	 * Maximum depth of traversals before we consider the possibility of a bad ID.
	 */
	var MAX_TREE_DEPTH = 10000;
	
	/**
	 * Creates a DOM ID prefix to use when mounting React components.
	 *
	 * @param {number} index A unique integer
	 * @return {string} React root ID.
	 * @internal
	 */
	function getReactRootIDString(index) {
	  return SEPARATOR + index.toString(36);
	}
	
	/**
	 * Checks if a character in the supplied ID is a separator or the end.
	 *
	 * @param {string} id A React DOM ID.
	 * @param {number} index Index of the character to check.
	 * @return {boolean} True if the character is a separator or end of the ID.
	 * @private
	 */
	function isBoundary(id, index) {
	  return id.charAt(index) === SEPARATOR || index === id.length;
	}
	
	/**
	 * Checks if the supplied string is a valid React DOM ID.
	 *
	 * @param {string} id A React DOM ID, maybe.
	 * @return {boolean} True if the string is a valid React DOM ID.
	 * @private
	 */
	function isValidID(id) {
	  return id === '' || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;
	}
	
	/**
	 * Checks if the first ID is an ancestor of or equal to the second ID.
	 *
	 * @param {string} ancestorID
	 * @param {string} descendantID
	 * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.
	 * @internal
	 */
	function isAncestorIDOf(ancestorID, descendantID) {
	  return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);
	}
	
	/**
	 * Gets the parent ID of the supplied React DOM ID, `id`.
	 *
	 * @param {string} id ID of a component.
	 * @return {string} ID of the parent, or an empty string.
	 * @private
	 */
	function getParentID(id) {
	  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
	}
	
	/**
	 * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the
	 * supplied `destinationID`. If they are equal, the ID is returned.
	 *
	 * @param {string} ancestorID ID of an ancestor node of `destinationID`.
	 * @param {string} destinationID ID of the destination node.
	 * @return {string} Next ID on the path from `ancestorID` to `destinationID`.
	 * @private
	 */
	function getNextDescendantID(ancestorID, destinationID) {
	  !(isValidID(ancestorID) && isValidID(destinationID)) ?  false ? invariant(false, 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(false) : undefined;
	  !isAncestorIDOf(ancestorID, destinationID) ?  false ? invariant(false, 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(false) : undefined;
	  if (ancestorID === destinationID) {
	    return ancestorID;
	  }
	  // Skip over the ancestor and the immediate separator. Traverse until we hit
	  // another separator or we reach the end of `destinationID`.
	  var start = ancestorID.length + SEPARATOR_LENGTH;
	  var i;
	  for (i = start; i < destinationID.length; i++) {
	    if (isBoundary(destinationID, i)) {
	      break;
	    }
	  }
	  return destinationID.substr(0, i);
	}
	
	/**
	 * Gets the nearest common ancestor ID of two IDs.
	 *
	 * Using this ID scheme, the nearest common ancestor ID is the longest common
	 * prefix of the two IDs that immediately preceded a "marker" in both strings.
	 *
	 * @param {string} oneID
	 * @param {string} twoID
	 * @return {string} Nearest common ancestor ID, or the empty string if none.
	 * @private
	 */
	function getFirstCommonAncestorID(oneID, twoID) {
	  var minLength = Math.min(oneID.length, twoID.length);
	  if (minLength === 0) {
	    return '';
	  }
	  var lastCommonMarkerIndex = 0;
	  // Use `<=` to traverse until the "EOL" of the shorter string.
	  for (var i = 0; i <= minLength; i++) {
	    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
	      lastCommonMarkerIndex = i;
	    } else if (oneID.charAt(i) !== twoID.charAt(i)) {
	      break;
	    }
	  }
	  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
	  !isValidID(longestCommonID) ?  false ? invariant(false, 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(false) : undefined;
	  return longestCommonID;
	}
	
	/**
	 * Traverses the parent path between two IDs (either up or down). The IDs must
	 * not be the same, and there must exist a parent path between them. If the
	 * callback returns `false`, traversal is stopped.
	 *
	 * @param {?string} start ID at which to start traversal.
	 * @param {?string} stop ID at which to end traversal.
	 * @param {function} cb Callback to invoke each ID with.
	 * @param {*} arg Argument to invoke the callback with.
	 * @param {?boolean} skipFirst Whether or not to skip the first node.
	 * @param {?boolean} skipLast Whether or not to skip the last node.
	 * @private
	 */
	function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
	  start = start || '';
	  stop = stop || '';
	  !(start !== stop) ?  false ? invariant(false, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(false) : undefined;
	  var traverseUp = isAncestorIDOf(stop, start);
	  !(traverseUp || isAncestorIDOf(start, stop)) ?  false ? invariant(false, 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(false) : undefined;
	  // Traverse from `start` to `stop` one depth at a time.
	  var depth = 0;
	  var traverse = traverseUp ? getParentID : getNextDescendantID;
	  for (var id = start;; /* until break */id = traverse(id, stop)) {
	    var ret;
	    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
	      ret = cb(id, traverseUp, arg);
	    }
	    if (ret === false || id === stop) {
	      // Only break //after// visiting `stop`.
	      break;
	    }
	    !(depth++ < MAX_TREE_DEPTH) ?  false ? invariant(false, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop, id) : invariant(false) : undefined;
	  }
	}
	
	/**
	 * Manages the IDs assigned to DOM representations of React components. This
	 * uses a specific scheme in order to traverse the DOM efficiently (e.g. in
	 * order to simulate events).
	 *
	 * @internal
	 */
	var ReactInstanceHandles = {
	
	  /**
	   * Constructs a React root ID
	   * @return {string} A React root ID.
	   */
	  createReactRootID: function () {
	    return getReactRootIDString(ReactRootIndex.createReactRootIndex());
	  },
	
	  /**
	   * Constructs a React ID by joining a root ID with a name.
	   *
	   * @param {string} rootID Root ID of a parent component.
	   * @param {string} name A component's name (as flattened children).
	   * @return {string} A React ID.
	   * @internal
	   */
	  createReactID: function (rootID, name) {
	    return rootID + name;
	  },
	
	  /**
	   * Gets the DOM ID of the React component that is the root of the tree that
	   * contains the React component with the supplied DOM ID.
	   *
	   * @param {string} id DOM ID of a React component.
	   * @return {?string} DOM ID of the React component that is the root.
	   * @internal
	   */
	  getReactRootIDFromNodeID: function (id) {
	    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
	      var index = id.indexOf(SEPARATOR, 1);
	      return index > -1 ? id.substr(0, index) : id;
	    }
	    return null;
	  },
	
	  /**
	   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
	   * should would receive a `mouseEnter` or `mouseLeave` event.
	   *
	   * NOTE: Does not invoke the callback on the nearest common ancestor because
	   * nothing "entered" or "left" that element.
	   *
	   * @param {string} leaveID ID being left.
	   * @param {string} enterID ID being entered.
	   * @param {function} cb Callback to invoke on each entered/left ID.
	   * @param {*} upArg Argument to invoke the callback with on left IDs.
	   * @param {*} downArg Argument to invoke the callback with on entered IDs.
	   * @internal
	   */
	  traverseEnterLeave: function (leaveID, enterID, cb, upArg, downArg) {
	    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
	    if (ancestorID !== leaveID) {
	      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
	    }
	    if (ancestorID !== enterID) {
	      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
	    }
	  },
	
	  /**
	   * Simulates the traversal of a two-phase, capture/bubble event dispatch.
	   *
	   * NOTE: This traversal happens on IDs without touching the DOM.
	   *
	   * @param {string} targetID ID of the target node.
	   * @param {function} cb Callback to invoke.
	   * @param {*} arg Argument to invoke the callback with.
	   * @internal
	   */
	  traverseTwoPhase: function (targetID, cb, arg) {
	    if (targetID) {
	      traverseParentPath('', targetID, cb, arg, true, false);
	      traverseParentPath(targetID, '', cb, arg, false, true);
	    }
	  },
	
	  /**
	   * Same as `traverseTwoPhase` but skips the `targetID`.
	   */
	  traverseTwoPhaseSkipTarget: function (targetID, cb, arg) {
	    if (targetID) {
	      traverseParentPath('', targetID, cb, arg, true, true);
	      traverseParentPath(targetID, '', cb, arg, true, true);
	    }
	  },
	
	  /**
	   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For
	   * example, passing `.0.$row-0.1` would result in `cb` getting called
	   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.
	   *
	   * NOTE: This traversal happens on IDs without touching the DOM.
	   *
	   * @param {string} targetID ID of the target node.
	   * @param {function} cb Callback to invoke.
	   * @param {*} arg Argument to invoke the callback with.
	   * @internal
	   */
	  traverseAncestors: function (targetID, cb, arg) {
	    traverseParentPath('', targetID, cb, arg, true, false);
	  },
	
	  getFirstCommonAncestorID: getFirstCommonAncestorID,
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _getNextDescendantID: getNextDescendantID,
	
	  isAncestorIDOf: isAncestorIDOf,
	
	  SEPARATOR: SEPARATOR
	
	};
	
	module.exports = ReactInstanceHandles;

/***/ },
/* 46 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRootIndex
	 * @typechecks
	 */
	
	'use strict';
	
	var ReactRootIndexInjection = {
	  /**
	   * @param {function} _createReactRootIndex
	   */
	  injectCreateReactRootIndex: function (_createReactRootIndex) {
	    ReactRootIndex.createReactRootIndex = _createReactRootIndex;
	  }
	};
	
	var ReactRootIndex = {
	  createReactRootIndex: null,
	  injection: ReactRootIndexInjection
	};
	
	module.exports = ReactRootIndex;

/***/ },
/* 47 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceMap
	 */
	
	'use strict';
	
	/**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 */
	
	// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
	var ReactInstanceMap = {
	
	  /**
	   * This API should be called `delete` but we'd have to make sure to always
	   * transform these to strings for IE support. When this transform is fully
	   * supported we can rename it.
	   */
	  remove: function (key) {
	    key._reactInternalInstance = undefined;
	  },
	
	  get: function (key) {
	    return key._reactInternalInstance;
	  },
	
	  has: function (key) {
	    return key._reactInternalInstance !== undefined;
	  },
	
	  set: function (key, value) {
	    key._reactInternalInstance = value;
	  }
	
	};
	
	module.exports = ReactInstanceMap;

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMarkupChecksum
	 */
	
	'use strict';
	
	var adler32 = __webpack_require__(49);
	
	var TAG_END = /\/?>/;
	
	var ReactMarkupChecksum = {
	  CHECKSUM_ATTR_NAME: 'data-react-checksum',
	
	  /**
	   * @param {string} markup Markup string
	   * @return {string} Markup string with checksum attribute attached
	   */
	  addChecksumToMarkup: function (markup) {
	    var checksum = adler32(markup);
	
	    // Add checksum (handle both parent tags and self-closing tags)
	    return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
	  },
	
	  /**
	   * @param {string} markup to use
	   * @param {DOMElement} element root React element
	   * @returns {boolean} whether or not the markup is the same
	   */
	  canReuseMarkup: function (markup, element) {
	    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
	    var markupChecksum = adler32(markup);
	    return markupChecksum === existingChecksum;
	  }
	};
	
	module.exports = ReactMarkupChecksum;

/***/ },
/* 49 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule adler32
	 */
	
	'use strict';
	
	var MOD = 65521;
	
	// adler32 is not cryptographically strong, and is only used to sanity check that
	// markup generated on the server matches the markup generated on the client.
	// This implementation (a modified version of the SheetJS version) has been optimized
	// for our use case, at the expense of conforming to the adler32 specification
	// for non-ascii inputs.
	function adler32(data) {
	  var a = 1;
	  var b = 0;
	  var i = 0;
	  var l = data.length;
	  var m = l & ~0x3;
	  while (i < m) {
	    for (; i < Math.min(i + 4096, m); i += 4) {
	      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
	    }
	    a %= MOD;
	    b %= MOD;
	  }
	  for (; i < l; i++) {
	    b += a += data.charCodeAt(i);
	  }
	  a %= MOD;
	  b %= MOD;
	  return a | b << 16;
	}
	
	module.exports = adler32;

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconciler
	 */
	
	'use strict';
	
	var ReactRef = __webpack_require__(51);
	
	/**
	 * Helper to call ReactRef.attachRefs with this composite component, split out
	 * to avoid allocations in the transaction mount-ready queue.
	 */
	function attachRefs() {
	  ReactRef.attachRefs(this, this._currentElement);
	}
	
	var ReactReconciler = {
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (internalInstance, rootID, transaction, context) {
	    var markup = internalInstance.mountComponent(rootID, transaction, context);
	    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	    return markup;
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function (internalInstance) {
	    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
	    internalInstance.unmountComponent();
	  },
	
	  /**
	   * Update a component using a new element.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @internal
	   */
	  receiveComponent: function (internalInstance, nextElement, transaction, context) {
	    var prevElement = internalInstance._currentElement;
	
	    if (nextElement === prevElement && context === internalInstance._context) {
	      // Since elements are immutable after the owner is rendered,
	      // we can do a cheap identity compare here to determine if this is a
	      // superfluous reconcile. It's possible for state to be mutable but such
	      // change should trigger an update of the owner which would recreate
	      // the element. We explicitly check for the existence of an owner since
	      // it's possible for an element created outside a composite to be
	      // deeply mutated and reused.
	
	      // TODO: Bailing out early is just a perf optimization right?
	      // TODO: Removing the return statement should affect correctness?
	      return;
	    }
	
	    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
	
	    if (refsChanged) {
	      ReactRef.detachRefs(internalInstance, prevElement);
	    }
	
	    internalInstance.receiveComponent(nextElement, transaction, context);
	
	    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	  },
	
	  /**
	   * Flush any dirty changes in a component.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (internalInstance, transaction) {
	    internalInstance.performUpdateIfNecessary(transaction);
	  }
	
	};
	
	module.exports = ReactReconciler;

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRef
	 */
	
	'use strict';
	
	var ReactOwner = __webpack_require__(52);
	
	var ReactRef = {};
	
	function attachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(component.getPublicInstance());
	  } else {
	    // Legacy ref
	    ReactOwner.addComponentAsRefTo(component, ref, owner);
	  }
	}
	
	function detachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(null);
	  } else {
	    // Legacy ref
	    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
	  }
	}
	
	ReactRef.attachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    attachRef(ref, instance, element._owner);
	  }
	};
	
	ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
	  // If either the owner or a `ref` has changed, make sure the newest owner
	  // has stored a reference to `this`, and the previous owner (if different)
	  // has forgotten the reference to `this`. We use the element instead
	  // of the public this.props because the post processing cannot determine
	  // a ref. The ref conceptually lives on the element.
	
	  // TODO: Should this even be possible? The owner cannot change because
	  // it's forbidden by shouldUpdateReactComponent. The ref can change
	  // if you swap the keys of but not the refs. Reconsider where this check
	  // is made. It probably belongs where the key checking and
	  // instantiateReactComponent is done.
	
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	
	  return(
	    // This has a few false positives w/r/t empty components.
	    prevEmpty || nextEmpty || nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref
	  );
	};
	
	ReactRef.detachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    detachRef(ref, instance, element._owner);
	  }
	};
	
	module.exports = ReactRef;

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactOwner
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(13);
	
	/**
	 * ReactOwners are capable of storing references to owned components.
	 *
	 * All components are capable of //being// referenced by owner components, but
	 * only ReactOwner components are capable of //referencing// owned components.
	 * The named reference is known as a "ref".
	 *
	 * Refs are available when mounted and updated during reconciliation.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return (
	 *         <div onClick={this.handleClick}>
	 *           <CustomComponent ref="custom" />
	 *         </div>
	 *       );
	 *     },
	 *     handleClick: function() {
	 *       this.refs.custom.handleClick();
	 *     },
	 *     componentDidMount: function() {
	 *       this.refs.custom.initialize();
	 *     }
	 *   });
	 *
	 * Refs should rarely be used. When refs are used, they should only be done to
	 * control data that is not handled by React's data flow.
	 *
	 * @class ReactOwner
	 */
	var ReactOwner = {
	
	  /**
	   * @param {?object} object
	   * @return {boolean} True if `object` is a valid owner.
	   * @final
	   */
	  isValidOwner: function (object) {
	    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
	  },
	
	  /**
	   * Adds a component by ref to an owner component.
	   *
	   * @param {ReactComponent} component Component to reference.
	   * @param {string} ref Name by which to refer to the component.
	   * @param {ReactOwner} owner Component on which to record the ref.
	   * @final
	   * @internal
	   */
	  addComponentAsRefTo: function (component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ?  false ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might ' + 'be adding a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
	    owner.attachRef(ref, component);
	  },
	
	  /**
	   * Removes a component by ref from an owner component.
	   *
	   * @param {ReactComponent} component Component to dereference.
	   * @param {string} ref Name of the ref to remove.
	   * @param {ReactOwner} owner Component on which the ref is recorded.
	   * @final
	   * @internal
	   */
	  removeComponentAsRefFrom: function (component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ?  false ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might ' + 'be removing a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
	    // Check that `component` is still the current ref because we do not want to
	    // detach the ref if another component stole it.
	    if (owner.getPublicInstance().refs[ref] === component.getPublicInstance()) {
	      owner.detachRef(ref);
	    }
	  }
	
	};
	
	module.exports = ReactOwner;

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdateQueue
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(5);
	var ReactElement = __webpack_require__(42);
	var ReactInstanceMap = __webpack_require__(47);
	var ReactUpdates = __webpack_require__(54);
	
	var assign = __webpack_require__(39);
	var invariant = __webpack_require__(13);
	var warning = __webpack_require__(25);
	
	function enqueueUpdate(internalInstance) {
	  ReactUpdates.enqueueUpdate(internalInstance);
	}
	
	function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
	  var internalInstance = ReactInstanceMap.get(publicInstance);
	  if (!internalInstance) {
	    if (false) {
	      // Only warn when we have a callerName. Otherwise we should be silent.
	      // We're probably calling from enqueueCallback. We don't want to warn
	      // there because we already warned for the corresponding lifecycle method.
	      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor.displayName) : undefined;
	    }
	    return null;
	  }
	
	  if (false) {
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.', callerName) : undefined;
	  }
	
	  return internalInstance;
	}
	
	/**
	 * ReactUpdateQueue allows for state updates to be scheduled into a later
	 * reconciliation step.
	 */
	var ReactUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    if (false) {
	      var owner = ReactCurrentOwner.current;
	      if (owner !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
	        owner._warnedAboutRefsInRender = true;
	      }
	    }
	    var internalInstance = ReactInstanceMap.get(publicInstance);
	    if (internalInstance) {
	      // During componentWillMount and render this will still be null but after
	      // that will always render to something. At least for now. So we can use
	      // this hack.
	      return !!internalInstance._renderedComponent;
	    } else {
	      return false;
	    }
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback) {
	    !(typeof callback === 'function') ?  false ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
	
	    // Previously we would throw an error if we didn't have an internal
	    // instance. Since we want to make it a no-op instead, we mirror the same
	    // behavior we have in other enqueue* methods.
	    // We also need to ignore callbacks in componentWillMount. See
	    // enqueueUpdates.
	    if (!internalInstance) {
	      return null;
	    }
	
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    // TODO: The callback here is ignored when setState is called from
	    // componentWillMount. Either fix it or disallow doing so completely in
	    // favor of getInitialState. Alternatively, we can disallow
	    // componentWillMount during server-side rendering.
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueCallbackInternal: function (internalInstance, callback) {
	    !(typeof callback === 'function') ?  false ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingForceUpdate = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingStateQueue = [completeState];
	    internalInstance._pendingReplaceState = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
	    queue.push(partialState);
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialProps Subset of the next props.
	   * @internal
	   */
	  enqueueSetProps: function (publicInstance, partialProps) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setProps');
	    if (!internalInstance) {
	      return;
	    }
	    ReactUpdateQueue.enqueueSetPropsInternal(internalInstance, partialProps);
	  },
	
	  enqueueSetPropsInternal: function (internalInstance, partialProps) {
	    var topLevelWrapper = internalInstance._topLevelWrapper;
	    !topLevelWrapper ?  false ? invariant(false, 'setProps(...): You called `setProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;
	
	    // Merge with the pending element if it exists, otherwise with existing
	    // element props.
	    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
	    var element = wrapElement.props;
	    var props = assign({}, element.props, partialProps);
	    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));
	
	    enqueueUpdate(topLevelWrapper);
	  },
	
	  /**
	   * Replaces all of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} props New props.
	   * @internal
	   */
	  enqueueReplaceProps: function (publicInstance, props) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceProps');
	    if (!internalInstance) {
	      return;
	    }
	    ReactUpdateQueue.enqueueReplacePropsInternal(internalInstance, props);
	  },
	
	  enqueueReplacePropsInternal: function (internalInstance, props) {
	    var topLevelWrapper = internalInstance._topLevelWrapper;
	    !topLevelWrapper ?  false ? invariant(false, 'replaceProps(...): You called `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;
	
	    // Merge with the pending element if it exists, otherwise with existing
	    // element props.
	    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
	    var element = wrapElement.props;
	    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));
	
	    enqueueUpdate(topLevelWrapper);
	  },
	
	  enqueueElementInternal: function (internalInstance, newElement) {
	    internalInstance._pendingElement = newElement;
	    enqueueUpdate(internalInstance);
	  }
	
	};
	
	module.exports = ReactUpdateQueue;

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdates
	 */
	
	'use strict';
	
	var CallbackQueue = __webpack_require__(55);
	var PooledClass = __webpack_require__(56);
	var ReactPerf = __webpack_require__(18);
	var ReactReconciler = __webpack_require__(50);
	var Transaction = __webpack_require__(57);
	
	var assign = __webpack_require__(39);
	var invariant = __webpack_require__(13);
	
	var dirtyComponents = [];
	var asapCallbackQueue = CallbackQueue.getPooled();
	var asapEnqueued = false;
	
	var batchingStrategy = null;
	
	function ensureInjected() {
	  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ?  false ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(false) : undefined;
	}
	
	var NESTED_UPDATES = {
	  initialize: function () {
	    this.dirtyComponentsLength = dirtyComponents.length;
	  },
	  close: function () {
	    if (this.dirtyComponentsLength !== dirtyComponents.length) {
	      // Additional updates were enqueued by componentDidUpdate handlers or
	      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
	      // these new updates so that if A's componentDidUpdate calls setState on
	      // B, B will update before the callback A's updater provided when calling
	      // setState.
	      dirtyComponents.splice(0, this.dirtyComponentsLength);
	      flushBatchedUpdates();
	    } else {
	      dirtyComponents.length = 0;
	    }
	  }
	};
	
	var UPDATE_QUEUEING = {
	  initialize: function () {
	    this.callbackQueue.reset();
	  },
	  close: function () {
	    this.callbackQueue.notifyAll();
	  }
	};
	
	var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
	
	function ReactUpdatesFlushTransaction() {
	  this.reinitializeTransaction();
	  this.dirtyComponentsLength = null;
	  this.callbackQueue = CallbackQueue.getPooled();
	  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled( /* forceHTML */false);
	}
	
	assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  destructor: function () {
	    this.dirtyComponentsLength = null;
	    CallbackQueue.release(this.callbackQueue);
	    this.callbackQueue = null;
	    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
	    this.reconcileTransaction = null;
	  },
	
	  perform: function (method, scope, a) {
	    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
	    // with this transaction's wrappers around it.
	    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
	  }
	});
	
	PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
	
	function batchedUpdates(callback, a, b, c, d, e) {
	  ensureInjected();
	  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
	}
	
	/**
	 * Array comparator for ReactComponents by mount ordering.
	 *
	 * @param {ReactComponent} c1 first component you're comparing
	 * @param {ReactComponent} c2 second component you're comparing
	 * @return {number} Return value usable by Array.prototype.sort().
	 */
	function mountOrderComparator(c1, c2) {
	  return c1._mountOrder - c2._mountOrder;
	}
	
	function runBatchedUpdates(transaction) {
	  var len = transaction.dirtyComponentsLength;
	  !(len === dirtyComponents.length) ?  false ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(false) : undefined;
	
	  // Since reconciling a component higher in the owner hierarchy usually (not
	  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
	  // them before their children by sorting the array.
	  dirtyComponents.sort(mountOrderComparator);
	
	  for (var i = 0; i < len; i++) {
	    // If a component is unmounted before pending changes apply, it will still
	    // be here, but we assume that it has cleared its _pendingCallbacks and
	    // that performUpdateIfNecessary is a noop.
	    var component = dirtyComponents[i];
	
	    // If performUpdateIfNecessary happens to enqueue any new updates, we
	    // shouldn't execute the callbacks until the next render happens, so
	    // stash the callbacks first
	    var callbacks = component._pendingCallbacks;
	    component._pendingCallbacks = null;
	
	    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);
	
	    if (callbacks) {
	      for (var j = 0; j < callbacks.length; j++) {
	        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
	      }
	    }
	  }
	}
	
	var flushBatchedUpdates = function () {
	  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
	  // array and perform any updates enqueued by mount-ready handlers (i.e.,
	  // componentDidUpdate) but we need to check here too in order to catch
	  // updates enqueued by setState callbacks and asap calls.
	  while (dirtyComponents.length || asapEnqueued) {
	    if (dirtyComponents.length) {
	      var transaction = ReactUpdatesFlushTransaction.getPooled();
	      transaction.perform(runBatchedUpdates, null, transaction);
	      ReactUpdatesFlushTransaction.release(transaction);
	    }
	
	    if (asapEnqueued) {
	      asapEnqueued = false;
	      var queue = asapCallbackQueue;
	      asapCallbackQueue = CallbackQueue.getPooled();
	      queue.notifyAll();
	      CallbackQueue.release(queue);
	    }
	  }
	};
	flushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', flushBatchedUpdates);
	
	/**
	 * Mark a component as needing a rerender, adding an optional callback to a
	 * list of functions which will be executed once the rerender occurs.
	 */
	function enqueueUpdate(component) {
	  ensureInjected();
	
	  // Various parts of our code (such as ReactCompositeComponent's
	  // _renderValidatedComponent) assume that calls to render aren't nested;
	  // verify that that's the case. (This is called by each top-level update
	  // function, like setProps, setState, forceUpdate, etc.; creation and
	  // destruction of top-level components is guarded in ReactMount.)
	
	  if (!batchingStrategy.isBatchingUpdates) {
	    batchingStrategy.batchedUpdates(enqueueUpdate, component);
	    return;
	  }
	
	  dirtyComponents.push(component);
	}
	
	/**
	 * Enqueue a callback to be run at the end of the current batching cycle. Throws
	 * if no updates are currently being performed.
	 */
	function asap(callback, context) {
	  !batchingStrategy.isBatchingUpdates ?  false ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(false) : undefined;
	  asapCallbackQueue.enqueue(callback, context);
	  asapEnqueued = true;
	}
	
	var ReactUpdatesInjection = {
	  injectReconcileTransaction: function (ReconcileTransaction) {
	    !ReconcileTransaction ?  false ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : invariant(false) : undefined;
	    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
	  },
	
	  injectBatchingStrategy: function (_batchingStrategy) {
	    !_batchingStrategy ?  false ? invariant(false, 'ReactUpdates: must provide a batching strategy') : invariant(false) : undefined;
	    !(typeof _batchingStrategy.batchedUpdates === 'function') ?  false ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : invariant(false) : undefined;
	    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ?  false ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(false) : undefined;
	    batchingStrategy = _batchingStrategy;
	  }
	};
	
	var ReactUpdates = {
	  /**
	   * React references `ReactReconcileTransaction` using this property in order
	   * to allow dependency injection.
	   *
	   * @internal
	   */
	  ReactReconcileTransaction: null,
	
	  batchedUpdates: batchedUpdates,
	  enqueueUpdate: enqueueUpdate,
	  flushBatchedUpdates: flushBatchedUpdates,
	  injection: ReactUpdatesInjection,
	  asap: asap
	};
	
	module.exports = ReactUpdates;

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CallbackQueue
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(56);
	
	var assign = __webpack_require__(39);
	var invariant = __webpack_require__(13);
	
	/**
	 * A specialized pseudo-event module to help keep track of components waiting to
	 * be notified when their DOM representations are available for use.
	 *
	 * This implements `PooledClass`, so you should never need to instantiate this.
	 * Instead, use `CallbackQueue.getPooled()`.
	 *
	 * @class ReactMountReady
	 * @implements PooledClass
	 * @internal
	 */
	function CallbackQueue() {
	  this._callbacks = null;
	  this._contexts = null;
	}
	
	assign(CallbackQueue.prototype, {
	
	  /**
	   * Enqueues a callback to be invoked when `notifyAll` is invoked.
	   *
	   * @param {function} callback Invoked when `notifyAll` is invoked.
	   * @param {?object} context Context to call `callback` with.
	   * @internal
	   */
	  enqueue: function (callback, context) {
	    this._callbacks = this._callbacks || [];
	    this._contexts = this._contexts || [];
	    this._callbacks.push(callback);
	    this._contexts.push(context);
	  },
	
	  /**
	   * Invokes all enqueued callbacks and clears the queue. This is invoked after
	   * the DOM representation of a component has been created or updated.
	   *
	   * @internal
	   */
	  notifyAll: function () {
	    var callbacks = this._callbacks;
	    var contexts = this._contexts;
	    if (callbacks) {
	      !(callbacks.length === contexts.length) ?  false ? invariant(false, 'Mismatched list of contexts in callback queue') : invariant(false) : undefined;
	      this._callbacks = null;
	      this._contexts = null;
	      for (var i = 0; i < callbacks.length; i++) {
	        callbacks[i].call(contexts[i]);
	      }
	      callbacks.length = 0;
	      contexts.length = 0;
	    }
	  },
	
	  /**
	   * Resets the internal queue.
	   *
	   * @internal
	   */
	  reset: function () {
	    this._callbacks = null;
	    this._contexts = null;
	  },
	
	  /**
	   * `PooledClass` looks for this.
	   */
	  destructor: function () {
	    this.reset();
	  }
	
	});
	
	PooledClass.addPoolingTo(CallbackQueue);
	
	module.exports = CallbackQueue;

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule PooledClass
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(13);
	
	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function (copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};
	
	var twoArgumentPooler = function (a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};
	
	var threeArgumentPooler = function (a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};
	
	var fourArgumentPooler = function (a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};
	
	var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4, a5);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4, a5);
	  }
	};
	
	var standardReleaser = function (instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ?  false ? invariant(false, 'Trying to release an instance into a pool of a different type.') : invariant(false) : undefined;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};
	
	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;
	
	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances (optional).
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function (CopyConstructor, pooler) {
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};
	
	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler,
	  fiveArgumentPooler: fiveArgumentPooler
	};
	
	module.exports = PooledClass;

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Transaction
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(13);
	
	/**
	 * `Transaction` creates a black box that is able to wrap any method such that
	 * certain invariants are maintained before and after the method is invoked
	 * (Even if an exception is thrown while invoking the wrapped method). Whoever
	 * instantiates a transaction can provide enforcers of the invariants at
	 * creation time. The `Transaction` class itself will supply one additional
	 * automatic invariant for you - the invariant that any transaction instance
	 * should not be run while it is already being run. You would typically create a
	 * single instance of a `Transaction` for reuse multiple times, that potentially
	 * is used to wrap several different methods. Wrappers are extremely simple -
	 * they only require implementing two methods.
	 *
	 * <pre>
	 *                       wrappers (injected at creation time)
	 *                                      +        +
	 *                                      |        |
	 *                    +-----------------|--------|--------------+
	 *                    |                 v        |              |
	 *                    |      +---------------+   |              |
	 *                    |   +--|    wrapper1   |---|----+         |
	 *                    |   |  +---------------+   v    |         |
	 *                    |   |          +-------------+  |         |
	 *                    |   |     +----|   wrapper2  |--------+   |
	 *                    |   |     |    +-------------+  |     |   |
	 *                    |   |     |                     |     |   |
	 *                    |   v     v                     v     v   | wrapper
	 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
	 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
	 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | +---+ +---+   +---------+   +---+ +---+ |
	 *                    |  initialize                    close    |
	 *                    +-----------------------------------------+
	 * </pre>
	 *
	 * Use cases:
	 * - Preserving the input selection ranges before/after reconciliation.
	 *   Restoring selection even in the event of an unexpected error.
	 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
	 *   while guaranteeing that afterwards, the event system is reactivated.
	 * - Flushing a queue of collected DOM mutations to the main UI thread after a
	 *   reconciliation takes place in a worker thread.
	 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
	 *   content.
	 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
	 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
	 * - (Future use case): Layout calculations before and after DOM updates.
	 *
	 * Transactional plugin API:
	 * - A module that has an `initialize` method that returns any precomputation.
	 * - and a `close` method that accepts the precomputation. `close` is invoked
	 *   when the wrapped process is completed, or has failed.
	 *
	 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
	 * that implement `initialize` and `close`.
	 * @return {Transaction} Single transaction for reuse in thread.
	 *
	 * @class Transaction
	 */
	var Mixin = {
	  /**
	   * Sets up this instance so that it is prepared for collecting metrics. Does
	   * so such that this setup method may be used on an instance that is already
	   * initialized, in a way that does not consume additional memory upon reuse.
	   * That can be useful if you decide to make your subclass of this mixin a
	   * "PooledClass".
	   */
	  reinitializeTransaction: function () {
	    this.transactionWrappers = this.getTransactionWrappers();
	    if (this.wrapperInitData) {
	      this.wrapperInitData.length = 0;
	    } else {
	      this.wrapperInitData = [];
	    }
	    this._isInTransaction = false;
	  },
	
	  _isInTransaction: false,
	
	  /**
	   * @abstract
	   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
	   */
	  getTransactionWrappers: null,
	
	  isInTransaction: function () {
	    return !!this._isInTransaction;
	  },
	
	  /**
	   * Executes the function within a safety window. Use this for the top level
	   * methods that result in large amounts of computation/mutations that would
	   * need to be safety checked. The optional arguments helps prevent the need
	   * to bind in many cases.
	   *
	   * @param {function} method Member of scope to call.
	   * @param {Object} scope Scope to invoke from.
	   * @param {Object?=} a Argument to pass to the method.
	   * @param {Object?=} b Argument to pass to the method.
	   * @param {Object?=} c Argument to pass to the method.
	   * @param {Object?=} d Argument to pass to the method.
	   * @param {Object?=} e Argument to pass to the method.
	   * @param {Object?=} f Argument to pass to the method.
	   *
	   * @return {*} Return value from `method`.
	   */
	  perform: function (method, scope, a, b, c, d, e, f) {
	    !!this.isInTransaction() ?  false ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there ' + 'is already an outstanding transaction.') : invariant(false) : undefined;
	    var errorThrown;
	    var ret;
	    try {
	      this._isInTransaction = true;
	      // Catching errors makes debugging more difficult, so we start with
	      // errorThrown set to true before setting it to false after calling
	      // close -- if it's still set to true in the finally block, it means
	      // one of these calls threw.
	      errorThrown = true;
	      this.initializeAll(0);
	      ret = method.call(scope, a, b, c, d, e, f);
	      errorThrown = false;
	    } finally {
	      try {
	        if (errorThrown) {
	          // If `method` throws, prefer to show that stack trace over any thrown
	          // by invoking `closeAll`.
	          try {
	            this.closeAll(0);
	          } catch (err) {}
	        } else {
	          // Since `method` didn't throw, we don't want to silence the exception
	          // here.
	          this.closeAll(0);
	        }
	      } finally {
	        this._isInTransaction = false;
	      }
	    }
	    return ret;
	  },
	
	  initializeAll: function (startIndex) {
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      try {
	        // Catching errors makes debugging more difficult, so we start with the
	        // OBSERVED_ERROR state before overwriting it with the real return value
	        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
	        // block, it means wrapper.initialize threw.
	        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
	        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
	      } finally {
	        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
	          // The initializer for wrapper i threw an error; initialize the
	          // remaining wrappers but silence any exceptions from them to ensure
	          // that the first error is the one to bubble up.
	          try {
	            this.initializeAll(i + 1);
	          } catch (err) {}
	        }
	      }
	    }
	  },
	
	  /**
	   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
	   * them the respective return values of `this.transactionWrappers.init[i]`
	   * (`close`rs that correspond to initializers that failed will not be
	   * invoked).
	   */
	  closeAll: function (startIndex) {
	    !this.isInTransaction() ?  false ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : invariant(false) : undefined;
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      var initData = this.wrapperInitData[i];
	      var errorThrown;
	      try {
	        // Catching errors makes debugging more difficult, so we start with
	        // errorThrown set to true before setting it to false after calling
	        // close -- if it's still set to true in the finally block, it means
	        // wrapper.close threw.
	        errorThrown = true;
	        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
	          wrapper.close.call(this, initData);
	        }
	        errorThrown = false;
	      } finally {
	        if (errorThrown) {
	          // The closer for wrapper i threw an error; close the remaining
	          // wrappers but silence any exceptions from them to ensure that the
	          // first error is the one to bubble up.
	          try {
	            this.closeAll(i + 1);
	          } catch (e) {}
	        }
	      }
	    }
	    this.wrapperInitData.length = 0;
	  }
	};
	
	var Transaction = {
	
	  Mixin: Mixin,
	
	  /**
	   * Token to look for to determine if an error occurred.
	   */
	  OBSERVED_ERROR: {}
	
	};
	
	module.exports = Transaction;

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyObject
	 */
	
	'use strict';
	
	var emptyObject = {};
	
	if (false) {
	  Object.freeze(emptyObject);
	}
	
	module.exports = emptyObject;

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule containsNode
	 * @typechecks
	 */
	
	'use strict';
	
	var isTextNode = __webpack_require__(60);
	
	/*eslint-disable no-bitwise */
	
	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 *
	 * @param {?DOMNode} outerNode Outer DOM node.
	 * @param {?DOMNode} innerNode Inner DOM node.
	 * @return {boolean} True if `outerNode` contains or is `innerNode`.
	 */
	function containsNode(_x, _x2) {
	  var _again = true;
	
	  _function: while (_again) {
	    var outerNode = _x,
	        innerNode = _x2;
	    _again = false;
	
	    if (!outerNode || !innerNode) {
	      return false;
	    } else if (outerNode === innerNode) {
	      return true;
	    } else if (isTextNode(outerNode)) {
	      return false;
	    } else if (isTextNode(innerNode)) {
	      _x = outerNode;
	      _x2 = innerNode.parentNode;
	      _again = true;
	      continue _function;
	    } else if (outerNode.contains) {
	      return outerNode.contains(innerNode);
	    } else if (outerNode.compareDocumentPosition) {
	      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	    } else {
	      return false;
	    }
	  }
	}
	
	module.exports = containsNode;

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextNode
	 * @typechecks
	 */
	
	'use strict';
	
	var isNode = __webpack_require__(61);
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode(object) && object.nodeType == 3;
	}
	
	module.exports = isTextNode;

/***/ },
/* 61 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isNode
	 * @typechecks
	 */
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	'use strict';
	
	function isNode(object) {
	  return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
	}
	
	module.exports = isNode;

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule instantiateReactComponent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactCompositeComponent = __webpack_require__(63);
	var ReactEmptyComponent = __webpack_require__(68);
	var ReactNativeComponent = __webpack_require__(69);
	
	var assign = __webpack_require__(39);
	var invariant = __webpack_require__(13);
	var warning = __webpack_require__(25);
	
	// To avoid a cyclic dependency, we create the final class in this module
	var ReactCompositeComponentWrapper = function () {};
	assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
	  _instantiateReactComponent: instantiateReactComponent
	});
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Check if the type reference is a known internal type. I.e. not a user
	 * provided composite type.
	 *
	 * @param {function} type
	 * @return {boolean} Returns true if this is a valid internal type.
	 */
	function isInternalComponentType(type) {
	  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
	}
	
	/**
	 * Given a ReactNode, create an instance that will actually be mounted.
	 *
	 * @param {ReactNode} node
	 * @return {object} A new instance of the element's constructor.
	 * @protected
	 */
	function instantiateReactComponent(node) {
	  var instance;
	
	  if (node === null || node === false) {
	    instance = new ReactEmptyComponent(instantiateReactComponent);
	  } else if (typeof node === 'object') {
	    var element = node;
	    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ?  false ? invariant(false, 'Element type is invalid: expected a string (for built-in components) ' + 'or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : invariant(false) : undefined;
	
	    // Special case string values
	    if (typeof element.type === 'string') {
	      instance = ReactNativeComponent.createInternalComponent(element);
	    } else if (isInternalComponentType(element.type)) {
	      // This is temporarily available for custom components that are not string
	      // representations. I.e. ART. Once those are updated to use the string
	      // representation, we can drop this code path.
	      instance = new element.type(element);
	    } else {
	      instance = new ReactCompositeComponentWrapper();
	    }
	  } else if (typeof node === 'string' || typeof node === 'number') {
	    instance = ReactNativeComponent.createInstanceForText(node);
	  } else {
	     true ?  false ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : invariant(false) : undefined;
	  }
	
	  if (false) {
	    process.env.NODE_ENV !== 'production' ? warning(typeof instance.construct === 'function' && typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : undefined;
	  }
	
	  // Sets up the instance. This can probably just move into the constructor now.
	  instance.construct(node);
	
	  // These two fields are used by the DOM and ART diffing algorithms
	  // respectively. Instead of using expandos on components, we should be
	  // storing the state needed by the diffing algorithms elsewhere.
	  instance._mountIndex = 0;
	  instance._mountImage = null;
	
	  if (false) {
	    instance._isOwnerNecessary = false;
	    instance._warnedAboutRefsInRender = false;
	  }
	
	  // Internal instances should fully constructed at this point, so they should
	  // not get any new fields added to them at this point.
	  if (false) {
	    if (Object.preventExtensions) {
	      Object.preventExtensions(instance);
	    }
	  }
	
	  return instance;
	}
	
	module.exports = instantiateReactComponent;

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCompositeComponent
	 */
	
	'use strict';
	
	var ReactComponentEnvironment = __webpack_require__(64);
	var ReactCurrentOwner = __webpack_require__(5);
	var ReactElement = __webpack_require__(42);
	var ReactInstanceMap = __webpack_require__(47);
	var ReactPerf = __webpack_require__(18);
	var ReactPropTypeLocations = __webpack_require__(65);
	var ReactPropTypeLocationNames = __webpack_require__(66);
	var ReactReconciler = __webpack_require__(50);
	var ReactUpdateQueue = __webpack_require__(53);
	
	var assign = __webpack_require__(39);
	var emptyObject = __webpack_require__(58);
	var invariant = __webpack_require__(13);
	var shouldUpdateReactComponent = __webpack_require__(67);
	var warning = __webpack_require__(25);
	
	function getDeclarationErrorAddendum(component) {
	  var owner = component._currentElement._owner || null;
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	function StatelessComponent(Component) {}
	StatelessComponent.prototype.render = function () {
	  var Component = ReactInstanceMap.get(this)._currentElement.type;
	  return Component(this.props, this.context, this.updater);
	};
	
	/**
	 * ------------------ The Life-Cycle of a Composite Component ------------------
	 *
	 * - constructor: Initialization of state. The instance is now retained.
	 *   - componentWillMount
	 *   - render
	 *   - [children's constructors]
	 *     - [children's componentWillMount and render]
	 *     - [children's componentDidMount]
	 *     - componentDidMount
	 *
	 *       Update Phases:
	 *       - componentWillReceiveProps (only called if parent updated)
	 *       - shouldComponentUpdate
	 *         - componentWillUpdate
	 *           - render
	 *           - [children's constructors or receive props phases]
	 *         - componentDidUpdate
	 *
	 *     - componentWillUnmount
	 *     - [children's componentWillUnmount]
	 *   - [children destroyed]
	 * - (destroyed): The instance is now blank, released by React and ready for GC.
	 *
	 * -----------------------------------------------------------------------------
	 */
	
	/**
	 * An incrementing ID assigned to each component when it is mounted. This is
	 * used to enforce the order in which `ReactUpdates` updates dirty components.
	 *
	 * @private
	 */
	var nextMountID = 1;
	
	/**
	 * @lends {ReactCompositeComponent.prototype}
	 */
	var ReactCompositeComponentMixin = {
	
	  /**
	   * Base constructor for all composite component.
	   *
	   * @param {ReactElement} element
	   * @final
	   * @internal
	   */
	  construct: function (element) {
	    this._currentElement = element;
	    this._rootNodeID = null;
	    this._instance = null;
	
	    // See ReactUpdateQueue
	    this._pendingElement = null;
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    this._renderedComponent = null;
	
	    this._context = null;
	    this._mountOrder = 0;
	    this._topLevelWrapper = null;
	
	    // See ReactUpdates and ReactUpdateQueue.
	    this._pendingCallbacks = null;
	  },
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (rootID, transaction, context) {
	    this._context = context;
	    this._mountOrder = nextMountID++;
	    this._rootNodeID = rootID;
	
	    var publicProps = this._processProps(this._currentElement.props);
	    var publicContext = this._processContext(context);
	
	    var Component = this._currentElement.type;
	
	    // Initialize the public class
	    var inst;
	    var renderedElement;
	
	    // This is a way to detect if Component is a stateless arrow function
	    // component, which is not newable. It might not be 100% reliable but is
	    // something we can do until we start detecting that Component extends
	    // React.Component. We already assume that typeof Component === 'function'.
	    var canInstantiate = ('prototype' in Component);
	
	    if (canInstantiate) {
	      if (false) {
	        ReactCurrentOwner.current = this;
	        try {
	          inst = new Component(publicProps, publicContext, ReactUpdateQueue);
	        } finally {
	          ReactCurrentOwner.current = null;
	        }
	      } else {
	        inst = new Component(publicProps, publicContext, ReactUpdateQueue);
	      }
	    }
	
	    if (!canInstantiate || inst === null || inst === false || ReactElement.isValidElement(inst)) {
	      renderedElement = inst;
	      inst = new StatelessComponent(Component);
	    }
	
	    if (false) {
	      // This will throw later in _renderValidatedComponent, but add an early
	      // warning now to help debugging
	      if (inst.render == null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`, returned ' + 'null/false from a stateless component, or tried to render an ' + 'element whose type is a function that isn\'t a React component.', Component.displayName || Component.name || 'Component') : undefined;
	      } else {
	        // We support ES6 inheriting from React.Component, the module pattern,
	        // and stateless components, but not ES6 classes that don't extend
	        process.env.NODE_ENV !== 'production' ? warning(Component.prototype && Component.prototype.isReactComponent || !canInstantiate || !(inst instanceof Component), '%s(...): React component classes must extend React.Component.', Component.displayName || Component.name || 'Component') : undefined;
	      }
	    }
	
	    // These should be set up in the constructor, but as a convenience for
	    // simpler class abstractions, we set them up after the fact.
	    inst.props = publicProps;
	    inst.context = publicContext;
	    inst.refs = emptyObject;
	    inst.updater = ReactUpdateQueue;
	
	    this._instance = inst;
	
	    // Store a reference from the instance back to the internal representation
	    ReactInstanceMap.set(inst, this);
	
	    if (false) {
	      // Since plain JS classes are defined without any special initialization
	      // logic, we can not catch common errors early. Therefore, we have to
	      // catch them here, at initialization time, instead.
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : undefined;
	    }
	
	    var initialState = inst.state;
	    if (initialState === undefined) {
	      inst.state = initialState = null;
	    }
	    !(typeof initialState === 'object' && !Array.isArray(initialState)) ?  false ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    if (inst.componentWillMount) {
	      inst.componentWillMount();
	      // When mounting, calls to `setState` by `componentWillMount` will set
	      // `this._pendingStateQueue` without triggering a re-render.
	      if (this._pendingStateQueue) {
	        inst.state = this._processPendingState(inst.props, inst.context);
	      }
	    }
	
	    // If not a stateless component, we now render
	    if (renderedElement === undefined) {
	      renderedElement = this._renderValidatedComponent();
	    }
	
	    this._renderedComponent = this._instantiateReactComponent(renderedElement);
	
	    var markup = ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, this._processChildContext(context));
	    if (inst.componentDidMount) {
	      transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
	    }
	
	    return markup;
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function () {
	    var inst = this._instance;
	
	    if (inst.componentWillUnmount) {
	      inst.componentWillUnmount();
	    }
	
	    ReactReconciler.unmountComponent(this._renderedComponent);
	    this._renderedComponent = null;
	    this._instance = null;
	
	    // Reset pending fields
	    // Even if this component is scheduled for another update in ReactUpdates,
	    // it would still be ignored because these fields are reset.
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	    this._pendingCallbacks = null;
	    this._pendingElement = null;
	
	    // These fields do not really need to be reset since this object is no
	    // longer accessible.
	    this._context = null;
	    this._rootNodeID = null;
	    this._topLevelWrapper = null;
	
	    // Delete the reference from the instance to this internal representation
	    // which allow the internals to be properly cleaned up even if the user
	    // leaks a reference to the public instance.
	    ReactInstanceMap.remove(inst);
	
	    // Some existing components rely on inst.props even after they've been
	    // destroyed (in event handlers).
	    // TODO: inst.props = null;
	    // TODO: inst.state = null;
	    // TODO: inst.context = null;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _maskContext: function (context) {
	    var maskedContext = null;
	    var Component = this._currentElement.type;
	    var contextTypes = Component.contextTypes;
	    if (!contextTypes) {
	      return emptyObject;
	    }
	    maskedContext = {};
	    for (var contextName in contextTypes) {
	      maskedContext[contextName] = context[contextName];
	    }
	    return maskedContext;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`, and asserts that they are valid.
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _processContext: function (context) {
	    var maskedContext = this._maskContext(context);
	    if (false) {
	      var Component = this._currentElement.type;
	      if (Component.contextTypes) {
	        this._checkPropTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
	      }
	    }
	    return maskedContext;
	  },
	
	  /**
	   * @param {object} currentContext
	   * @return {object}
	   * @private
	   */
	  _processChildContext: function (currentContext) {
	    var Component = this._currentElement.type;
	    var inst = this._instance;
	    var childContext = inst.getChildContext && inst.getChildContext();
	    if (childContext) {
	      !(typeof Component.childContextTypes === 'object') ?  false ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	      if (false) {
	        this._checkPropTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);
	      }
	      for (var name in childContext) {
	        !(name in Component.childContextTypes) ?  false ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : invariant(false) : undefined;
	      }
	      return assign({}, currentContext, childContext);
	    }
	    return currentContext;
	  },
	
	  /**
	   * Processes props by setting default values for unspecified props and
	   * asserting that the props are valid. Does not mutate its argument; returns
	   * a new props object with defaults merged in.
	   *
	   * @param {object} newProps
	   * @return {object}
	   * @private
	   */
	  _processProps: function (newProps) {
	    if (false) {
	      var Component = this._currentElement.type;
	      if (Component.propTypes) {
	        this._checkPropTypes(Component.propTypes, newProps, ReactPropTypeLocations.prop);
	      }
	    }
	    return newProps;
	  },
	
	  /**
	   * Assert that the props are valid
	   *
	   * @param {object} propTypes Map of prop name to a ReactPropType
	   * @param {object} props
	   * @param {string} location e.g. "prop", "context", "child context"
	   * @private
	   */
	  _checkPropTypes: function (propTypes, props, location) {
	    // TODO: Stop validating prop types here and only use the element
	    // validation.
	    var componentName = this.getName();
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error;
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          !(typeof propTypes[propName] === 'function') ?  false ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually ' + 'from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
	          error = propTypes[propName](props, propName, componentName, location);
	        } catch (ex) {
	          error = ex;
	        }
	        if (error instanceof Error) {
	          // We may want to extend this logic for similar errors in
	          // top-level render calls, so I'm abstracting it away into
	          // a function to minimize refactoring in the future
	          var addendum = getDeclarationErrorAddendum(this);
	
	          if (location === ReactPropTypeLocations.prop) {
	            // Preface gives us something to blacklist in warning module
	             false ? warning(false, 'Failed Composite propType: %s%s', error.message, addendum) : undefined;
	          } else {
	             false ? warning(false, 'Failed Context Types: %s%s', error.message, addendum) : undefined;
	          }
	        }
	      }
	    }
	  },
	
	  receiveComponent: function (nextElement, transaction, nextContext) {
	    var prevElement = this._currentElement;
	    var prevContext = this._context;
	
	    this._pendingElement = null;
	
	    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
	  },
	
	  /**
	   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
	   * is set, update the component.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (transaction) {
	    if (this._pendingElement != null) {
	      ReactReconciler.receiveComponent(this, this._pendingElement || this._currentElement, transaction, this._context);
	    }
	
	    if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
	      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
	    }
	  },
	
	  /**
	   * Perform an update to a mounted component. The componentWillReceiveProps and
	   * shouldComponentUpdate methods are called, then (assuming the update isn't
	   * skipped) the remaining update lifecycle methods are called and the DOM
	   * representation is updated.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevParentElement
	   * @param {ReactElement} nextParentElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
	    var inst = this._instance;
	
	    var nextContext = this._context === nextUnmaskedContext ? inst.context : this._processContext(nextUnmaskedContext);
	    var nextProps;
	
	    // Distinguish between a props update versus a simple state update
	    if (prevParentElement === nextParentElement) {
	      // Skip checking prop types again -- we don't read inst.props to avoid
	      // warning for DOM component props in this upgrade
	      nextProps = nextParentElement.props;
	    } else {
	      nextProps = this._processProps(nextParentElement.props);
	      // An update here will schedule an update but immediately set
	      // _pendingStateQueue which will ensure that any state updates gets
	      // immediately reconciled instead of waiting for the next batch.
	
	      if (inst.componentWillReceiveProps) {
	        inst.componentWillReceiveProps(nextProps, nextContext);
	      }
	    }
	
	    var nextState = this._processPendingState(nextProps, nextContext);
	
	    var shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	
	    if (false) {
	      process.env.NODE_ENV !== 'production' ? warning(typeof shouldUpdate !== 'undefined', '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : undefined;
	    }
	
	    if (shouldUpdate) {
	      this._pendingForceUpdate = false;
	      // Will set `this.props`, `this.state` and `this.context`.
	      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
	    } else {
	      // If it's determined that a component should not update, we still want
	      // to set props and state but we shortcut the rest of the update.
	      this._currentElement = nextParentElement;
	      this._context = nextUnmaskedContext;
	      inst.props = nextProps;
	      inst.state = nextState;
	      inst.context = nextContext;
	    }
	  },
	
	  _processPendingState: function (props, context) {
	    var inst = this._instance;
	    var queue = this._pendingStateQueue;
	    var replace = this._pendingReplaceState;
	    this._pendingReplaceState = false;
	    this._pendingStateQueue = null;
	
	    if (!queue) {
	      return inst.state;
	    }
	
	    if (replace && queue.length === 1) {
	      return queue[0];
	    }
	
	    var nextState = assign({}, replace ? queue[0] : inst.state);
	    for (var i = replace ? 1 : 0; i < queue.length; i++) {
	      var partial = queue[i];
	      assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
	    }
	
	    return nextState;
	  },
	
	  /**
	   * Merges new props and state, notifies delegate methods of update and
	   * performs update.
	   *
	   * @param {ReactElement} nextElement Next element
	   * @param {object} nextProps Next public object to set as properties.
	   * @param {?object} nextState Next object to set as state.
	   * @param {?object} nextContext Next public object to set as context.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?object} unmaskedContext
	   * @private
	   */
	  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
	    var inst = this._instance;
	
	    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
	    var prevProps;
	    var prevState;
	    var prevContext;
	    if (hasComponentDidUpdate) {
	      prevProps = inst.props;
	      prevState = inst.state;
	      prevContext = inst.context;
	    }
	
	    if (inst.componentWillUpdate) {
	      inst.componentWillUpdate(nextProps, nextState, nextContext);
	    }
	
	    this._currentElement = nextElement;
	    this._context = unmaskedContext;
	    inst.props = nextProps;
	    inst.state = nextState;
	    inst.context = nextContext;
	
	    this._updateRenderedComponent(transaction, unmaskedContext);
	
	    if (hasComponentDidUpdate) {
	      transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
	    }
	  },
	
	  /**
	   * Call the component's `render` method and update the DOM accordingly.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  _updateRenderedComponent: function (transaction, context) {
	    var prevComponentInstance = this._renderedComponent;
	    var prevRenderedElement = prevComponentInstance._currentElement;
	    var nextRenderedElement = this._renderValidatedComponent();
	    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
	      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
	    } else {
	      // These two IDs are actually the same! But nothing should rely on that.
	      var thisID = this._rootNodeID;
	      var prevComponentID = prevComponentInstance._rootNodeID;
	      ReactReconciler.unmountComponent(prevComponentInstance);
	
	      this._renderedComponent = this._instantiateReactComponent(nextRenderedElement);
	      var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, thisID, transaction, this._processChildContext(context));
	      this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
	    }
	  },
	
	  /**
	   * @protected
	   */
	  _replaceNodeWithMarkupByID: function (prevComponentID, nextMarkup) {
	    ReactComponentEnvironment.replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
	  },
	
	  /**
	   * @protected
	   */
	  _renderValidatedComponentWithoutOwnerOrContext: function () {
	    var inst = this._instance;
	    var renderedComponent = inst.render();
	    if (false) {
	      // We allow auto-mocks to proceed as if they're returning null.
	      if (typeof renderedComponent === 'undefined' && inst.render._isMockFunction) {
	        // This is probably bad practice. Consider warning here and
	        // deprecating this convenience.
	        renderedComponent = null;
	      }
	    }
	
	    return renderedComponent;
	  },
	
	  /**
	   * @private
	   */
	  _renderValidatedComponent: function () {
	    var renderedComponent;
	    ReactCurrentOwner.current = this;
	    try {
	      renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
	    } finally {
	      ReactCurrentOwner.current = null;
	    }
	    !(
	    // TODO: An `isValidNode` function would probably be more appropriate
	    renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ?  false ? invariant(false, '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	    return renderedComponent;
	  },
	
	  /**
	   * Lazily allocates the refs object and stores `component` as `ref`.
	   *
	   * @param {string} ref Reference name.
	   * @param {component} component Component to store as `ref`.
	   * @final
	   * @private
	   */
	  attachRef: function (ref, component) {
	    var inst = this.getPublicInstance();
	    !(inst != null) ?  false ? invariant(false, 'Stateless function components cannot have refs.') : invariant(false) : undefined;
	    var publicComponentInstance = component.getPublicInstance();
	    if (false) {
	      var componentName = component && component.getName ? component.getName() : 'a component';
	      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : undefined;
	    }
	    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
	    refs[ref] = publicComponentInstance;
	  },
	
	  /**
	   * Detaches a reference name.
	   *
	   * @param {string} ref Name to dereference.
	   * @final
	   * @private
	   */
	  detachRef: function (ref) {
	    var refs = this.getPublicInstance().refs;
	    delete refs[ref];
	  },
	
	  /**
	   * Get a text description of the component that can be used to identify it
	   * in error messages.
	   * @return {string} The name or null.
	   * @internal
	   */
	  getName: function () {
	    var type = this._currentElement.type;
	    var constructor = this._instance && this._instance.constructor;
	    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
	  },
	
	  /**
	   * Get the publicly accessible representation of this component - i.e. what
	   * is exposed by refs and returned by render. Can be null for stateless
	   * components.
	   *
	   * @return {ReactComponent} the public component instance.
	   * @internal
	   */
	  getPublicInstance: function () {
	    var inst = this._instance;
	    if (inst instanceof StatelessComponent) {
	      return null;
	    }
	    return inst;
	  },
	
	  // Stub
	  _instantiateReactComponent: null
	
	};
	
	ReactPerf.measureMethods(ReactCompositeComponentMixin, 'ReactCompositeComponent', {
	  mountComponent: 'mountComponent',
	  updateComponent: 'updateComponent',
	  _renderValidatedComponent: '_renderValidatedComponent'
	});
	
	var ReactCompositeComponent = {
	
	  Mixin: ReactCompositeComponentMixin
	
	};
	
	module.exports = ReactCompositeComponent;

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentEnvironment
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(13);
	
	var injected = false;
	
	var ReactComponentEnvironment = {
	
	  /**
	   * Optionally injectable environment dependent cleanup hook. (server vs.
	   * browser etc). Example: A browser system caches DOM nodes based on component
	   * ID and must remove that cache entry when this instance is unmounted.
	   */
	  unmountIDFromEnvironment: null,
	
	  /**
	   * Optionally injectable hook for swapping out mount images in the middle of
	   * the tree.
	   */
	  replaceNodeWithMarkupByID: null,
	
	  /**
	   * Optionally injectable hook for processing a queue of child updates. Will
	   * later move into MultiChildComponents.
	   */
	  processChildrenUpdates: null,
	
	  injection: {
	    injectEnvironment: function (environment) {
	      !!injected ?  false ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : invariant(false) : undefined;
	      ReactComponentEnvironment.unmountIDFromEnvironment = environment.unmountIDFromEnvironment;
	      ReactComponentEnvironment.replaceNodeWithMarkupByID = environment.replaceNodeWithMarkupByID;
	      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
	      injected = true;
	    }
	  }
	
	};
	
	module.exports = ReactComponentEnvironment;

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocations
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(17);
	
	var ReactPropTypeLocations = keyMirror({
	  prop: null,
	  context: null,
	  childContext: null
	});
	
	module.exports = ReactPropTypeLocations;

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocationNames
	 */
	
	'use strict';
	
	var ReactPropTypeLocationNames = {};
	
	if (false) {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}
	
	module.exports = ReactPropTypeLocationNames;

/***/ },
/* 67 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shouldUpdateReactComponent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Given a `prevElement` and `nextElement`, determines if the existing
	 * instance should be updated as opposed to being destroyed or replaced by a new
	 * instance. Both arguments are elements. This ensures that this logic can
	 * operate on stateless trees without any backing instance.
	 *
	 * @param {?object} prevElement
	 * @param {?object} nextElement
	 * @return {boolean} True if the existing instance should be updated.
	 * @protected
	 */
	function shouldUpdateReactComponent(prevElement, nextElement) {
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	  if (prevEmpty || nextEmpty) {
	    return prevEmpty === nextEmpty;
	  }
	
	  var prevType = typeof prevElement;
	  var nextType = typeof nextElement;
	  if (prevType === 'string' || prevType === 'number') {
	    return nextType === 'string' || nextType === 'number';
	  } else {
	    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
	  }
	  return false;
	}
	
	module.exports = shouldUpdateReactComponent;

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEmptyComponent
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(42);
	var ReactEmptyComponentRegistry = __webpack_require__(44);
	var ReactReconciler = __webpack_require__(50);
	
	var assign = __webpack_require__(39);
	
	var placeholderElement;
	
	var ReactEmptyComponentInjection = {
	  injectEmptyComponent: function (component) {
	    placeholderElement = ReactElement.createElement(component);
	  }
	};
	
	var ReactEmptyComponent = function (instantiate) {
	  this._currentElement = null;
	  this._rootNodeID = null;
	  this._renderedComponent = instantiate(placeholderElement);
	};
	assign(ReactEmptyComponent.prototype, {
	  construct: function (element) {},
	  mountComponent: function (rootID, transaction, context) {
	    ReactEmptyComponentRegistry.registerNullComponentID(rootID);
	    this._rootNodeID = rootID;
	    return ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, context);
	  },
	  receiveComponent: function () {},
	  unmountComponent: function (rootID, transaction, context) {
	    ReactReconciler.unmountComponent(this._renderedComponent);
	    ReactEmptyComponentRegistry.deregisterNullComponentID(this._rootNodeID);
	    this._rootNodeID = null;
	    this._renderedComponent = null;
	  }
	});
	
	ReactEmptyComponent.injection = ReactEmptyComponentInjection;
	
	module.exports = ReactEmptyComponent;

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNativeComponent
	 */
	
	'use strict';
	
	var assign = __webpack_require__(39);
	var invariant = __webpack_require__(13);
	
	var autoGenerateWrapperClass = null;
	var genericComponentClass = null;
	// This registry keeps track of wrapper classes around native tags.
	var tagToComponentClass = {};
	var textComponentClass = null;
	
	var ReactNativeComponentInjection = {
	  // This accepts a class that receives the tag string. This is a catch all
	  // that can render any kind of tag.
	  injectGenericComponentClass: function (componentClass) {
	    genericComponentClass = componentClass;
	  },
	  // This accepts a text component class that takes the text string to be
	  // rendered as props.
	  injectTextComponentClass: function (componentClass) {
	    textComponentClass = componentClass;
	  },
	  // This accepts a keyed object with classes as values. Each key represents a
	  // tag. That particular tag will use this class instead of the generic one.
	  injectComponentClasses: function (componentClasses) {
	    assign(tagToComponentClass, componentClasses);
	  }
	};
	
	/**
	 * Get a composite component wrapper class for a specific tag.
	 *
	 * @param {ReactElement} element The tag for which to get the class.
	 * @return {function} The React class constructor function.
	 */
	function getComponentClassForElement(element) {
	  if (typeof element.type === 'function') {
	    return element.type;
	  }
	  var tag = element.type;
	  var componentClass = tagToComponentClass[tag];
	  if (componentClass == null) {
	    tagToComponentClass[tag] = componentClass = autoGenerateWrapperClass(tag);
	  }
	  return componentClass;
	}
	
	/**
	 * Get a native internal component class for a specific tag.
	 *
	 * @param {ReactElement} element The element to create.
	 * @return {function} The internal class constructor function.
	 */
	function createInternalComponent(element) {
	  !genericComponentClass ?  false ? invariant(false, 'There is no registered component for the tag %s', element.type) : invariant(false) : undefined;
	  return new genericComponentClass(element.type, element.props);
	}
	
	/**
	 * @param {ReactText} text
	 * @return {ReactComponent}
	 */
	function createInstanceForText(text) {
	  return new textComponentClass(text);
	}
	
	/**
	 * @param {ReactComponent} component
	 * @return {boolean}
	 */
	function isTextComponent(component) {
	  return component instanceof textComponentClass;
	}
	
	var ReactNativeComponent = {
	  getComponentClassForElement: getComponentClassForElement,
	  createInternalComponent: createInternalComponent,
	  createInstanceForText: createInstanceForText,
	  isTextComponent: isTextComponent,
	  injection: ReactNativeComponentInjection
	};
	
	module.exports = ReactNativeComponent;

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule validateDOMNesting
	 */
	
	'use strict';
	
	var assign = __webpack_require__(39);
	var emptyFunction = __webpack_require__(15);
	var warning = __webpack_require__(25);
	
	var validateDOMNesting = emptyFunction;
	
	if (false) {
	  // This validation code was written based on the HTML5 parsing spec:
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  //
	  // Note: this does not catch all invalid nesting, nor does it try to (as it's
	  // not clear what practical benefit doing so provides); instead, we warn only
	  // for cases where the parser will give a parse tree differing from what React
	  // intended. For example, <b><div></div></b> is invalid but we don't warn
	  // because it still parses correctly; we do warn for other cases like nested
	  // <p> tags where the beginning of the second element implicitly closes the
	  // first, causing a confusing mess.
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#special
	  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
	  // TODO: Distinguish by namespace here -- for <title>, including it here
	  // errs on the side of fewer warnings
	  'foreignObject', 'desc', 'title'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
	  var buttonScopeTags = inScopeTags.concat(['button']);
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
	  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
	
	  var emptyAncestorInfo = {
	    parentTag: null,
	
	    formTag: null,
	    aTagInScope: null,
	    buttonTagInScope: null,
	    nobrTagInScope: null,
	    pTagInButtonScope: null,
	
	    listItemTagAutoclosing: null,
	    dlItemTagAutoclosing: null
	  };
	
	  var updatedAncestorInfo = function (oldInfo, tag, instance) {
	    var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
	    var info = { tag: tag, instance: instance };
	
	    if (inScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.aTagInScope = null;
	      ancestorInfo.buttonTagInScope = null;
	      ancestorInfo.nobrTagInScope = null;
	    }
	    if (buttonScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.pTagInButtonScope = null;
	    }
	
	    // See rules for 'li', 'dd', 'dt' start tags in
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
	      ancestorInfo.listItemTagAutoclosing = null;
	      ancestorInfo.dlItemTagAutoclosing = null;
	    }
	
	    ancestorInfo.parentTag = info;
	
	    if (tag === 'form') {
	      ancestorInfo.formTag = info;
	    }
	    if (tag === 'a') {
	      ancestorInfo.aTagInScope = info;
	    }
	    if (tag === 'button') {
	      ancestorInfo.buttonTagInScope = info;
	    }
	    if (tag === 'nobr') {
	      ancestorInfo.nobrTagInScope = info;
	    }
	    if (tag === 'p') {
	      ancestorInfo.pTagInButtonScope = info;
	    }
	    if (tag === 'li') {
	      ancestorInfo.listItemTagAutoclosing = info;
	    }
	    if (tag === 'dd' || tag === 'dt') {
	      ancestorInfo.dlItemTagAutoclosing = info;
	    }
	
	    return ancestorInfo;
	  };
	
	  /**
	   * Returns whether
	   */
	  var isTagValidWithParent = function (tag, parentTag) {
	    // First, let's check if we're in an unusual parsing mode...
	    switch (parentTag) {
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
	      case 'select':
	        return tag === 'option' || tag === 'optgroup' || tag === '#text';
	      case 'optgroup':
	        return tag === 'option' || tag === '#text';
	      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
	      // but
	      case 'option':
	        return tag === '#text';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
	      // No special behavior since these rules fall back to "in body" mode for
	      // all except special table nodes which cause bad parsing behavior anyway.
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
	      case 'tr':
	        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
	      case 'tbody':
	      case 'thead':
	      case 'tfoot':
	        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
	      case 'colgroup':
	        return tag === 'col' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
	      case 'table':
	        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
	      case 'head':
	        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
	      case 'html':
	        return tag === 'head' || tag === 'body';
	    }
	
	    // Probably in the "in body" parsing mode, so we outlaw only tag combos
	    // where the parsing rules cause implicit opens or closes to be added.
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    switch (tag) {
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
	
	      case 'rp':
	      case 'rt':
	        return impliedEndTags.indexOf(parentTag) === -1;
	
	      case 'caption':
	      case 'col':
	      case 'colgroup':
	      case 'frame':
	      case 'head':
	      case 'tbody':
	      case 'td':
	      case 'tfoot':
	      case 'th':
	      case 'thead':
	      case 'tr':
	        // These tags are only valid with a few parents that have special child
	        // parsing rules -- if we're down here, then none of those matched and
	        // so we allow it only if we don't know what the parent is, as all other
	        // cases are invalid.
	        return parentTag == null;
	    }
	
	    return true;
	  };
	
	  /**
	   * Returns whether
	   */
	  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
	    switch (tag) {
	      case 'address':
	      case 'article':
	      case 'aside':
	      case 'blockquote':
	      case 'center':
	      case 'details':
	      case 'dialog':
	      case 'dir':
	      case 'div':
	      case 'dl':
	      case 'fieldset':
	      case 'figcaption':
	      case 'figure':
	      case 'footer':
	      case 'header':
	      case 'hgroup':
	      case 'main':
	      case 'menu':
	      case 'nav':
	      case 'ol':
	      case 'p':
	      case 'section':
	      case 'summary':
	      case 'ul':
	
	      case 'pre':
	      case 'listing':
	
	      case 'table':
	
	      case 'hr':
	
	      case 'xmp':
	
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return ancestorInfo.pTagInButtonScope;
	
	      case 'form':
	        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
	
	      case 'li':
	        return ancestorInfo.listItemTagAutoclosing;
	
	      case 'dd':
	      case 'dt':
	        return ancestorInfo.dlItemTagAutoclosing;
	
	      case 'button':
	        return ancestorInfo.buttonTagInScope;
	
	      case 'a':
	        // Spec says something about storing a list of markers, but it sounds
	        // equivalent to this check.
	        return ancestorInfo.aTagInScope;
	
	      case 'nobr':
	        return ancestorInfo.nobrTagInScope;
	    }
	
	    return null;
	  };
	
	  /**
	   * Given a ReactCompositeComponent instance, return a list of its recursive
	   * owners, starting at the root and ending with the instance itself.
	   */
	  var findOwnerStack = function (instance) {
	    if (!instance) {
	      return [];
	    }
	
	    var stack = [];
	    /*eslint-disable space-after-keywords */
	    do {
	      /*eslint-enable space-after-keywords */
	      stack.push(instance);
	    } while (instance = instance._currentElement._owner);
	    stack.reverse();
	    return stack;
	  };
	
	  var didWarn = {};
	
	  validateDOMNesting = function (childTag, childInstance, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.parentTag;
	    var parentTag = parentInfo && parentInfo.tag;
	
	    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
	    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
	    var problematic = invalidParent || invalidAncestor;
	
	    if (problematic) {
	      var ancestorTag = problematic.tag;
	      var ancestorInstance = problematic.instance;
	
	      var childOwner = childInstance && childInstance._currentElement._owner;
	      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;
	
	      var childOwners = findOwnerStack(childOwner);
	      var ancestorOwners = findOwnerStack(ancestorOwner);
	
	      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
	      var i;
	
	      var deepestCommon = -1;
	      for (i = 0; i < minStackLen; i++) {
	        if (childOwners[i] === ancestorOwners[i]) {
	          deepestCommon = i;
	        } else {
	          break;
	        }
	      }
	
	      var UNKNOWN = '(unknown)';
	      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ownerInfo = [].concat(
	      // If the parent and child instances have a common owner ancestor, start
	      // with that -- otherwise we just start with the parent's owners.
	      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
	      // If we're warning about an invalid (non-parent) ancestry, add '...'
	      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');
	
	      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
	      if (didWarn[warnKey]) {
	        return;
	      }
	      didWarn[warnKey] = true;
	
	      if (invalidParent) {
	        var info = '';
	        if (ancestorTag === 'table' && childTag === 'tr') {
	          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
	        }
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a child of <%s>. ' + 'See %s.%s', childTag, ancestorTag, ownerInfo, info) : undefined;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a descendant of ' + '<%s>. See %s.', childTag, ancestorTag, ownerInfo) : undefined;
	      }
	    }
	  };
	
	  validateDOMNesting.ancestorInfoContextKey = '__validateDOMNesting_ancestorInfo$' + Math.random().toString(36).slice(2);
	
	  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
	
	  // For testing
	  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.parentTag;
	    var parentTag = parentInfo && parentInfo.tag;
	    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
	  };
	}
	
	module.exports = validateDOMNesting;

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultInjection
	 */
	
	'use strict';
	
	var BeforeInputEventPlugin = __webpack_require__(72);
	var ChangeEventPlugin = __webpack_require__(80);
	var ClientReactRootIndex = __webpack_require__(83);
	var DefaultEventPluginOrder = __webpack_require__(84);
	var EnterLeaveEventPlugin = __webpack_require__(85);
	var ExecutionEnvironment = __webpack_require__(9);
	var HTMLDOMPropertyConfig = __webpack_require__(89);
	var ReactBrowserComponentMixin = __webpack_require__(90);
	var ReactComponentBrowserEnvironment = __webpack_require__(26);
	var ReactDefaultBatchingStrategy = __webpack_require__(92);
	var ReactDOMComponent = __webpack_require__(93);
	var ReactDOMTextComponent = __webpack_require__(6);
	var ReactEventListener = __webpack_require__(118);
	var ReactInjection = __webpack_require__(121);
	var ReactInstanceHandles = __webpack_require__(45);
	var ReactMount = __webpack_require__(28);
	var ReactReconcileTransaction = __webpack_require__(125);
	var SelectEventPlugin = __webpack_require__(130);
	var ServerReactRootIndex = __webpack_require__(131);
	var SimpleEventPlugin = __webpack_require__(132);
	var SVGDOMPropertyConfig = __webpack_require__(141);
	
	var alreadyInjected = false;
	
	function inject() {
	  if (alreadyInjected) {
	    // TODO: This is currently true because these injections are shared between
	    // the client and the server package. They should be built independently
	    // and not share any injection state. Then this problem will be solved.
	    return;
	  }
	  alreadyInjected = true;
	
	  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
	
	  /**
	   * Inject modules for resolving DOM hierarchy and plugin ordering.
	   */
	  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
	  ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
	  ReactInjection.EventPluginHub.injectMount(ReactMount);
	
	  /**
	   * Some important event plugins included by default (without having to require
	   * them).
	   */
	  ReactInjection.EventPluginHub.injectEventPluginsByName({
	    SimpleEventPlugin: SimpleEventPlugin,
	    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
	    ChangeEventPlugin: ChangeEventPlugin,
	    SelectEventPlugin: SelectEventPlugin,
	    BeforeInputEventPlugin: BeforeInputEventPlugin
	  });
	
	  ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);
	
	  ReactInjection.NativeComponent.injectTextComponentClass(ReactDOMTextComponent);
	
	  ReactInjection.Class.injectMixin(ReactBrowserComponentMixin);
	
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
	
	  ReactInjection.EmptyComponent.injectEmptyComponent('noscript');
	
	  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
	  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	
	  ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex);
	
	  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
	
	  if (false) {
	    var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
	    if (/[?&]react_perf\b/.test(url)) {
	      var ReactDefaultPerf = require('./ReactDefaultPerf');
	      ReactDefaultPerf.start();
	    }
	  }
	}
	
	module.exports = {
	  inject: inject
	};

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015 Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule BeforeInputEventPlugin
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(30);
	var EventPropagators = __webpack_require__(73);
	var ExecutionEnvironment = __webpack_require__(9);
	var FallbackCompositionState = __webpack_require__(74);
	var SyntheticCompositionEvent = __webpack_require__(76);
	var SyntheticInputEvent = __webpack_require__(78);
	
	var keyOf = __webpack_require__(79);
	
	var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
	var START_KEYCODE = 229;
	
	var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
	
	var documentMode = null;
	if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
	  documentMode = document.documentMode;
	}
	
	// Webkit offers a very useful `textInput` event that can be used to
	// directly represent `beforeInput`. The IE `textinput` event is not as
	// useful, so we don't use it.
	var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();
	
	// In IE9+, we have access to composition events, but the data supplied
	// by the native compositionend event may be incorrect. Japanese ideographic
	// spaces, for instance (\u3000) are not recorded correctly.
	var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
	
	/**
	 * Opera <= 12 includes TextEvent in window, but does not fire
	 * text input events. Rely on keypress instead.
	 */
	function isPresto() {
	  var opera = window.opera;
	  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
	}
	
	var SPACEBAR_CODE = 32;
	var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	// Events and their corresponding property names.
	var eventTypes = {
	  beforeInput: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBeforeInput: null }),
	      captured: keyOf({ onBeforeInputCapture: null })
	    },
	    dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
	  },
	  compositionEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionEnd: null }),
	      captured: keyOf({ onCompositionEndCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionStart: null }),
	      captured: keyOf({ onCompositionStartCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionUpdate: null }),
	      captured: keyOf({ onCompositionUpdateCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  }
	};
	
	// Track whether we've ever handled a keypress on the space key.
	var hasSpaceKeypress = false;
	
	/**
	 * Return whether a native keypress event is assumed to be a command.
	 * This is required because Firefox fires `keypress` events for key commands
	 * (cut, copy, select-all, etc.) even though no character is inserted.
	 */
	function isKeypressCommand(nativeEvent) {
	  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
	  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
	  !(nativeEvent.ctrlKey && nativeEvent.altKey);
	}
	
	/**
	 * Translate native top level events into event types.
	 *
	 * @param {string} topLevelType
	 * @return {object}
	 */
	function getCompositionEventType(topLevelType) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionStart:
	      return eventTypes.compositionStart;
	    case topLevelTypes.topCompositionEnd:
	      return eventTypes.compositionEnd;
	    case topLevelTypes.topCompositionUpdate:
	      return eventTypes.compositionUpdate;
	  }
	}
	
	/**
	 * Does our fallback best-guess model think this event signifies that
	 * composition has begun?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionStart(topLevelType, nativeEvent) {
	  return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
	}
	
	/**
	 * Does our fallback mode think that this event is the end of composition?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionEnd(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topKeyUp:
	      // Command keys insert or clear IME input.
	      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
	    case topLevelTypes.topKeyDown:
	      // Expect IME keyCode on each keydown. If we get any other
	      // code we must have exited earlier.
	      return nativeEvent.keyCode !== START_KEYCODE;
	    case topLevelTypes.topKeyPress:
	    case topLevelTypes.topMouseDown:
	    case topLevelTypes.topBlur:
	      // Events are not possible without cancelling IME.
	      return true;
	    default:
	      return false;
	  }
	}
	
	/**
	 * Google Input Tools provides composition data via a CustomEvent,
	 * with the `data` property populated in the `detail` object. If this
	 * is available on the event object, use it. If not, this is a plain
	 * composition event and we have nothing special to extract.
	 *
	 * @param {object} nativeEvent
	 * @return {?string}
	 */
	function getDataFromCustomEvent(nativeEvent) {
	  var detail = nativeEvent.detail;
	  if (typeof detail === 'object' && 'data' in detail) {
	    return detail.data;
	  }
	  return null;
	}
	
	// Track the current IME composition fallback object, if any.
	var currentComposition = null;
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {DOMEventTarget} topLevelTarget The listening component root node.
	 * @param {string} topLevelTargetID ID of `topLevelTarget`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?object} A SyntheticCompositionEvent.
	 */
	function extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	  var eventType;
	  var fallbackData;
	
	  if (canUseCompositionEvent) {
	    eventType = getCompositionEventType(topLevelType);
	  } else if (!currentComposition) {
	    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
	      eventType = eventTypes.compositionStart;
	    }
	  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	    eventType = eventTypes.compositionEnd;
	  }
	
	  if (!eventType) {
	    return null;
	  }
	
	  if (useFallbackCompositionData) {
	    // The current composition is stored statically and must not be
	    // overwritten while composition continues.
	    if (!currentComposition && eventType === eventTypes.compositionStart) {
	      currentComposition = FallbackCompositionState.getPooled(topLevelTarget);
	    } else if (eventType === eventTypes.compositionEnd) {
	      if (currentComposition) {
	        fallbackData = currentComposition.getData();
	      }
	    }
	  }
	
	  var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent, nativeEventTarget);
	
	  if (fallbackData) {
	    // Inject data generated from fallback path into the synthetic event.
	    // This matches the property of native CompositionEventInterface.
	    event.data = fallbackData;
	  } else {
	    var customData = getDataFromCustomEvent(nativeEvent);
	    if (customData !== null) {
	      event.data = customData;
	    }
	  }
	
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The string corresponding to this `beforeInput` event.
	 */
	function getNativeBeforeInputChars(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionEnd:
	      return getDataFromCustomEvent(nativeEvent);
	    case topLevelTypes.topKeyPress:
	      /**
	       * If native `textInput` events are available, our goal is to make
	       * use of them. However, there is a special case: the spacebar key.
	       * In Webkit, preventing default on a spacebar `textInput` event
	       * cancels character insertion, but it *also* causes the browser
	       * to fall back to its default spacebar behavior of scrolling the
	       * page.
	       *
	       * Tracking at:
	       * https://code.google.com/p/chromium/issues/detail?id=355103
	       *
	       * To avoid this issue, use the keypress event as if no `textInput`
	       * event is available.
	       */
	      var which = nativeEvent.which;
	      if (which !== SPACEBAR_CODE) {
	        return null;
	      }
	
	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;
	
	    case topLevelTypes.topTextInput:
	      // Record the characters to be added to the DOM.
	      var chars = nativeEvent.data;
	
	      // If it's a spacebar character, assume that we have already handled
	      // it at the keypress level and bail immediately. Android Chrome
	      // doesn't give us keycodes, so we need to blacklist it.
	      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
	        return null;
	      }
	
	      return chars;
	
	    default:
	      // For other native event types, do nothing.
	      return null;
	  }
	}
	
	/**
	 * For browsers that do not provide the `textInput` event, extract the
	 * appropriate string to use for SyntheticInputEvent.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The fallback string for this `beforeInput` event.
	 */
	function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
	  // If we are currently composing (IME) and using a fallback to do so,
	  // try to extract the composed characters from the fallback object.
	  if (currentComposition) {
	    if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	      var chars = currentComposition.getData();
	      FallbackCompositionState.release(currentComposition);
	      currentComposition = null;
	      return chars;
	    }
	    return null;
	  }
	
	  switch (topLevelType) {
	    case topLevelTypes.topPaste:
	      // If a paste event occurs after a keypress, throw out the input
	      // chars. Paste events should not lead to BeforeInput events.
	      return null;
	    case topLevelTypes.topKeyPress:
	      /**
	       * As of v27, Firefox may fire keypress events even when no character
	       * will be inserted. A few possibilities:
	       *
	       * - `which` is `0`. Arrow keys, Esc key, etc.
	       *
	       * - `which` is the pressed key code, but no char is available.
	       *   Ex: 'AltGr + d` in Polish. There is no modified character for
	       *   this key combination and no character is inserted into the
	       *   document, but FF fires the keypress for char code `100` anyway.
	       *   No `input` event will occur.
	       *
	       * - `which` is the pressed key code, but a command combination is
	       *   being used. Ex: `Cmd+C`. No character is inserted, and no
	       *   `input` event will occur.
	       */
	      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
	        return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case topLevelTypes.topCompositionEnd:
	      return useFallbackCompositionData ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}
	
	/**
	 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
	 * `textInput` or fallback behavior.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {DOMEventTarget} topLevelTarget The listening component root node.
	 * @param {string} topLevelTargetID ID of `topLevelTarget`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?object} A SyntheticInputEvent.
	 */
	function extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	  var chars;
	
	  if (canUseTextInputEvent) {
	    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
	  } else {
	    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
	  }
	
	  // If no characters are being inserted, no BeforeInput event should
	  // be fired.
	  if (!chars) {
	    return null;
	  }
	
	  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent, nativeEventTarget);
	
	  event.data = chars;
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * Create an `onBeforeInput` event to match
	 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
	 *
	 * This event plugin is based on the native `textInput` event
	 * available in Chrome, Safari, Opera, and IE. This event fires after
	 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
	 *
	 * `beforeInput` is spec'd but not implemented in any browsers, and
	 * the `input` event does not provide any useful information about what has
	 * actually been added, contrary to the spec. Thus, `textInput` is the best
	 * available event to identify the characters that have actually been inserted
	 * into the target node.
	 *
	 * This plugin is also responsible for emitting `composition` events, thus
	 * allowing us to share composition fallback code for both `beforeInput` and
	 * `composition` event types.
	 */
	var BeforeInputEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    return [extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget)];
	  }
	};
	
	module.exports = BeforeInputEventPlugin;

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPropagators
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(30);
	var EventPluginHub = __webpack_require__(31);
	
	var warning = __webpack_require__(25);
	
	var accumulateInto = __webpack_require__(35);
	var forEachAccumulated = __webpack_require__(36);
	
	var PropagationPhases = EventConstants.PropagationPhases;
	var getListener = EventPluginHub.getListener;
	
	/**
	 * Some event types have a notion of different registration names for different
	 * "phases" of propagation. This finds listeners by a given phase.
	 */
	function listenerAtPhase(id, event, propagationPhase) {
	  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
	  return getListener(id, registrationName);
	}
	
	/**
	 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
	 * here, allows us to not have to bind or create functions for each event.
	 * Mutating the event's members allows us to not have to create a wrapping
	 * "dispatch" object that pairs the event with the listener.
	 */
	function accumulateDirectionalDispatches(domID, upwards, event) {
	  if (false) {
	    process.env.NODE_ENV !== 'production' ? warning(domID, 'Dispatching id must not be null') : undefined;
	  }
	  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
	  var listener = listenerAtPhase(domID, event, phase);
	  if (listener) {
	    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
	  }
	}
	
	/**
	 * Collect dispatches (must be entirely collected before dispatching - see unit
	 * tests). Lazily allocate the array to conserve memory.  We must loop through
	 * each event and perform the traversal for each one. We cannot perform a
	 * single traversal for the entire collection of events because each event may
	 * have a different target.
	 */
	function accumulateTwoPhaseDispatchesSingle(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
	 */
	function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginHub.injection.getInstanceHandle().traverseTwoPhaseSkipTarget(event.dispatchMarker, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Accumulates without regard to direction, does not look for phased
	 * registration names. Same as `accumulateDirectDispatchesSingle` but without
	 * requiring that the `dispatchMarker` be the same as the dispatched ID.
	 */
	function accumulateDispatches(id, ignoredDirection, event) {
	  if (event && event.dispatchConfig.registrationName) {
	    var registrationName = event.dispatchConfig.registrationName;
	    var listener = getListener(id, registrationName);
	    if (listener) {
	      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	      event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
	    }
	  }
	}
	
	/**
	 * Accumulates dispatches on an `SyntheticEvent`, but only for the
	 * `dispatchMarker`.
	 * @param {SyntheticEvent} event
	 */
	function accumulateDirectDispatchesSingle(event) {
	  if (event && event.dispatchConfig.registrationName) {
	    accumulateDispatches(event.dispatchMarker, null, event);
	  }
	}
	
	function accumulateTwoPhaseDispatches(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
	}
	
	function accumulateTwoPhaseDispatchesSkipTarget(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
	}
	
	function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
	  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);
	}
	
	function accumulateDirectDispatches(events) {
	  forEachAccumulated(events, accumulateDirectDispatchesSingle);
	}
	
	/**
	 * A small set of propagation patterns, each of which will accept a small amount
	 * of information, and generate a set of "dispatch ready event objects" - which
	 * are sets of events that have already been annotated with a set of dispatched
	 * listener functions/ids. The API is designed this way to discourage these
	 * propagation strategies from actually executing the dispatches, since we
	 * always want to collect the entire set of dispatches before executing event a
	 * single one.
	 *
	 * @constructor EventPropagators
	 */
	var EventPropagators = {
	  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	  accumulateDirectDispatches: accumulateDirectDispatches,
	  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
	};
	
	module.exports = EventPropagators;

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule FallbackCompositionState
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(56);
	
	var assign = __webpack_require__(39);
	var getTextContentAccessor = __webpack_require__(75);
	
	/**
	 * This helper class stores information about text content of a target node,
	 * allowing comparison of content before and after a given event.
	 *
	 * Identify the node where selection currently begins, then observe
	 * both its text content and its current position in the DOM. Since the
	 * browser may natively replace the target node during composition, we can
	 * use its position to find its replacement.
	 *
	 * @param {DOMEventTarget} root
	 */
	function FallbackCompositionState(root) {
	  this._root = root;
	  this._startText = this.getText();
	  this._fallbackText = null;
	}
	
	assign(FallbackCompositionState.prototype, {
	  destructor: function () {
	    this._root = null;
	    this._startText = null;
	    this._fallbackText = null;
	  },
	
	  /**
	   * Get current text of input.
	   *
	   * @return {string}
	   */
	  getText: function () {
	    if ('value' in this._root) {
	      return this._root.value;
	    }
	    return this._root[getTextContentAccessor()];
	  },
	
	  /**
	   * Determine the differing substring between the initially stored
	   * text content and the current content.
	   *
	   * @return {string}
	   */
	  getData: function () {
	    if (this._fallbackText) {
	      return this._fallbackText;
	    }
	
	    var start;
	    var startValue = this._startText;
	    var startLength = startValue.length;
	    var end;
	    var endValue = this.getText();
	    var endLength = endValue.length;
	
	    for (start = 0; start < startLength; start++) {
	      if (startValue[start] !== endValue[start]) {
	        break;
	      }
	    }
	
	    var minEnd = startLength - start;
	    for (end = 1; end <= minEnd; end++) {
	      if (startValue[startLength - end] !== endValue[endLength - end]) {
	        break;
	      }
	    }
	
	    var sliceTail = end > 1 ? 1 - end : undefined;
	    this._fallbackText = endValue.slice(start, sliceTail);
	    return this._fallbackText;
	  }
	});
	
	PooledClass.addPoolingTo(FallbackCompositionState);
	
	module.exports = FallbackCompositionState;

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getTextContentAccessor
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var contentKey = null;
	
	/**
	 * Gets the key used to access text content on a DOM node.
	 *
	 * @return {?string} Key used to access text content.
	 * @internal
	 */
	function getTextContentAccessor() {
	  if (!contentKey && ExecutionEnvironment.canUseDOM) {
	    // Prefer textContent to innerText because many browsers support both but
	    // SVG <text> elements don't support innerText even when <div> does.
	    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
	  }
	  return contentKey;
	}
	
	module.exports = getTextContentAccessor;

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticCompositionEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(77);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
	 */
	var CompositionEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
	
	module.exports = SyntheticCompositionEvent;

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(56);
	
	var assign = __webpack_require__(39);
	var emptyFunction = __webpack_require__(15);
	var warning = __webpack_require__(25);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var EventInterface = {
	  type: null,
	  // currentTarget is set when dispatching; no use in copying it here
	  currentTarget: emptyFunction.thatReturnsNull,
	  eventPhase: null,
	  bubbles: null,
	  cancelable: null,
	  timeStamp: function (event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: null,
	  isTrusted: null
	};
	
	/**
	 * Synthetic events are dispatched by event plugins, typically in response to a
	 * top-level event delegation handler.
	 *
	 * These systems should generally use pooling to reduce the frequency of garbage
	 * collection. The system should check `isPersistent` to determine whether the
	 * event should be released into the pool after being dispatched. Users that
	 * need a persisted event should invoke `persist`.
	 *
	 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
	 * normalizing browser quirks. Subclasses do not necessarily have to implement a
	 * DOM interface; custom application-specific events can also subclass this.
	 *
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 */
	function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  this.dispatchConfig = dispatchConfig;
	  this.dispatchMarker = dispatchMarker;
	  this.nativeEvent = nativeEvent;
	  this.target = nativeEventTarget;
	  this.currentTarget = nativeEventTarget;
	
	  var Interface = this.constructor.Interface;
	  for (var propName in Interface) {
	    if (!Interface.hasOwnProperty(propName)) {
	      continue;
	    }
	    var normalize = Interface[propName];
	    if (normalize) {
	      this[propName] = normalize(nativeEvent);
	    } else {
	      this[propName] = nativeEvent[propName];
	    }
	  }
	
	  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
	  if (defaultPrevented) {
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  } else {
	    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
	  }
	  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
	}
	
	assign(SyntheticEvent.prototype, {
	
	  preventDefault: function () {
	    this.defaultPrevented = true;
	    var event = this.nativeEvent;
	    if (false) {
	      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `preventDefault` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
	    }
	    if (!event) {
	      return;
	    }
	
	    if (event.preventDefault) {
	      event.preventDefault();
	    } else {
	      event.returnValue = false;
	    }
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  },
	
	  stopPropagation: function () {
	    var event = this.nativeEvent;
	    if (false) {
	      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `stopPropagation` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
	    }
	    if (!event) {
	      return;
	    }
	
	    if (event.stopPropagation) {
	      event.stopPropagation();
	    } else {
	      event.cancelBubble = true;
	    }
	    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * We release all dispatched `SyntheticEvent`s after each event loop, adding
	   * them back into the pool. This allows a way to hold onto a reference that
	   * won't be added back into the pool.
	   */
	  persist: function () {
	    this.isPersistent = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * Checks if this event should be released back into the pool.
	   *
	   * @return {boolean} True if this should not be released, false otherwise.
	   */
	  isPersistent: emptyFunction.thatReturnsFalse,
	
	  /**
	   * `PooledClass` looks for `destructor` on each instance it releases.
	   */
	  destructor: function () {
	    var Interface = this.constructor.Interface;
	    for (var propName in Interface) {
	      this[propName] = null;
	    }
	    this.dispatchConfig = null;
	    this.dispatchMarker = null;
	    this.nativeEvent = null;
	  }
	
	});
	
	SyntheticEvent.Interface = EventInterface;
	
	/**
	 * Helper to reduce boilerplate when creating subclasses.
	 *
	 * @param {function} Class
	 * @param {?object} Interface
	 */
	SyntheticEvent.augmentClass = function (Class, Interface) {
	  var Super = this;
	
	  var prototype = Object.create(Super.prototype);
	  assign(prototype, Class.prototype);
	  Class.prototype = prototype;
	  Class.prototype.constructor = Class;
	
	  Class.Interface = assign({}, Super.Interface, Interface);
	  Class.augmentClass = Super.augmentClass;
	
	  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
	};
	
	PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
	
	module.exports = SyntheticEvent;

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticInputEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(77);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
	 *      /#events-inputevents
	 */
	var InputEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
	
	module.exports = SyntheticInputEvent;

/***/ },
/* 79 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule keyOf
	 */
	
	/**
	 * Allows extraction of a minified key. Let's the build system minify keys
	 * without losing the ability to dynamically use key strings as values
	 * themselves. Pass in an object with a single key/val pair and it will return
	 * you the string key of that single record. Suppose you want to grab the
	 * value for a key 'className' inside of an object. Key/val minification may
	 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
	 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
	 * reuse those resolutions.
	 */
	"use strict";
	
	var keyOf = function (oneKeyObj) {
	  var key;
	  for (key in oneKeyObj) {
	    if (!oneKeyObj.hasOwnProperty(key)) {
	      continue;
	    }
	    return key;
	  }
	  return null;
	};
	
	module.exports = keyOf;

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ChangeEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(30);
	var EventPluginHub = __webpack_require__(31);
	var EventPropagators = __webpack_require__(73);
	var ExecutionEnvironment = __webpack_require__(9);
	var ReactUpdates = __webpack_require__(54);
	var SyntheticEvent = __webpack_require__(77);
	
	var getEventTarget = __webpack_require__(81);
	var isEventSupported = __webpack_require__(40);
	var isTextInputElement = __webpack_require__(82);
	var keyOf = __webpack_require__(79);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  change: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onChange: null }),
	      captured: keyOf({ onChangeCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	/**
	 * For IE shims
	 */
	var activeElement = null;
	var activeElementID = null;
	var activeElementValue = null;
	var activeElementValueProp = null;
	
	/**
	 * SECTION: handle `change` event
	 */
	function shouldUseChangeEvent(elem) {
	  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
	}
	
	var doesChangeEventBubble = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // See `handleChange` comment below
	  doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
	}
	
	function manualDispatchChangeEvent(nativeEvent) {
	  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent, getEventTarget(nativeEvent));
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	
	  // If change and propertychange bubbled, we'd just bind to it like all the
	  // other events and have it go through ReactBrowserEventEmitter. Since it
	  // doesn't, we manually listen for the events and so we have to enqueue and
	  // process the abstract event manually.
	  //
	  // Batching is necessary here in order to ensure that all event handlers run
	  // before the next rerender (including event handlers attached to ancestor
	  // elements instead of directly on the input). Without this, controlled
	  // components don't work properly in conjunction with event bubbling because
	  // the component is rerendered and the value reverted before all the event
	  // handlers can run. See https://github.com/facebook/react/issues/708.
	  ReactUpdates.batchedUpdates(runEventInBatch, event);
	}
	
	function runEventInBatch(event) {
	  EventPluginHub.enqueueEvents(event);
	  EventPluginHub.processEventQueue(false);
	}
	
	function startWatchingForChangeEventIE8(target, targetID) {
	  activeElement = target;
	  activeElementID = targetID;
	  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
	}
	
	function stopWatchingForChangeEventIE8() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
	  activeElement = null;
	  activeElementID = null;
	}
	
	function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topChange) {
	    return topLevelTargetID;
	  }
	}
	function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForChangeEventIE8();
	    startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForChangeEventIE8();
	  }
	}
	
	/**
	 * SECTION: handle `input` event
	 */
	var isInputEventSupported = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // IE9 claims to support the input event but fails to trigger it when
	  // deleting text, so we ignore its input events
	  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
	}
	
	/**
	 * (For old IE.) Replacement getter/setter for the `value` property that gets
	 * set on the active element.
	 */
	var newValueProp = {
	  get: function () {
	    return activeElementValueProp.get.call(this);
	  },
	  set: function (val) {
	    // Cast to a string so we can do equality checks.
	    activeElementValue = '' + val;
	    activeElementValueProp.set.call(this, val);
	  }
	};
	
	/**
	 * (For old IE.) Starts tracking propertychange events on the passed-in element
	 * and override the value property so that we can distinguish user events from
	 * value changes in JS.
	 */
	function startWatchingForValueChange(target, targetID) {
	  activeElement = target;
	  activeElementID = targetID;
	  activeElementValue = target.value;
	  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
	
	  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
	  // on DOM elements
	  Object.defineProperty(activeElement, 'value', newValueProp);
	  activeElement.attachEvent('onpropertychange', handlePropertyChange);
	}
	
	/**
	 * (For old IE.) Removes the event listeners from the currently-tracked element,
	 * if any exists.
	 */
	function stopWatchingForValueChange() {
	  if (!activeElement) {
	    return;
	  }
	
	  // delete restores the original property definition
	  delete activeElement.value;
	  activeElement.detachEvent('onpropertychange', handlePropertyChange);
	
	  activeElement = null;
	  activeElementID = null;
	  activeElementValue = null;
	  activeElementValueProp = null;
	}
	
	/**
	 * (For old IE.) Handles a propertychange event, sending a `change` event if
	 * the value of the active element has changed.
	 */
	function handlePropertyChange(nativeEvent) {
	  if (nativeEvent.propertyName !== 'value') {
	    return;
	  }
	  var value = nativeEvent.srcElement.value;
	  if (value === activeElementValue) {
	    return;
	  }
	  activeElementValue = value;
	
	  manualDispatchChangeEvent(nativeEvent);
	}
	
	/**
	 * If a `change` event should be fired, returns the target's ID.
	 */
	function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topInput) {
	    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
	    // what we want so fall through here and trigger an abstract event
	    return topLevelTargetID;
	  }
	}
	
	// For IE8 and IE9.
	function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // In IE8, we can capture almost all .value changes by adding a
	    // propertychange handler and looking for events with propertyName
	    // equal to 'value'
	    // In IE9, propertychange fires for most input events but is buggy and
	    // doesn't fire when text is deleted, but conveniently, selectionchange
	    // appears to fire in all of the remaining cases so we catch those and
	    // forward the event if the value has changed
	    // In either case, we don't want to call the event handler if the value
	    // is changed from JS so we redefine a setter for `.value` that updates
	    // our activeElementValue variable, allowing us to ignore those changes
	    //
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForValueChange();
	    startWatchingForValueChange(topLevelTarget, topLevelTargetID);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForValueChange();
	  }
	}
	
	// For IE8 and IE9.
	function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
	    // On the selectionchange event, the target is just document which isn't
	    // helpful for us so just check activeElement instead.
	    //
	    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
	    // propertychange on the first input event after setting `value` from a
	    // script and fires only keydown, keypress, keyup. Catching keyup usually
	    // gets it and catching keydown lets us fire an event for the first
	    // keystroke if user does a key repeat (it'll be a little delayed: right
	    // before the second keystroke). Other input methods (e.g., paste) seem to
	    // fire selectionchange normally.
	    if (activeElement && activeElement.value !== activeElementValue) {
	      activeElementValue = activeElement.value;
	      return activeElementID;
	    }
	  }
	}
	
	/**
	 * SECTION: handle `click` event
	 */
	function shouldUseClickEvent(elem) {
	  // Use the `click` event to detect changes to checkbox and radio inputs.
	  // This approach works across all browsers, whereas `change` does not fire
	  // until `blur` in IE8.
	  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
	}
	
	function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topClick) {
	    return topLevelTargetID;
	  }
	}
	
	/**
	 * This plugin creates an `onChange` event that normalizes change events
	 * across form elements. This event fires at a time when it's possible to
	 * change the element's value without seeing a flicker.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - select
	 */
	var ChangeEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	
	    var getTargetIDFunc, handleEventFunc;
	    if (shouldUseChangeEvent(topLevelTarget)) {
	      if (doesChangeEventBubble) {
	        getTargetIDFunc = getTargetIDForChangeEvent;
	      } else {
	        handleEventFunc = handleEventsForChangeEventIE8;
	      }
	    } else if (isTextInputElement(topLevelTarget)) {
	      if (isInputEventSupported) {
	        getTargetIDFunc = getTargetIDForInputEvent;
	      } else {
	        getTargetIDFunc = getTargetIDForInputEventIE;
	        handleEventFunc = handleEventsForInputEventIE;
	      }
	    } else if (shouldUseClickEvent(topLevelTarget)) {
	      getTargetIDFunc = getTargetIDForClickEvent;
	    }
	
	    if (getTargetIDFunc) {
	      var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);
	      if (targetID) {
	        var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent, nativeEventTarget);
	        event.type = 'change';
	        EventPropagators.accumulateTwoPhaseDispatches(event);
	        return event;
	      }
	    }
	
	    if (handleEventFunc) {
	      handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID);
	    }
	  }
	
	};
	
	module.exports = ChangeEventPlugin;

/***/ },
/* 81 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventTarget
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Gets the target node from a native browser event by accounting for
	 * inconsistencies in browser DOM APIs.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {DOMEventTarget} Target node.
	 */
	function getEventTarget(nativeEvent) {
	  var target = nativeEvent.target || nativeEvent.srcElement || window;
	  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
	  // @see http://www.quirksmode.org/js/events_properties.html
	  return target.nodeType === 3 ? target.parentNode : target;
	}
	
	module.exports = getEventTarget;

/***/ },
/* 82 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextInputElement
	 */
	
	'use strict';
	
	/**
	 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
	 */
	var supportedInputTypes = {
	  'color': true,
	  'date': true,
	  'datetime': true,
	  'datetime-local': true,
	  'email': true,
	  'month': true,
	  'number': true,
	  'password': true,
	  'range': true,
	  'search': true,
	  'tel': true,
	  'text': true,
	  'time': true,
	  'url': true,
	  'week': true
	};
	
	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName && (nodeName === 'input' && supportedInputTypes[elem.type] || nodeName === 'textarea');
	}
	
	module.exports = isTextInputElement;

/***/ },
/* 83 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ClientReactRootIndex
	 * @typechecks
	 */
	
	'use strict';
	
	var nextReactRootIndex = 0;
	
	var ClientReactRootIndex = {
	  createReactRootIndex: function () {
	    return nextReactRootIndex++;
	  }
	};
	
	module.exports = ClientReactRootIndex;

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DefaultEventPluginOrder
	 */
	
	'use strict';
	
	var keyOf = __webpack_require__(79);
	
	/**
	 * Module that is injectable into `EventPluginHub`, that specifies a
	 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
	 * plugins, without having to package every one of them. This is better than
	 * having plugins be ordered in the same order that they are injected because
	 * that ordering would be influenced by the packaging order.
	 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
	 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
	 */
	var DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null })];
	
	module.exports = DefaultEventPluginOrder;

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EnterLeaveEventPlugin
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(30);
	var EventPropagators = __webpack_require__(73);
	var SyntheticMouseEvent = __webpack_require__(86);
	
	var ReactMount = __webpack_require__(28);
	var keyOf = __webpack_require__(79);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	var getFirstReactDOM = ReactMount.getFirstReactDOM;
	
	var eventTypes = {
	  mouseEnter: {
	    registrationName: keyOf({ onMouseEnter: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  },
	  mouseLeave: {
	    registrationName: keyOf({ onMouseLeave: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  }
	};
	
	var extractedEvents = [null, null];
	
	var EnterLeaveEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * For almost every interaction we care about, there will be both a top-level
	   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
	   * we do not extract duplicate events. However, moving the mouse into the
	   * browser from outside will not fire a `mouseout` event. In this case, we use
	   * the `mouseover` top-level event.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
	      return null;
	    }
	    if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
	      // Must not be a mouse in or mouse out - ignoring.
	      return null;
	    }
	
	    var win;
	    if (topLevelTarget.window === topLevelTarget) {
	      // `topLevelTarget` is probably a window object.
	      win = topLevelTarget;
	    } else {
	      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	      var doc = topLevelTarget.ownerDocument;
	      if (doc) {
	        win = doc.defaultView || doc.parentWindow;
	      } else {
	        win = window;
	      }
	    }
	
	    var from;
	    var to;
	    var fromID = '';
	    var toID = '';
	    if (topLevelType === topLevelTypes.topMouseOut) {
	      from = topLevelTarget;
	      fromID = topLevelTargetID;
	      to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement);
	      if (to) {
	        toID = ReactMount.getID(to);
	      } else {
	        to = win;
	      }
	      to = to || win;
	    } else {
	      from = win;
	      to = topLevelTarget;
	      toID = topLevelTargetID;
	    }
	
	    if (from === to) {
	      // Nothing pertains to our managed components.
	      return null;
	    }
	
	    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent, nativeEventTarget);
	    leave.type = 'mouseleave';
	    leave.target = from;
	    leave.relatedTarget = to;
	
	    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent, nativeEventTarget);
	    enter.type = 'mouseenter';
	    enter.target = to;
	    enter.relatedTarget = from;
	
	    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);
	
	    extractedEvents[0] = leave;
	    extractedEvents[1] = enter;
	
	    return extractedEvents;
	  }
	
	};
	
	module.exports = EnterLeaveEventPlugin;

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticMouseEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(87);
	var ViewportMetrics = __webpack_require__(38);
	
	var getEventModifierState = __webpack_require__(88);
	
	/**
	 * @interface MouseEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var MouseEventInterface = {
	  screenX: null,
	  screenY: null,
	  clientX: null,
	  clientY: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  getModifierState: getEventModifierState,
	  button: function (event) {
	    // Webkit, Firefox, IE9+
	    // which:  1 2 3
	    // button: 0 1 2 (standard)
	    var button = event.button;
	    if ('which' in event) {
	      return button;
	    }
	    // IE<9
	    // which:  undefined
	    // button: 0 0 0
	    // button: 1 4 2 (onmouseup)
	    return button === 2 ? 2 : button === 4 ? 1 : 0;
	  },
	  buttons: null,
	  relatedTarget: function (event) {
	    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
	  },
	  // "Proprietary" Interface.
	  pageX: function (event) {
	    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
	  },
	  pageY: function (event) {
	    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
	
	module.exports = SyntheticMouseEvent;

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticUIEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(77);
	
	var getEventTarget = __webpack_require__(81);
	
	/**
	 * @interface UIEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var UIEventInterface = {
	  view: function (event) {
	    if (event.view) {
	      return event.view;
	    }
	
	    var target = getEventTarget(event);
	    if (target != null && target.window === target) {
	      // target is a window object
	      return target;
	    }
	
	    var doc = target.ownerDocument;
	    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	    if (doc) {
	      return doc.defaultView || doc.parentWindow;
	    } else {
	      return window;
	    }
	  },
	  detail: function (event) {
	    return event.detail || 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
	
	module.exports = SyntheticUIEvent;

/***/ },
/* 88 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventModifierState
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Translation from modifier key to the associated property in the event.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
	 */
	
	var modifierKeyToProp = {
	  'Alt': 'altKey',
	  'Control': 'ctrlKey',
	  'Meta': 'metaKey',
	  'Shift': 'shiftKey'
	};
	
	// IE8 does not implement getModifierState so we simply map it to the only
	// modifier keys exposed by the event itself, does not support Lock-keys.
	// Currently, all major browsers except Chrome seems to support Lock-keys.
	function modifierStateGetter(keyArg) {
	  var syntheticEvent = this;
	  var nativeEvent = syntheticEvent.nativeEvent;
	  if (nativeEvent.getModifierState) {
	    return nativeEvent.getModifierState(keyArg);
	  }
	  var keyProp = modifierKeyToProp[keyArg];
	  return keyProp ? !!nativeEvent[keyProp] : false;
	}
	
	function getEventModifierState(nativeEvent) {
	  return modifierStateGetter;
	}
	
	module.exports = getEventModifierState;

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule HTMLDOMPropertyConfig
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(23);
	var ExecutionEnvironment = __webpack_require__(9);
	
	var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
	var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
	var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
	var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
	var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
	var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
	var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
	
	var hasSVG;
	if (ExecutionEnvironment.canUseDOM) {
	  var implementation = document.implementation;
	  hasSVG = implementation && implementation.hasFeature && implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1');
	}
	
	var HTMLDOMPropertyConfig = {
	  isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/),
	  Properties: {
	    /**
	     * Standard Properties
	     */
	    accept: null,
	    acceptCharset: null,
	    accessKey: null,
	    action: null,
	    allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    allowTransparency: MUST_USE_ATTRIBUTE,
	    alt: null,
	    async: HAS_BOOLEAN_VALUE,
	    autoComplete: null,
	    // autoFocus is polyfilled/normalized by AutoFocusUtils
	    // autoFocus: HAS_BOOLEAN_VALUE,
	    autoPlay: HAS_BOOLEAN_VALUE,
	    capture: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    cellPadding: null,
	    cellSpacing: null,
	    charSet: MUST_USE_ATTRIBUTE,
	    challenge: MUST_USE_ATTRIBUTE,
	    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    classID: MUST_USE_ATTRIBUTE,
	    // To set className on SVG elements, it's necessary to use .setAttribute;
	    // this works on HTML elements too in all browsers except IE8. Conveniently,
	    // IE8 doesn't support SVG and so we can simply use the attribute in
	    // browsers that support SVG and the property in browsers that don't,
	    // regardless of whether the element is HTML or SVG.
	    className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
	    cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    colSpan: null,
	    content: null,
	    contentEditable: null,
	    contextMenu: MUST_USE_ATTRIBUTE,
	    controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    coords: null,
	    crossOrigin: null,
	    data: null, // For `<object />` acts as `src`.
	    dateTime: MUST_USE_ATTRIBUTE,
	    'default': HAS_BOOLEAN_VALUE,
	    defer: HAS_BOOLEAN_VALUE,
	    dir: null,
	    disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    download: HAS_OVERLOADED_BOOLEAN_VALUE,
	    draggable: null,
	    encType: null,
	    form: MUST_USE_ATTRIBUTE,
	    formAction: MUST_USE_ATTRIBUTE,
	    formEncType: MUST_USE_ATTRIBUTE,
	    formMethod: MUST_USE_ATTRIBUTE,
	    formNoValidate: HAS_BOOLEAN_VALUE,
	    formTarget: MUST_USE_ATTRIBUTE,
	    frameBorder: MUST_USE_ATTRIBUTE,
	    headers: null,
	    height: MUST_USE_ATTRIBUTE,
	    hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    high: null,
	    href: null,
	    hrefLang: null,
	    htmlFor: null,
	    httpEquiv: null,
	    icon: null,
	    id: MUST_USE_PROPERTY,
	    inputMode: MUST_USE_ATTRIBUTE,
	    integrity: null,
	    is: MUST_USE_ATTRIBUTE,
	    keyParams: MUST_USE_ATTRIBUTE,
	    keyType: MUST_USE_ATTRIBUTE,
	    kind: null,
	    label: null,
	    lang: null,
	    list: MUST_USE_ATTRIBUTE,
	    loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    low: null,
	    manifest: MUST_USE_ATTRIBUTE,
	    marginHeight: null,
	    marginWidth: null,
	    max: null,
	    maxLength: MUST_USE_ATTRIBUTE,
	    media: MUST_USE_ATTRIBUTE,
	    mediaGroup: null,
	    method: null,
	    min: null,
	    minLength: MUST_USE_ATTRIBUTE,
	    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    name: null,
	    nonce: MUST_USE_ATTRIBUTE,
	    noValidate: HAS_BOOLEAN_VALUE,
	    open: HAS_BOOLEAN_VALUE,
	    optimum: null,
	    pattern: null,
	    placeholder: null,
	    poster: null,
	    preload: null,
	    radioGroup: null,
	    readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    rel: null,
	    required: HAS_BOOLEAN_VALUE,
	    reversed: HAS_BOOLEAN_VALUE,
	    role: MUST_USE_ATTRIBUTE,
	    rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    rowSpan: null,
	    sandbox: null,
	    scope: null,
	    scoped: HAS_BOOLEAN_VALUE,
	    scrolling: null,
	    seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    shape: null,
	    size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    sizes: MUST_USE_ATTRIBUTE,
	    span: HAS_POSITIVE_NUMERIC_VALUE,
	    spellCheck: null,
	    src: null,
	    srcDoc: MUST_USE_PROPERTY,
	    srcLang: null,
	    srcSet: MUST_USE_ATTRIBUTE,
	    start: HAS_NUMERIC_VALUE,
	    step: null,
	    style: null,
	    summary: null,
	    tabIndex: null,
	    target: null,
	    title: null,
	    type: null,
	    useMap: null,
	    value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
	    width: MUST_USE_ATTRIBUTE,
	    wmode: MUST_USE_ATTRIBUTE,
	    wrap: null,
	
	    /**
	     * RDFa Properties
	     */
	    about: MUST_USE_ATTRIBUTE,
	    datatype: MUST_USE_ATTRIBUTE,
	    inlist: MUST_USE_ATTRIBUTE,
	    prefix: MUST_USE_ATTRIBUTE,
	    // property is also supported for OpenGraph in meta tags.
	    property: MUST_USE_ATTRIBUTE,
	    resource: MUST_USE_ATTRIBUTE,
	    'typeof': MUST_USE_ATTRIBUTE,
	    vocab: MUST_USE_ATTRIBUTE,
	
	    /**
	     * Non-standard Properties
	     */
	    // autoCapitalize and autoCorrect are supported in Mobile Safari for
	    // keyboard hints.
	    autoCapitalize: MUST_USE_ATTRIBUTE,
	    autoCorrect: MUST_USE_ATTRIBUTE,
	    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
	    autoSave: null,
	    // color is for Safari mask-icon link
	    color: null,
	    // itemProp, itemScope, itemType are for
	    // Microdata support. See http://schema.org/docs/gs.html
	    itemProp: MUST_USE_ATTRIBUTE,
	    itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    itemType: MUST_USE_ATTRIBUTE,
	    // itemID and itemRef are for Microdata support as well but
	    // only specified in the the WHATWG spec document. See
	    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
	    itemID: MUST_USE_ATTRIBUTE,
	    itemRef: MUST_USE_ATTRIBUTE,
	    // results show looking glass icon and recent searches on input
	    // search fields in WebKit/Blink
	    results: null,
	    // IE-only attribute that specifies security restrictions on an iframe
	    // as an alternative to the sandbox attribute on IE<10
	    security: MUST_USE_ATTRIBUTE,
	    // IE-only attribute that controls focus behavior
	    unselectable: MUST_USE_ATTRIBUTE
	  },
	  DOMAttributeNames: {
	    acceptCharset: 'accept-charset',
	    className: 'class',
	    htmlFor: 'for',
	    httpEquiv: 'http-equiv'
	  },
	  DOMPropertyNames: {
	    autoComplete: 'autocomplete',
	    autoFocus: 'autofocus',
	    autoPlay: 'autoplay',
	    autoSave: 'autosave',
	    // `encoding` is equivalent to `enctype`, IE8 lacks an `enctype` setter.
	    // http://www.w3.org/TR/html5/forms.html#dom-fs-encoding
	    encType: 'encoding',
	    hrefLang: 'hreflang',
	    radioGroup: 'radiogroup',
	    spellCheck: 'spellcheck',
	    srcDoc: 'srcdoc',
	    srcSet: 'srcset'
	  }
	};
	
	module.exports = HTMLDOMPropertyConfig;

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserComponentMixin
	 */
	
	'use strict';
	
	var ReactInstanceMap = __webpack_require__(47);
	
	var findDOMNode = __webpack_require__(91);
	var warning = __webpack_require__(25);
	
	var didWarnKey = '_getDOMNodeDidWarn';
	
	var ReactBrowserComponentMixin = {
	  /**
	   * Returns the DOM node rendered by this component.
	   *
	   * @return {DOMElement} The root node of this component.
	   * @final
	   * @protected
	   */
	  getDOMNode: function () {
	     false ? warning(this.constructor[didWarnKey], '%s.getDOMNode(...) is deprecated. Please use ' + 'ReactDOM.findDOMNode(instance) instead.', ReactInstanceMap.get(this).getName() || this.tagName || 'Unknown') : undefined;
	    this.constructor[didWarnKey] = true;
	    return findDOMNode(this);
	  }
	};
	
	module.exports = ReactBrowserComponentMixin;

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule findDOMNode
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(5);
	var ReactInstanceMap = __webpack_require__(47);
	var ReactMount = __webpack_require__(28);
	
	var invariant = __webpack_require__(13);
	var warning = __webpack_require__(25);
	
	/**
	 * Returns the DOM node rendered by this element.
	 *
	 * @param {ReactComponent|DOMElement} componentOrElement
	 * @return {?DOMElement} The root node of this element.
	 */
	function findDOMNode(componentOrElement) {
	  if (false) {
	    var owner = ReactCurrentOwner.current;
	    if (owner !== null) {
	      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing getDOMNode or findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
	      owner._warnedAboutRefsInRender = true;
	    }
	  }
	  if (componentOrElement == null) {
	    return null;
	  }
	  if (componentOrElement.nodeType === 1) {
	    return componentOrElement;
	  }
	  if (ReactInstanceMap.has(componentOrElement)) {
	    return ReactMount.getNodeFromInstance(componentOrElement);
	  }
	  !(componentOrElement.render == null || typeof componentOrElement.render !== 'function') ?  false ? invariant(false, 'findDOMNode was called on an unmounted component.') : invariant(false) : undefined;
	   true ?  false ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : invariant(false) : undefined;
	}
	
	module.exports = findDOMNode;

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultBatchingStrategy
	 */
	
	'use strict';
	
	var ReactUpdates = __webpack_require__(54);
	var Transaction = __webpack_require__(57);
	
	var assign = __webpack_require__(39);
	var emptyFunction = __webpack_require__(15);
	
	var RESET_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: function () {
	    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
	  }
	};
	
	var FLUSH_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
	};
	
	var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
	
	function ReactDefaultBatchingStrategyTransaction() {
	  this.reinitializeTransaction();
	}
	
	assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  }
	});
	
	var transaction = new ReactDefaultBatchingStrategyTransaction();
	
	var ReactDefaultBatchingStrategy = {
	  isBatchingUpdates: false,
	
	  /**
	   * Call the provided function in a context within which calls to `setState`
	   * and friends are batched such that components aren't updated unnecessarily.
	   */
	  batchedUpdates: function (callback, a, b, c, d, e) {
	    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
	
	    ReactDefaultBatchingStrategy.isBatchingUpdates = true;
	
	    // The code is written this way to avoid extra allocations
	    if (alreadyBatchingUpdates) {
	      callback(a, b, c, d, e);
	    } else {
	      transaction.perform(callback, null, a, b, c, d, e);
	    }
	  }
	};
	
	module.exports = ReactDefaultBatchingStrategy;

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponent
	 * @typechecks static-only
	 */
	
	/* global hasOwnProperty:true */
	
	'use strict';
	
	var AutoFocusUtils = __webpack_require__(94);
	var CSSPropertyOperations = __webpack_require__(96);
	var DOMProperty = __webpack_require__(23);
	var DOMPropertyOperations = __webpack_require__(22);
	var EventConstants = __webpack_require__(30);
	var ReactBrowserEventEmitter = __webpack_require__(29);
	var ReactComponentBrowserEnvironment = __webpack_require__(26);
	var ReactDOMButton = __webpack_require__(104);
	var ReactDOMInput = __webpack_require__(105);
	var ReactDOMOption = __webpack_require__(109);
	var ReactDOMSelect = __webpack_require__(112);
	var ReactDOMTextarea = __webpack_require__(113);
	var ReactMount = __webpack_require__(28);
	var ReactMultiChild = __webpack_require__(114);
	var ReactPerf = __webpack_require__(18);
	var ReactUpdateQueue = __webpack_require__(53);
	
	var assign = __webpack_require__(39);
	var canDefineProperty = __webpack_require__(43);
	var escapeTextContentForBrowser = __webpack_require__(21);
	var invariant = __webpack_require__(13);
	var isEventSupported = __webpack_require__(40);
	var keyOf = __webpack_require__(79);
	var setInnerHTML = __webpack_require__(19);
	var setTextContent = __webpack_require__(20);
	var shallowEqual = __webpack_require__(117);
	var validateDOMNesting = __webpack_require__(70);
	var warning = __webpack_require__(25);
	
	var deleteListener = ReactBrowserEventEmitter.deleteListener;
	var listenTo = ReactBrowserEventEmitter.listenTo;
	var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;
	
	// For quickly matching children type, to test if can be treated as content.
	var CONTENT_TYPES = { 'string': true, 'number': true };
	
	var CHILDREN = keyOf({ children: null });
	var STYLE = keyOf({ style: null });
	var HTML = keyOf({ __html: null });
	
	var ELEMENT_NODE_TYPE = 1;
	
	function getDeclarationErrorAddendum(internalInstance) {
	  if (internalInstance) {
	    var owner = internalInstance._currentElement._owner || null;
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' This DOM node was rendered by `' + name + '`.';
	      }
	    }
	  }
	  return '';
	}
	
	var legacyPropsDescriptor;
	if (false) {
	  legacyPropsDescriptor = {
	    props: {
	      enumerable: false,
	      get: function () {
	        var component = this._reactInternalComponent;
	        process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .props of a DOM node; instead, ' + 'recreate the props as `render` did originally or read the DOM ' + 'properties/attributes directly from this node (e.g., ' + 'this.refs.box.className).%s', getDeclarationErrorAddendum(component)) : undefined;
	        return component._currentElement.props;
	      }
	    }
	  };
	}
	
	function legacyGetDOMNode() {
	  if (false) {
	    var component = this._reactInternalComponent;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .getDOMNode() of a DOM node; ' + 'instead, use the node directly.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  return this;
	}
	
	function legacyIsMounted() {
	  var component = this._reactInternalComponent;
	  if (false) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .isMounted() of a DOM node.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  return !!component;
	}
	
	function legacySetStateEtc() {
	  if (false) {
	    var component = this._reactInternalComponent;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setState(), .replaceState(), or ' + '.forceUpdate() of a DOM node. This is a no-op.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	}
	
	function legacySetProps(partialProps, callback) {
	  var component = this._reactInternalComponent;
	  if (false) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  if (!component) {
	    return;
	  }
	  ReactUpdateQueue.enqueueSetPropsInternal(component, partialProps);
	  if (callback) {
	    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
	  }
	}
	
	function legacyReplaceProps(partialProps, callback) {
	  var component = this._reactInternalComponent;
	  if (false) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .replaceProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  if (!component) {
	    return;
	  }
	  ReactUpdateQueue.enqueueReplacePropsInternal(component, partialProps);
	  if (callback) {
	    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
	  }
	}
	
	function friendlyStringify(obj) {
	  if (typeof obj === 'object') {
	    if (Array.isArray(obj)) {
	      return '[' + obj.map(friendlyStringify).join(', ') + ']';
	    } else {
	      var pairs = [];
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
	          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
	        }
	      }
	      return '{' + pairs.join(', ') + '}';
	    }
	  } else if (typeof obj === 'string') {
	    return JSON.stringify(obj);
	  } else if (typeof obj === 'function') {
	    return '[function object]';
	  }
	  // Differs from JSON.stringify in that undefined becauses undefined and that
	  // inf and nan don't become null
	  return String(obj);
	}
	
	var styleMutationWarning = {};
	
	function checkAndWarnForMutatedStyle(style1, style2, component) {
	  if (style1 == null || style2 == null) {
	    return;
	  }
	  if (shallowEqual(style1, style2)) {
	    return;
	  }
	
	  var componentName = component._tag;
	  var owner = component._currentElement._owner;
	  var ownerName;
	  if (owner) {
	    ownerName = owner.getName();
	  }
	
	  var hash = ownerName + '|' + componentName;
	
	  if (styleMutationWarning.hasOwnProperty(hash)) {
	    return;
	  }
	
	  styleMutationWarning[hash] = true;
	
	   false ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : undefined;
	}
	
	/**
	 * @param {object} component
	 * @param {?object} props
	 */
	function assertValidProps(component, props) {
	  if (!props) {
	    return;
	  }
	  // Note the use of `==` which checks for null or undefined.
	  if (false) {
	    if (voidElementTags[component._tag]) {
	      process.env.NODE_ENV !== 'production' ? warning(props.children == null && props.dangerouslySetInnerHTML == null, '%s is a void element tag and must not have `children` or ' + 'use `props.dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : undefined;
	    }
	  }
	  if (props.dangerouslySetInnerHTML != null) {
	    !(props.children == null) ?  false ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : invariant(false) : undefined;
	    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ?  false ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' + 'Please visit https://fb.me/react-invariant-dangerously-set-inner-html ' + 'for more information.') : invariant(false) : undefined;
	  }
	  if (false) {
	    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : undefined;
	    process.env.NODE_ENV !== 'production' ? warning(!props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : undefined;
	  }
	  !(props.style == null || typeof props.style === 'object') ?  false ? invariant(false, 'The `style` prop expects a mapping from style properties to values, ' + 'not a string. For example, style={{marginRight: spacing + \'em\'}} when ' + 'using JSX.%s', getDeclarationErrorAddendum(component)) : invariant(false) : undefined;
	}
	
	function enqueuePutListener(id, registrationName, listener, transaction) {
	  if (false) {
	    // IE8 has no API for event capturing and the `onScroll` event doesn't
	    // bubble.
	    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : undefined;
	  }
	  var container = ReactMount.findReactContainerForID(id);
	  if (container) {
	    var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
	    listenTo(registrationName, doc);
	  }
	  transaction.getReactMountReady().enqueue(putListener, {
	    id: id,
	    registrationName: registrationName,
	    listener: listener
	  });
	}
	
	function putListener() {
	  var listenerToPut = this;
	  ReactBrowserEventEmitter.putListener(listenerToPut.id, listenerToPut.registrationName, listenerToPut.listener);
	}
	
	// There are so many media events, it makes sense to just
	// maintain a list rather than create a `trapBubbledEvent` for each
	var mediaEvents = {
	  topAbort: 'abort',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTimeUpdate: 'timeupdate',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting'
	};
	
	function trapBubbledEventsLocal() {
	  var inst = this;
	  // If a component renders to null or if another component fatals and causes
	  // the state of the tree to be corrupted, `node` here can be null.
	  !inst._rootNodeID ?  false ? invariant(false, 'Must be mounted to trap events') : invariant(false) : undefined;
	  var node = ReactMount.getNode(inst._rootNodeID);
	  !node ?  false ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : invariant(false) : undefined;
	
	  switch (inst._tag) {
	    case 'iframe':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'video':
	    case 'audio':
	
	      inst._wrapperState.listeners = [];
	      // create listener for each media event
	      for (var event in mediaEvents) {
	        if (mediaEvents.hasOwnProperty(event)) {
	          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
	        }
	      }
	
	      break;
	    case 'img':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'form':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];
	      break;
	  }
	}
	
	function mountReadyInputWrapper() {
	  ReactDOMInput.mountReadyWrapper(this);
	}
	
	function postUpdateSelectWrapper() {
	  ReactDOMSelect.postUpdateWrapper(this);
	}
	
	// For HTML, certain tags should omit their close tag. We keep a whitelist for
	// those special cased tags.
	
	var omittedCloseTags = {
	  'area': true,
	  'base': true,
	  'br': true,
	  'col': true,
	  'embed': true,
	  'hr': true,
	  'img': true,
	  'input': true,
	  'keygen': true,
	  'link': true,
	  'meta': true,
	  'param': true,
	  'source': true,
	  'track': true,
	  'wbr': true
	};
	
	// NOTE: menuitem's close tag should be omitted, but that causes problems.
	var newlineEatingTags = {
	  'listing': true,
	  'pre': true,
	  'textarea': true
	};
	
	// For HTML, certain tags cannot have children. This has the same purpose as
	// `omittedCloseTags` except that `menuitem` should still have its closing tag.
	
	var voidElementTags = assign({
	  'menuitem': true
	}, omittedCloseTags);
	
	// We accept any tag to be rendered but since this gets injected into arbitrary
	// HTML, we want to make sure that it's a safe tag.
	// http://www.w3.org/TR/REC-xml/#NT-Name
	
	var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
	var validatedTagCache = {};
	var hasOwnProperty = ({}).hasOwnProperty;
	
	function validateDangerousTag(tag) {
	  if (!hasOwnProperty.call(validatedTagCache, tag)) {
	    !VALID_TAG_REGEX.test(tag) ?  false ? invariant(false, 'Invalid tag: %s', tag) : invariant(false) : undefined;
	    validatedTagCache[tag] = true;
	  }
	}
	
	function processChildContextDev(context, inst) {
	  // Pass down our tag name to child components for validation purposes
	  context = assign({}, context);
	  var info = context[validateDOMNesting.ancestorInfoContextKey];
	  context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(info, inst._tag, inst);
	  return context;
	}
	
	function isCustomComponent(tagName, props) {
	  return tagName.indexOf('-') >= 0 || props.is != null;
	}
	
	/**
	 * Creates a new React class that is idempotent and capable of containing other
	 * React components. It accepts event listeners and DOM properties that are
	 * valid according to `DOMProperty`.
	 *
	 *  - Event listeners: `onClick`, `onMouseDown`, etc.
	 *  - DOM properties: `className`, `name`, `title`, etc.
	 *
	 * The `style` property functions differently from the DOM API. It accepts an
	 * object mapping of style properties to values.
	 *
	 * @constructor ReactDOMComponent
	 * @extends ReactMultiChild
	 */
	function ReactDOMComponent(tag) {
	  validateDangerousTag(tag);
	  this._tag = tag.toLowerCase();
	  this._renderedChildren = null;
	  this._previousStyle = null;
	  this._previousStyleCopy = null;
	  this._rootNodeID = null;
	  this._wrapperState = null;
	  this._topLevelWrapper = null;
	  this._nodeWithLegacyProperties = null;
	  if (false) {
	    this._unprocessedContextDev = null;
	    this._processedContextDev = null;
	  }
	}
	
	ReactDOMComponent.displayName = 'ReactDOMComponent';
	
	ReactDOMComponent.Mixin = {
	
	  construct: function (element) {
	    this._currentElement = element;
	  },
	
	  /**
	   * Generates root tag markup then recurses. This method has side effects and
	   * is not idempotent.
	   *
	   * @internal
	   * @param {string} rootID The root DOM ID for this node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   * @return {string} The computed markup.
	   */
	  mountComponent: function (rootID, transaction, context) {
	    this._rootNodeID = rootID;
	
	    var props = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'iframe':
	      case 'img':
	      case 'form':
	      case 'video':
	      case 'audio':
	        this._wrapperState = {
	          listeners: null
	        };
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'button':
	        props = ReactDOMButton.getNativeProps(this, props, context);
	        break;
	      case 'input':
	        ReactDOMInput.mountWrapper(this, props, context);
	        props = ReactDOMInput.getNativeProps(this, props, context);
	        break;
	      case 'option':
	        ReactDOMOption.mountWrapper(this, props, context);
	        props = ReactDOMOption.getNativeProps(this, props, context);
	        break;
	      case 'select':
	        ReactDOMSelect.mountWrapper(this, props, context);
	        props = ReactDOMSelect.getNativeProps(this, props, context);
	        context = ReactDOMSelect.processChildContext(this, props, context);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.mountWrapper(this, props, context);
	        props = ReactDOMTextarea.getNativeProps(this, props, context);
	        break;
	    }
	
	    assertValidProps(this, props);
	    if (false) {
	      if (context[validateDOMNesting.ancestorInfoContextKey]) {
	        validateDOMNesting(this._tag, this, context[validateDOMNesting.ancestorInfoContextKey]);
	      }
	    }
	
	    if (false) {
	      this._unprocessedContextDev = context;
	      this._processedContextDev = processChildContextDev(context, this);
	      context = this._processedContextDev;
	    }
	
	    var mountImage;
	    if (transaction.useCreateElement) {
	      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
	      var el = ownerDocument.createElement(this._currentElement.type);
	      DOMPropertyOperations.setAttributeForID(el, this._rootNodeID);
	      // Populate node cache
	      ReactMount.getID(el);
	      this._updateDOMProperties({}, props, transaction, el);
	      this._createInitialChildren(transaction, props, context, el);
	      mountImage = el;
	    } else {
	      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
	      var tagContent = this._createContentMarkup(transaction, props, context);
	      if (!tagContent && omittedCloseTags[this._tag]) {
	        mountImage = tagOpen + '/>';
	      } else {
	        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
	      }
	    }
	
	    switch (this._tag) {
	      case 'input':
	        transaction.getReactMountReady().enqueue(mountReadyInputWrapper, this);
	      // falls through
	      case 'button':
	      case 'select':
	      case 'textarea':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	    }
	
	    return mountImage;
	  },
	
	  /**
	   * Creates markup for the open tag and all attributes.
	   *
	   * This method has side effects because events get registered.
	   *
	   * Iterating over object properties is faster than iterating over arrays.
	   * @see http://jsperf.com/obj-vs-arr-iteration
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @return {string} Markup of opening tag.
	   */
	  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
	    var ret = '<' + this._currentElement.type;
	
	    for (var propKey in props) {
	      if (!props.hasOwnProperty(propKey)) {
	        continue;
	      }
	      var propValue = props[propKey];
	      if (propValue == null) {
	        continue;
	      }
	      if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (propValue) {
	          enqueuePutListener(this._rootNodeID, propKey, propValue, transaction);
	        }
	      } else {
	        if (propKey === STYLE) {
	          if (propValue) {
	            if (false) {
	              // See `_updateDOMProperties`. style block
	              this._previousStyle = propValue;
	            }
	            propValue = this._previousStyleCopy = assign({}, props.style);
	          }
	          propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
	        }
	        var markup = null;
	        if (this._tag != null && isCustomComponent(this._tag, props)) {
	          if (propKey !== CHILDREN) {
	            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
	          }
	        } else {
	          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
	        }
	        if (markup) {
	          ret += ' ' + markup;
	        }
	      }
	    }
	
	    // For static pages, no need to put React ID and checksum. Saves lots of
	    // bytes.
	    if (transaction.renderToStaticMarkup) {
	      return ret;
	    }
	
	    var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
	    return ret + ' ' + markupForID;
	  },
	
	  /**
	   * Creates markup for the content between the tags.
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @param {object} context
	   * @return {string} Content markup.
	   */
	  _createContentMarkup: function (transaction, props, context) {
	    var ret = '';
	
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        ret = innerHTML.__html;
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        ret = escapeTextContentForBrowser(contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        ret = mountImages.join('');
	      }
	    }
	    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
	      // text/html ignores the first character in these tags if it's a newline
	      // Prefer to break application/xml over text/html (for now) by adding
	      // a newline specifically to get eaten by the parser. (Alternately for
	      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
	      // \r is normalized out by HTMLTextAreaElement#value.)
	      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
	      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
	      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
	      // See: Parsing of "textarea" "listing" and "pre" elements
	      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
	      return '\n' + ret;
	    } else {
	      return ret;
	    }
	  },
	
	  _createInitialChildren: function (transaction, props, context, el) {
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        setInnerHTML(el, innerHTML.__html);
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        setTextContent(el, contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        for (var i = 0; i < mountImages.length; i++) {
	          el.appendChild(mountImages[i]);
	        }
	      }
	    }
	  },
	
	  /**
	   * Receives a next element and updates the component.
	   *
	   * @internal
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   */
	  receiveComponent: function (nextElement, transaction, context) {
	    var prevElement = this._currentElement;
	    this._currentElement = nextElement;
	    this.updateComponent(transaction, prevElement, nextElement, context);
	  },
	
	  /**
	   * Updates a native DOM component after it has already been allocated and
	   * attached to the DOM. Reconciles the root DOM node, then recurses.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevElement
	   * @param {ReactElement} nextElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevElement, nextElement, context) {
	    var lastProps = prevElement.props;
	    var nextProps = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'button':
	        lastProps = ReactDOMButton.getNativeProps(this, lastProps);
	        nextProps = ReactDOMButton.getNativeProps(this, nextProps);
	        break;
	      case 'input':
	        ReactDOMInput.updateWrapper(this);
	        lastProps = ReactDOMInput.getNativeProps(this, lastProps);
	        nextProps = ReactDOMInput.getNativeProps(this, nextProps);
	        break;
	      case 'option':
	        lastProps = ReactDOMOption.getNativeProps(this, lastProps);
	        nextProps = ReactDOMOption.getNativeProps(this, nextProps);
	        break;
	      case 'select':
	        lastProps = ReactDOMSelect.getNativeProps(this, lastProps);
	        nextProps = ReactDOMSelect.getNativeProps(this, nextProps);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.updateWrapper(this);
	        lastProps = ReactDOMTextarea.getNativeProps(this, lastProps);
	        nextProps = ReactDOMTextarea.getNativeProps(this, nextProps);
	        break;
	    }
	
	    if (false) {
	      // If the context is reference-equal to the old one, pass down the same
	      // processed object so the update bailout in ReactReconciler behaves
	      // correctly (and identically in dev and prod). See #5005.
	      if (this._unprocessedContextDev !== context) {
	        this._unprocessedContextDev = context;
	        this._processedContextDev = processChildContextDev(context, this);
	      }
	      context = this._processedContextDev;
	    }
	
	    assertValidProps(this, nextProps);
	    this._updateDOMProperties(lastProps, nextProps, transaction, null);
	    this._updateDOMChildren(lastProps, nextProps, transaction, context);
	
	    if (!canDefineProperty && this._nodeWithLegacyProperties) {
	      this._nodeWithLegacyProperties.props = nextProps;
	    }
	
	    if (this._tag === 'select') {
	      // <select> value update needs to occur after <option> children
	      // reconciliation
	      transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
	    }
	  },
	
	  /**
	   * Reconciles the properties by detecting differences in property values and
	   * updating the DOM as necessary. This function is probably the single most
	   * critical path for performance optimization.
	   *
	   * TODO: Benchmark whether checking for changed values in memory actually
	   *       improves performance (especially statically positioned elements).
	   * TODO: Benchmark the effects of putting this at the top since 99% of props
	   *       do not change for a given reconciliation.
	   * TODO: Benchmark areas that can be improved with caching.
	   *
	   * @private
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?DOMElement} node
	   */
	  _updateDOMProperties: function (lastProps, nextProps, transaction, node) {
	    var propKey;
	    var styleName;
	    var styleUpdates;
	    for (propKey in lastProps) {
	      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        var lastStyle = this._previousStyleCopy;
	        for (styleName in lastStyle) {
	          if (lastStyle.hasOwnProperty(styleName)) {
	            styleUpdates = styleUpdates || {};
	            styleUpdates[styleName] = '';
	          }
	        }
	        this._previousStyleCopy = null;
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (lastProps[propKey]) {
	          // Only call deleteListener if there was a listener previously or
	          // else willDeleteListener gets called when there wasn't actually a
	          // listener (e.g., onClick={null})
	          deleteListener(this._rootNodeID, propKey);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        DOMPropertyOperations.deleteValueForProperty(node, propKey);
	      }
	    }
	    for (propKey in nextProps) {
	      var nextProp = nextProps[propKey];
	      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps[propKey];
	      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        if (nextProp) {
	          if (false) {
	            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
	            this._previousStyle = nextProp;
	          }
	          nextProp = this._previousStyleCopy = assign({}, nextProp);
	        } else {
	          this._previousStyleCopy = null;
	        }
	        if (lastProp) {
	          // Unset styles on `lastProp` but not on `nextProp`.
	          for (styleName in lastProp) {
	            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = '';
	            }
	          }
	          // Update styles that changed since `lastProp`.
	          for (styleName in nextProp) {
	            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = nextProp[styleName];
	            }
	          }
	        } else {
	          // Relies on `updateStylesByID` not mutating `styleUpdates`.
	          styleUpdates = nextProp;
	        }
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (nextProp) {
	          enqueuePutListener(this._rootNodeID, propKey, nextProp, transaction);
	        } else if (lastProp) {
	          deleteListener(this._rootNodeID, propKey);
	        }
	      } else if (isCustomComponent(this._tag, nextProps)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        if (propKey === CHILDREN) {
	          nextProp = null;
	        }
	        DOMPropertyOperations.setValueForAttribute(node, propKey, nextProp);
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        // If we're updating to null or undefined, we should remove the property
	        // from the DOM node instead of inadvertantly setting to a string. This
	        // brings us in line with the same behavior we have on initial render.
	        if (nextProp != null) {
	          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
	        } else {
	          DOMPropertyOperations.deleteValueForProperty(node, propKey);
	        }
	      }
	    }
	    if (styleUpdates) {
	      if (!node) {
	        node = ReactMount.getNode(this._rootNodeID);
	      }
	      CSSPropertyOperations.setValueForStyles(node, styleUpdates);
	    }
	  },
	
	  /**
	   * Reconciles the children with the various properties that affect the
	   * children content.
	   *
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   */
	  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
	    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
	    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;
	
	    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
	    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
	
	    // Note the use of `!=` which checks for null or undefined.
	    var lastChildren = lastContent != null ? null : lastProps.children;
	    var nextChildren = nextContent != null ? null : nextProps.children;
	
	    // If we're switching from children to content/html or vice versa, remove
	    // the old content
	    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
	    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
	    if (lastChildren != null && nextChildren == null) {
	      this.updateChildren(null, transaction, context);
	    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
	      this.updateTextContent('');
	    }
	
	    if (nextContent != null) {
	      if (lastContent !== nextContent) {
	        this.updateTextContent('' + nextContent);
	      }
	    } else if (nextHtml != null) {
	      if (lastHtml !== nextHtml) {
	        this.updateMarkup('' + nextHtml);
	      }
	    } else if (nextChildren != null) {
	      this.updateChildren(nextChildren, transaction, context);
	    }
	  },
	
	  /**
	   * Destroys all event registrations for this instance. Does not remove from
	   * the DOM. That must be done by the parent.
	   *
	   * @internal
	   */
	  unmountComponent: function () {
	    switch (this._tag) {
	      case 'iframe':
	      case 'img':
	      case 'form':
	      case 'video':
	      case 'audio':
	        var listeners = this._wrapperState.listeners;
	        if (listeners) {
	          for (var i = 0; i < listeners.length; i++) {
	            listeners[i].remove();
	          }
	        }
	        break;
	      case 'input':
	        ReactDOMInput.unmountWrapper(this);
	        break;
	      case 'html':
	      case 'head':
	      case 'body':
	        /**
	         * Components like <html> <head> and <body> can't be removed or added
	         * easily in a cross-browser way, however it's valuable to be able to
	         * take advantage of React's reconciliation for styling and <title>
	         * management. So we just document it and throw in dangerous cases.
	         */
	         true ?  false ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is ' + 'impossible to unmount some top-level components (eg <html>, ' + '<head>, and <body>) reliably and efficiently. To fix this, have a ' + 'single top-level component that never unmounts render these ' + 'elements.', this._tag) : invariant(false) : undefined;
	        break;
	    }
	
	    this.unmountChildren();
	    ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
	    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
	    this._rootNodeID = null;
	    this._wrapperState = null;
	    if (this._nodeWithLegacyProperties) {
	      var node = this._nodeWithLegacyProperties;
	      node._reactInternalComponent = null;
	      this._nodeWithLegacyProperties = null;
	    }
	  },
	
	  getPublicInstance: function () {
	    if (!this._nodeWithLegacyProperties) {
	      var node = ReactMount.getNode(this._rootNodeID);
	
	      node._reactInternalComponent = this;
	      node.getDOMNode = legacyGetDOMNode;
	      node.isMounted = legacyIsMounted;
	      node.setState = legacySetStateEtc;
	      node.replaceState = legacySetStateEtc;
	      node.forceUpdate = legacySetStateEtc;
	      node.setProps = legacySetProps;
	      node.replaceProps = legacyReplaceProps;
	
	      if (false) {
	        if (canDefineProperty) {
	          Object.defineProperties(node, legacyPropsDescriptor);
	        } else {
	          // updateComponent will update this property on subsequent renders
	          node.props = this._currentElement.props;
	        }
	      } else {
	        // updateComponent will update this property on subsequent renders
	        node.props = this._currentElement.props;
	      }
	
	      this._nodeWithLegacyProperties = node;
	    }
	    return this._nodeWithLegacyProperties;
	  }
	
	};
	
	ReactPerf.measureMethods(ReactDOMComponent, 'ReactDOMComponent', {
	  mountComponent: 'mountComponent',
	  updateComponent: 'updateComponent'
	});
	
	assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
	
	module.exports = ReactDOMComponent;

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule AutoFocusUtils
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactMount = __webpack_require__(28);
	
	var findDOMNode = __webpack_require__(91);
	var focusNode = __webpack_require__(95);
	
	var Mixin = {
	  componentDidMount: function () {
	    if (this.props.autoFocus) {
	      focusNode(findDOMNode(this));
	    }
	  }
	};
	
	var AutoFocusUtils = {
	  Mixin: Mixin,
	
	  focusDOMComponent: function () {
	    focusNode(ReactMount.getNode(this._rootNodeID));
	  }
	};
	
	module.exports = AutoFocusUtils;

/***/ },
/* 95 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule focusNode
	 */
	
	'use strict';
	
	/**
	 * @param {DOMElement} node input/textarea to focus
	 */
	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch (e) {}
	}
	
	module.exports = focusNode;

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSPropertyOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(97);
	var ExecutionEnvironment = __webpack_require__(9);
	var ReactPerf = __webpack_require__(18);
	
	var camelizeStyleName = __webpack_require__(98);
	var dangerousStyleValue = __webpack_require__(100);
	var hyphenateStyleName = __webpack_require__(101);
	var memoizeStringOnly = __webpack_require__(103);
	var warning = __webpack_require__(25);
	
	var processStyleName = memoizeStringOnly(function (styleName) {
	  return hyphenateStyleName(styleName);
	});
	
	var hasShorthandPropertyBug = false;
	var styleFloatAccessor = 'cssFloat';
	if (ExecutionEnvironment.canUseDOM) {
	  var tempStyle = document.createElement('div').style;
	  try {
	    // IE8 throws "Invalid argument." if resetting shorthand style properties.
	    tempStyle.font = '';
	  } catch (e) {
	    hasShorthandPropertyBug = true;
	  }
	  // IE8 only supports accessing cssFloat (standard) as styleFloat
	  if (document.documentElement.style.cssFloat === undefined) {
	    styleFloatAccessor = 'styleFloat';
	  }
	}
	
	if (false) {
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
	
	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;
	
	  var warnedStyleNames = {};
	  var warnedStyleValues = {};
	
	  var warnHyphenatedStyleName = function (name) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?', name, camelizeStyleName(name)) : undefined;
	  };
	
	  var warnBadVendoredStyleName = function (name) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1)) : undefined;
	  };
	
	  var warnStyleValueWithSemicolon = function (name, value) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }
	
	    warnedStyleValues[value] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon. ' + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, '')) : undefined;
	  };
	
	  /**
	   * @param {string} name
	   * @param {*} value
	   */
	  var warnValidStyle = function (name, value) {
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value);
	    }
	  };
	}
	
	/**
	 * Operations for dealing with CSS properties.
	 */
	var CSSPropertyOperations = {
	
	  /**
	   * Serializes a mapping of style properties for use as inline styles:
	   *
	   *   > createMarkupForStyles({width: '200px', height: 0})
	   *   "width:200px;height:0;"
	   *
	   * Undefined values are ignored so that declarative programming is easier.
	   * The result should be HTML-escaped before insertion into the DOM.
	   *
	   * @param {object} styles
	   * @return {?string}
	   */
	  createMarkupForStyles: function (styles) {
	    var serialized = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var styleValue = styles[styleName];
	      if (false) {
	        warnValidStyle(styleName, styleValue);
	      }
	      if (styleValue != null) {
	        serialized += processStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue) + ';';
	      }
	    }
	    return serialized || null;
	  },
	
	  /**
	   * Sets the value for multiple styles on a node.  If a value is specified as
	   * '' (empty string), the corresponding style property will be unset.
	   *
	   * @param {DOMElement} node
	   * @param {object} styles
	   */
	  setValueForStyles: function (node, styles) {
	    var style = node.style;
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      if (false) {
	        warnValidStyle(styleName, styles[styleName]);
	      }
	      var styleValue = dangerousStyleValue(styleName, styles[styleName]);
	      if (styleName === 'float') {
	        styleName = styleFloatAccessor;
	      }
	      if (styleValue) {
	        style[styleName] = styleValue;
	      } else {
	        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
	        if (expansion) {
	          // Shorthand property that IE8 won't like unsetting, so unset each
	          // component to placate it
	          for (var individualStyleName in expansion) {
	            style[individualStyleName] = '';
	          }
	        } else {
	          style[styleName] = '';
	        }
	      }
	    }
	  }
	
	};
	
	ReactPerf.measureMethods(CSSPropertyOperations, 'CSSPropertyOperations', {
	  setValueForStyles: 'setValueForStyles'
	});
	
	module.exports = CSSPropertyOperations;

/***/ },
/* 97 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSProperty
	 */
	
	'use strict';
	
	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */
	var isUnitlessNumber = {
	  animationIterationCount: true,
	  boxFlex: true,
	  boxFlexGroup: true,
	  boxOrdinalGroup: true,
	  columnCount: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  flexOrder: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  tabSize: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,
	
	  // SVG-related properties
	  fillOpacity: true,
	  stopOpacity: true,
	  strokeDashoffset: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};
	
	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}
	
	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
	
	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	  prefixes.forEach(function (prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});
	
	/**
	 * Most style properties can be unset by doing .style[prop] = '' but IE8
	 * doesn't like doing that with shorthand properties so for the properties that
	 * IE8 breaks on, which are listed here, we instead unset each of the
	 * individual properties. See http://bugs.jquery.com/ticket/12385.
	 * The 4-value 'clock' properties like margin, padding, border-width seem to
	 * behave without any problems. Curiously, list-style works too without any
	 * special prodding.
	 */
	var shorthandPropertyExpansions = {
	  background: {
	    backgroundAttachment: true,
	    backgroundColor: true,
	    backgroundImage: true,
	    backgroundPositionX: true,
	    backgroundPositionY: true,
	    backgroundRepeat: true
	  },
	  backgroundPosition: {
	    backgroundPositionX: true,
	    backgroundPositionY: true
	  },
	  border: {
	    borderWidth: true,
	    borderStyle: true,
	    borderColor: true
	  },
	  borderBottom: {
	    borderBottomWidth: true,
	    borderBottomStyle: true,
	    borderBottomColor: true
	  },
	  borderLeft: {
	    borderLeftWidth: true,
	    borderLeftStyle: true,
	    borderLeftColor: true
	  },
	  borderRight: {
	    borderRightWidth: true,
	    borderRightStyle: true,
	    borderRightColor: true
	  },
	  borderTop: {
	    borderTopWidth: true,
	    borderTopStyle: true,
	    borderTopColor: true
	  },
	  font: {
	    fontStyle: true,
	    fontVariant: true,
	    fontWeight: true,
	    fontSize: true,
	    lineHeight: true,
	    fontFamily: true
	  },
	  outline: {
	    outlineWidth: true,
	    outlineStyle: true,
	    outlineColor: true
	  }
	};
	
	var CSSProperty = {
	  isUnitlessNumber: isUnitlessNumber,
	  shorthandPropertyExpansions: shorthandPropertyExpansions
	};
	
	module.exports = CSSProperty;

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule camelizeStyleName
	 * @typechecks
	 */
	
	'use strict';
	
	var camelize = __webpack_require__(99);
	
	var msPattern = /^-ms-/;
	
	/**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelizeStyleName(string) {
	  return camelize(string.replace(msPattern, 'ms-'));
	}
	
	module.exports = camelizeStyleName;

/***/ },
/* 99 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule camelize
	 * @typechecks
	 */
	
	"use strict";
	
	var _hyphenPattern = /-(.)/g;
	
	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function (_, character) {
	    return character.toUpperCase();
	  });
	}
	
	module.exports = camelize;

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule dangerousStyleValue
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(97);
	
	var isUnitlessNumber = CSSProperty.isUnitlessNumber;
	
	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901
	
	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }
	
	  var isNonNumeric = isNaN(value);
	  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	    return '' + value; // cast to string
	  }
	
	  if (typeof value === 'string') {
	    value = value.trim();
	  }
	  return value + 'px';
	}
	
	module.exports = dangerousStyleValue;

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule hyphenateStyleName
	 * @typechecks
	 */
	
	'use strict';
	
	var hyphenate = __webpack_require__(102);
	
	var msPattern = /^ms-/;
	
	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}
	
	module.exports = hyphenateStyleName;

/***/ },
/* 102 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule hyphenate
	 * @typechecks
	 */
	
	'use strict';
	
	var _uppercasePattern = /([A-Z])/g;
	
	/**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenate(string) {
	  return string.replace(_uppercasePattern, '-$1').toLowerCase();
	}
	
	module.exports = hyphenate;

/***/ },
/* 103 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule memoizeStringOnly
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Memoizes the return value of a function that accepts one string argument.
	 *
	 * @param {function} callback
	 * @return {function}
	 */
	function memoizeStringOnly(callback) {
	  var cache = {};
	  return function (string) {
	    if (!cache.hasOwnProperty(string)) {
	      cache[string] = callback.call(this, string);
	    }
	    return cache[string];
	  };
	}
	
	module.exports = memoizeStringOnly;

/***/ },
/* 104 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMButton
	 */
	
	'use strict';
	
	var mouseListenerNames = {
	  onClick: true,
	  onDoubleClick: true,
	  onMouseDown: true,
	  onMouseMove: true,
	  onMouseUp: true,
	
	  onClickCapture: true,
	  onDoubleClickCapture: true,
	  onMouseDownCapture: true,
	  onMouseMoveCapture: true,
	  onMouseUpCapture: true
	};
	
	/**
	 * Implements a <button> native component that does not receive mouse events
	 * when `disabled` is set.
	 */
	var ReactDOMButton = {
	  getNativeProps: function (inst, props, context) {
	    if (!props.disabled) {
	      return props;
	    }
	
	    // Copy the props, except the mouse listeners
	    var nativeProps = {};
	    for (var key in props) {
	      if (props.hasOwnProperty(key) && !mouseListenerNames[key]) {
	        nativeProps[key] = props[key];
	      }
	    }
	
	    return nativeProps;
	  }
	};
	
	module.exports = ReactDOMButton;

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMInput
	 */
	
	'use strict';
	
	var ReactDOMIDOperations = __webpack_require__(27);
	var LinkedValueUtils = __webpack_require__(106);
	var ReactMount = __webpack_require__(28);
	var ReactUpdates = __webpack_require__(54);
	
	var assign = __webpack_require__(39);
	var invariant = __webpack_require__(13);
	
	var instancesByReactID = {};
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMInput.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements an <input> native component that allows setting these optional
	 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
	 *
	 * If `checked` or `value` are not supplied (or null/undefined), user actions
	 * that affect the checked state or value will trigger updates to the element.
	 *
	 * If they are supplied (and not null/undefined), the rendered element will not
	 * trigger updates to the element. Instead, the props must change in order for
	 * the rendered element to be updated.
	 *
	 * The rendered element will be initialized as unchecked (or `defaultChecked`)
	 * with an empty value (or `defaultValue`).
	 *
	 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
	 */
	var ReactDOMInput = {
	  getNativeProps: function (inst, props, context) {
	    var value = LinkedValueUtils.getValue(props);
	    var checked = LinkedValueUtils.getChecked(props);
	
	    var nativeProps = assign({}, props, {
	      defaultChecked: undefined,
	      defaultValue: undefined,
	      value: value != null ? value : inst._wrapperState.initialValue,
	      checked: checked != null ? checked : inst._wrapperState.initialChecked,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return nativeProps;
	  },
	
	  mountWrapper: function (inst, props) {
	    if (false) {
	      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
	    }
	
	    var defaultValue = props.defaultValue;
	    inst._wrapperState = {
	      initialChecked: props.defaultChecked || false,
	      initialValue: defaultValue != null ? defaultValue : null,
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  mountReadyWrapper: function (inst) {
	    // Can't be in mountWrapper or else server rendering leaks.
	    instancesByReactID[inst._rootNodeID] = inst;
	  },
	
	  unmountWrapper: function (inst) {
	    delete instancesByReactID[inst._rootNodeID];
	  },
	
	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    // TODO: Shouldn't this be getChecked(props)?
	    var checked = props.checked;
	    if (checked != null) {
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'checked', checked || false);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  // Here we use asap to wait until all updates have propagated, which
	  // is important when using controlled components within layers:
	  // https://github.com/facebook/react/issues/1698
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	
	  var name = props.name;
	  if (props.type === 'radio' && name != null) {
	    var rootNode = ReactMount.getNode(this._rootNodeID);
	    var queryRoot = rootNode;
	
	    while (queryRoot.parentNode) {
	      queryRoot = queryRoot.parentNode;
	    }
	
	    // If `rootNode.form` was non-null, then we could try `form.elements`,
	    // but that sometimes behaves strangely in IE8. We could also try using
	    // `form.getElementsByName`, but that will only return direct children
	    // and won't include inputs that use the HTML5 `form=` attribute. Since
	    // the input might not even be in a form, let's just use the global
	    // `querySelectorAll` to ensure we don't miss anything.
	    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
	
	    for (var i = 0; i < group.length; i++) {
	      var otherNode = group[i];
	      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
	        continue;
	      }
	      // This will throw if radio buttons rendered by different copies of React
	      // and the same name are rendered into the same form (same as #1939).
	      // That's probably okay; we don't support it just as we don't support
	      // mixing React with non-React.
	      var otherID = ReactMount.getID(otherNode);
	      !otherID ?  false ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.') : invariant(false) : undefined;
	      var otherInstance = instancesByReactID[otherID];
	      !otherInstance ?  false ? invariant(false, 'ReactDOMInput: Unknown radio button ID %s.', otherID) : invariant(false) : undefined;
	      // If this is a controlled radio button group, forcing the input that
	      // was previously checked to update will cause it to be come re-checked
	      // as appropriate.
	      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
	    }
	  }
	
	  return returnValue;
	}
	
	module.exports = ReactDOMInput;

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule LinkedValueUtils
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactPropTypes = __webpack_require__(107);
	var ReactPropTypeLocations = __webpack_require__(65);
	
	var invariant = __webpack_require__(13);
	var warning = __webpack_require__(25);
	
	var hasReadOnlyValue = {
	  'button': true,
	  'checkbox': true,
	  'image': true,
	  'hidden': true,
	  'radio': true,
	  'reset': true,
	  'submit': true
	};
	
	function _assertSingleLink(inputProps) {
	  !(inputProps.checkedLink == null || inputProps.valueLink == null) ?  false ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use ' + 'checkedLink, you probably don\'t want to use valueLink and vice versa.') : invariant(false) : undefined;
	}
	function _assertValueLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.value == null && inputProps.onChange == null) ?  false ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want ' + 'to use value or onChange, you probably don\'t want to use valueLink.') : invariant(false) : undefined;
	}
	
	function _assertCheckedLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.checked == null && inputProps.onChange == null) ?  false ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. ' + 'If you want to use checked or onChange, you probably don\'t want to ' + 'use checkedLink') : invariant(false) : undefined;
	}
	
	var propTypes = {
	  value: function (props, propName, componentName) {
	    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  checked: function (props, propName, componentName) {
	    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  onChange: ReactPropTypes.func
	};
	
	var loggedTypeFailures = {};
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Provide a linked `value` attribute for controlled forms. You should not use
	 * this outside of the ReactDOM controlled form components.
	 */
	var LinkedValueUtils = {
	  checkPropTypes: function (tagName, props, owner) {
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop);
	      }
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum(owner);
	         false ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : undefined;
	      }
	    }
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current value of the input either from value prop or link.
	   */
	  getValue: function (inputProps) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.value;
	    }
	    return inputProps.value;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current checked status of the input either from checked prop
	   *             or link.
	   */
	  getChecked: function (inputProps) {
	    if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.value;
	    }
	    return inputProps.checked;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @param {SyntheticEvent} event change event to handle
	   */
	  executeOnChange: function (inputProps, event) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.requestChange(event.target.value);
	    } else if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.requestChange(event.target.checked);
	    } else if (inputProps.onChange) {
	      return inputProps.onChange.call(undefined, event);
	    }
	  }
	};
	
	module.exports = LinkedValueUtils;

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypes
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(42);
	var ReactPropTypeLocationNames = __webpack_require__(66);
	
	var emptyFunction = __webpack_require__(15);
	var getIteratorFn = __webpack_require__(108);
	
	/**
	 * Collection of methods that allow declaration and validation of props that are
	 * supplied to React components. Example usage:
	 *
	 *   var Props = require('ReactPropTypes');
	 *   var MyArticle = React.createClass({
	 *     propTypes: {
	 *       // An optional string prop named "description".
	 *       description: Props.string,
	 *
	 *       // A required enum prop named "category".
	 *       category: Props.oneOf(['News','Photos']).isRequired,
	 *
	 *       // A prop named "dialog" that requires an instance of Dialog.
	 *       dialog: Props.instanceOf(Dialog).isRequired
	 *     },
	 *     render: function() { ... }
	 *   });
	 *
	 * A more formal specification of how these methods are used:
	 *
	 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	 *   decl := ReactPropTypes.{type}(.isRequired)?
	 *
	 * Each and every declaration produces a function with the same signature. This
	 * allows the creation of custom validation functions. For example:
	 *
	 *  var MyLink = React.createClass({
	 *    propTypes: {
	 *      // An optional string or URI prop named "href".
	 *      href: function(props, propName, componentName) {
	 *        var propValue = props[propName];
	 *        if (propValue != null && typeof propValue !== 'string' &&
	 *            !(propValue instanceof URI)) {
	 *          return new Error(
	 *            'Expected a string or an URI for ' + propName + ' in ' +
	 *            componentName
	 *          );
	 *        }
	 *      }
	 *    },
	 *    render: function() {...}
	 *  });
	 *
	 * @internal
	 */
	
	var ANONYMOUS = '<<anonymous>>';
	
	var ReactPropTypes = {
	  array: createPrimitiveTypeChecker('array'),
	  bool: createPrimitiveTypeChecker('boolean'),
	  func: createPrimitiveTypeChecker('function'),
	  number: createPrimitiveTypeChecker('number'),
	  object: createPrimitiveTypeChecker('object'),
	  string: createPrimitiveTypeChecker('string'),
	
	  any: createAnyTypeChecker(),
	  arrayOf: createArrayOfTypeChecker,
	  element: createElementTypeChecker(),
	  instanceOf: createInstanceTypeChecker,
	  node: createNodeChecker(),
	  objectOf: createObjectOfTypeChecker,
	  oneOf: createEnumTypeChecker,
	  oneOfType: createUnionTypeChecker,
	  shape: createShapeTypeChecker
	};
	
	function createChainableTypeChecker(validate) {
	  function checkType(isRequired, props, propName, componentName, location, propFullName) {
	    componentName = componentName || ANONYMOUS;
	    propFullName = propFullName || propName;
	    if (props[propName] == null) {
	      var locationName = ReactPropTypeLocationNames[location];
	      if (isRequired) {
	        return new Error('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
	      }
	      return null;
	    } else {
	      return validate(props, propName, componentName, location, propFullName);
	    }
	  }
	
	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);
	
	  return chainedCheckType;
	}
	
	function createPrimitiveTypeChecker(expectedType) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== expectedType) {
	      var locationName = ReactPropTypeLocationNames[location];
	      // `propValue` being instance of, say, date/regexp, pass the 'object'
	      // check, but we can offer a more precise error message here rather than
	      // 'of type `object`'.
	      var preciseType = getPreciseType(propValue);
	
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createAnyTypeChecker() {
	  return createChainableTypeChecker(emptyFunction.thatReturns(null));
	}
	
	function createArrayOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!Array.isArray(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	    }
	    for (var i = 0; i < propValue.length; i++) {
	      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']');
	      if (error instanceof Error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createElementTypeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!ReactElement.isValidElement(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a single ReactElement.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createInstanceTypeChecker(expectedClass) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!(props[propName] instanceof expectedClass)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var expectedClassName = expectedClass.name || ANONYMOUS;
	      var actualClassName = getClassName(props[propName]);
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createEnumTypeChecker(expectedValues) {
	  if (!Array.isArray(expectedValues)) {
	    return createChainableTypeChecker(function () {
	      return new Error('Invalid argument supplied to oneOf, expected an instance of array.');
	    });
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    for (var i = 0; i < expectedValues.length; i++) {
	      if (propValue === expectedValues[i]) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    var valuesString = JSON.stringify(expectedValues);
	    return new Error('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createObjectOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	    }
	    for (var key in propValue) {
	      if (propValue.hasOwnProperty(key)) {
	        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createUnionTypeChecker(arrayOfTypeCheckers) {
	  if (!Array.isArray(arrayOfTypeCheckers)) {
	    return createChainableTypeChecker(function () {
	      return new Error('Invalid argument supplied to oneOfType, expected an instance of array.');
	    });
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (checker(props, propName, componentName, location, propFullName) == null) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createNodeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!isNode(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createShapeTypeChecker(shapeTypes) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	    }
	    for (var key in shapeTypes) {
	      var checker = shapeTypes[key];
	      if (!checker) {
	        continue;
	      }
	      var error = checker(propValue, key, componentName, location, propFullName + '.' + key);
	      if (error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function isNode(propValue) {
	  switch (typeof propValue) {
	    case 'number':
	    case 'string':
	    case 'undefined':
	      return true;
	    case 'boolean':
	      return !propValue;
	    case 'object':
	      if (Array.isArray(propValue)) {
	        return propValue.every(isNode);
	      }
	      if (propValue === null || ReactElement.isValidElement(propValue)) {
	        return true;
	      }
	
	      var iteratorFn = getIteratorFn(propValue);
	      if (iteratorFn) {
	        var iterator = iteratorFn.call(propValue);
	        var step;
	        if (iteratorFn !== propValue.entries) {
	          while (!(step = iterator.next()).done) {
	            if (!isNode(step.value)) {
	              return false;
	            }
	          }
	        } else {
	          // Iterator will provide entry [k,v] tuples rather than values.
	          while (!(step = iterator.next()).done) {
	            var entry = step.value;
	            if (entry) {
	              if (!isNode(entry[1])) {
	                return false;
	              }
	            }
	          }
	        }
	      } else {
	        return false;
	      }
	
	      return true;
	    default:
	      return false;
	  }
	}
	
	// Equivalent of `typeof` but with special handling for array and regexp.
	function getPropType(propValue) {
	  var propType = typeof propValue;
	  if (Array.isArray(propValue)) {
	    return 'array';
	  }
	  if (propValue instanceof RegExp) {
	    // Old webkits (at least until Android 4.0) return 'function' rather than
	    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	    // passes PropTypes.object.
	    return 'object';
	  }
	  return propType;
	}
	
	// This handles more types than `getPropType`. Only used for error messages.
	// See `createPrimitiveTypeChecker`.
	function getPreciseType(propValue) {
	  var propType = getPropType(propValue);
	  if (propType === 'object') {
	    if (propValue instanceof Date) {
	      return 'date';
	    } else if (propValue instanceof RegExp) {
	      return 'regexp';
	    }
	  }
	  return propType;
	}
	
	// Returns class name of the object, if any.
	function getClassName(propValue) {
	  if (!propValue.constructor || !propValue.constructor.name) {
	    return '<<anonymous>>';
	  }
	  return propValue.constructor.name;
	}
	
	module.exports = ReactPropTypes;

/***/ },
/* 108 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getIteratorFn
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/* global Symbol */
	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}
	
	module.exports = getIteratorFn;

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMOption
	 */
	
	'use strict';
	
	var ReactChildren = __webpack_require__(110);
	var ReactDOMSelect = __webpack_require__(112);
	
	var assign = __webpack_require__(39);
	var warning = __webpack_require__(25);
	
	var valueContextKey = ReactDOMSelect.valueContextKey;
	
	/**
	 * Implements an <option> native component that warns when `selected` is set.
	 */
	var ReactDOMOption = {
	  mountWrapper: function (inst, props, context) {
	    // TODO (yungsters): Remove support for `selected` in <option>.
	    if (false) {
	      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : undefined;
	    }
	
	    // Look up whether this option is 'selected' via context
	    var selectValue = context[valueContextKey];
	
	    // If context key is null (e.g., no specified value or after initial mount)
	    // or missing (e.g., for <datalist>), we don't change props.selected
	    var selected = null;
	    if (selectValue != null) {
	      selected = false;
	      if (Array.isArray(selectValue)) {
	        // multiple
	        for (var i = 0; i < selectValue.length; i++) {
	          if ('' + selectValue[i] === '' + props.value) {
	            selected = true;
	            break;
	          }
	        }
	      } else {
	        selected = '' + selectValue === '' + props.value;
	      }
	    }
	
	    inst._wrapperState = { selected: selected };
	  },
	
	  getNativeProps: function (inst, props, context) {
	    var nativeProps = assign({ selected: undefined, children: undefined }, props);
	
	    // Read state only from initial mount because <select> updates value
	    // manually; we need the initial state only for server rendering
	    if (inst._wrapperState.selected != null) {
	      nativeProps.selected = inst._wrapperState.selected;
	    }
	
	    var content = '';
	
	    // Flatten children and warn if they aren't strings or numbers;
	    // invalid types are ignored.
	    ReactChildren.forEach(props.children, function (child) {
	      if (child == null) {
	        return;
	      }
	      if (typeof child === 'string' || typeof child === 'number') {
	        content += child;
	      } else {
	         false ? warning(false, 'Only strings and numbers are supported as <option> children.') : undefined;
	      }
	    });
	
	    nativeProps.children = content;
	    return nativeProps;
	  }
	
	};
	
	module.exports = ReactDOMOption;

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildren
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(56);
	var ReactElement = __webpack_require__(42);
	
	var emptyFunction = __webpack_require__(15);
	var traverseAllChildren = __webpack_require__(111);
	
	var twoArgumentPooler = PooledClass.twoArgumentPooler;
	var fourArgumentPooler = PooledClass.fourArgumentPooler;
	
	var userProvidedKeyEscapeRegex = /\/(?!\/)/g;
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, '//');
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * traversal. Allows avoiding binding callbacks.
	 *
	 * @constructor ForEachBookKeeping
	 * @param {!function} forEachFunction Function to perform traversal with.
	 * @param {?*} forEachContext Context to perform context with.
	 */
	function ForEachBookKeeping(forEachFunction, forEachContext) {
	  this.func = forEachFunction;
	  this.context = forEachContext;
	  this.count = 0;
	}
	ForEachBookKeeping.prototype.destructor = function () {
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
	
	function forEachSingleChild(bookKeeping, child, name) {
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	  func.call(context, child, bookKeeping.count++);
	}
	
	/**
	 * Iterates through children that are typically specified as `props.children`.
	 *
	 * The provided forEachFunc(child, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} forEachFunc
	 * @param {*} forEachContext Context for forEachContext.
	 */
	function forEachChildren(children, forEachFunc, forEachContext) {
	  if (children == null) {
	    return children;
	  }
	  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
	  traverseAllChildren(children, forEachSingleChild, traverseContext);
	  ForEachBookKeeping.release(traverseContext);
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * mapping. Allows avoiding binding callbacks.
	 *
	 * @constructor MapBookKeeping
	 * @param {!*} mapResult Object containing the ordered map of results.
	 * @param {!function} mapFunction Function to perform mapping with.
	 * @param {?*} mapContext Context to perform mapping with.
	 */
	function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
	  this.result = mapResult;
	  this.keyPrefix = keyPrefix;
	  this.func = mapFunction;
	  this.context = mapContext;
	  this.count = 0;
	}
	MapBookKeeping.prototype.destructor = function () {
	  this.result = null;
	  this.keyPrefix = null;
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);
	
	function mapSingleChildIntoContext(bookKeeping, child, childKey) {
	  var result = bookKeeping.result;
	  var keyPrefix = bookKeeping.keyPrefix;
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	  var mappedChild = func.call(context, child, bookKeeping.count++);
	  if (Array.isArray(mappedChild)) {
	    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
	  } else if (mappedChild != null) {
	    if (ReactElement.isValidElement(mappedChild)) {
	      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
	      // Keep both the (mapped) and old keys if they differ, just as
	      // traverseAllChildren used to do for objects as children
	      keyPrefix + (mappedChild !== child ? escapeUserProvidedKey(mappedChild.key || '') + '/' : '') + childKey);
	    }
	    result.push(mappedChild);
	  }
	}
	
	function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
	  var escapedPrefix = '';
	  if (prefix != null) {
	    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
	  }
	  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
	  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
	  MapBookKeeping.release(traverseContext);
	}
	
	/**
	 * Maps children that are typically specified as `props.children`.
	 *
	 * The provided mapFunction(child, key, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} func The map function.
	 * @param {*} context Context for mapFunction.
	 * @return {object} Object containing the ordered map of results.
	 */
	function mapChildren(children, func, context) {
	  if (children == null) {
	    return children;
	  }
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
	  return result;
	}
	
	function forEachSingleChildDummy(traverseContext, child, name) {
	  return null;
	}
	
	/**
	 * Count the number of children that are typically specified as
	 * `props.children`.
	 *
	 * @param {?*} children Children tree container.
	 * @return {number} The number of children.
	 */
	function countChildren(children, context) {
	  return traverseAllChildren(children, forEachSingleChildDummy, null);
	}
	
	/**
	 * Flatten a children object (typically specified as `props.children`) and
	 * return an array with appropriately re-keyed children.
	 */
	function toArray(children) {
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
	  return result;
	}
	
	var ReactChildren = {
	  forEach: forEachChildren,
	  map: mapChildren,
	  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
	  count: countChildren,
	  toArray: toArray
	};
	
	module.exports = ReactChildren;

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule traverseAllChildren
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(5);
	var ReactElement = __webpack_require__(42);
	var ReactInstanceHandles = __webpack_require__(45);
	
	var getIteratorFn = __webpack_require__(108);
	var invariant = __webpack_require__(13);
	var warning = __webpack_require__(25);
	
	var SEPARATOR = ReactInstanceHandles.SEPARATOR;
	var SUBSEPARATOR = ':';
	
	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */
	
	var userProvidedKeyEscaperLookup = {
	  '=': '=0',
	  '.': '=1',
	  ':': '=2'
	};
	
	var userProvidedKeyEscapeRegex = /[=.:]/g;
	
	var didWarnAboutMaps = false;
	
	function userProvidedKeyEscaper(match) {
	  return userProvidedKeyEscaperLookup[match];
	}
	
	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  if (component && component.key != null) {
	    // Explicit key
	    return wrapUserProvidedKey(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}
	
	/**
	 * Escape a component key so that it is safe to use in a reactid.
	 *
	 * @param {*} text Component key to be escaped.
	 * @return {string} An escaped string.
	 */
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);
	}
	
	/**
	 * Wrap a `key` value explicitly provided by the user to distinguish it from
	 * implicitly-generated keys generated by a component's index in its parent.
	 *
	 * @param {string} key Value of a user-provided `key` attribute
	 * @return {string}
	 */
	function wrapUserProvidedKey(key) {
	  return '$' + escapeUserProvidedKey(key);
	}
	
	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children;
	
	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }
	
	  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }
	
	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
	
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (false) {
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.') : undefined;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + wrapUserProvidedKey(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (false) {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ?  false ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : invariant(false) : undefined;
	    }
	  }
	
	  return subtreeCount;
	}
	
	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }
	
	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}
	
	module.exports = traverseAllChildren;

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelect
	 */
	
	'use strict';
	
	var LinkedValueUtils = __webpack_require__(106);
	var ReactMount = __webpack_require__(28);
	var ReactUpdates = __webpack_require__(54);
	
	var assign = __webpack_require__(39);
	var warning = __webpack_require__(25);
	
	var valueContextKey = '__ReactDOMSelect_value$' + Math.random().toString(36).slice(2);
	
	function updateOptionsIfPendingUpdateAndMounted() {
	  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
	    this._wrapperState.pendingUpdate = false;
	
	    var props = this._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	
	    if (value != null) {
	      updateOptions(this, Boolean(props.multiple), value);
	    }
	  }
	}
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	var valuePropNames = ['value', 'defaultValue'];
	
	/**
	 * Validation function for `value` and `defaultValue`.
	 * @private
	 */
	function checkSelectPropTypes(inst, props) {
	  var owner = inst._currentElement._owner;
	  LinkedValueUtils.checkPropTypes('select', props, owner);
	
	  for (var i = 0; i < valuePropNames.length; i++) {
	    var propName = valuePropNames[i];
	    if (props[propName] == null) {
	      continue;
	    }
	    if (props.multiple) {
	       false ? warning(Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
	    } else {
	       false ? warning(!Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
	    }
	  }
	}
	
	/**
	 * @param {ReactDOMComponent} inst
	 * @param {boolean} multiple
	 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
	 * @private
	 */
	function updateOptions(inst, multiple, propValue) {
	  var selectedValue, i;
	  var options = ReactMount.getNode(inst._rootNodeID).options;
	
	  if (multiple) {
	    selectedValue = {};
	    for (i = 0; i < propValue.length; i++) {
	      selectedValue['' + propValue[i]] = true;
	    }
	    for (i = 0; i < options.length; i++) {
	      var selected = selectedValue.hasOwnProperty(options[i].value);
	      if (options[i].selected !== selected) {
	        options[i].selected = selected;
	      }
	    }
	  } else {
	    // Do not set `select.value` as exact behavior isn't consistent across all
	    // browsers for all cases.
	    selectedValue = '' + propValue;
	    for (i = 0; i < options.length; i++) {
	      if (options[i].value === selectedValue) {
	        options[i].selected = true;
	        return;
	      }
	    }
	    if (options.length) {
	      options[0].selected = true;
	    }
	  }
	}
	
	/**
	 * Implements a <select> native component that allows optionally setting the
	 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
	 * stringable. If `multiple` is true, the prop must be an array of stringables.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that change the
	 * selected option will trigger updates to the rendered options.
	 *
	 * If it is supplied (and not null/undefined), the rendered options will not
	 * update in response to user actions. Instead, the `value` prop must change in
	 * order for the rendered options to update.
	 *
	 * If `defaultValue` is provided, any options with the supplied values will be
	 * selected.
	 */
	var ReactDOMSelect = {
	  valueContextKey: valueContextKey,
	
	  getNativeProps: function (inst, props, context) {
	    return assign({}, props, {
	      onChange: inst._wrapperState.onChange,
	      value: undefined
	    });
	  },
	
	  mountWrapper: function (inst, props) {
	    if (false) {
	      checkSelectPropTypes(inst, props);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    inst._wrapperState = {
	      pendingUpdate: false,
	      initialValue: value != null ? value : props.defaultValue,
	      onChange: _handleChange.bind(inst),
	      wasMultiple: Boolean(props.multiple)
	    };
	  },
	
	  processChildContext: function (inst, props, context) {
	    // Pass down initial value so initial generated markup has correct
	    // `selected` attributes
	    var childContext = assign({}, context);
	    childContext[valueContextKey] = inst._wrapperState.initialValue;
	    return childContext;
	  },
	
	  postUpdateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    // After the initial mount, we control selected-ness manually so don't pass
	    // the context value down
	    inst._wrapperState.initialValue = undefined;
	
	    var wasMultiple = inst._wrapperState.wasMultiple;
	    inst._wrapperState.wasMultiple = Boolean(props.multiple);
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      inst._wrapperState.pendingUpdate = false;
	      updateOptions(inst, Boolean(props.multiple), value);
	    } else if (wasMultiple !== Boolean(props.multiple)) {
	      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
	      if (props.defaultValue != null) {
	        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
	      } else {
	        // Revert the select back to its default unselected state.
	        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
	      }
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  this._wrapperState.pendingUpdate = true;
	  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMSelect;

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextarea
	 */
	
	'use strict';
	
	var LinkedValueUtils = __webpack_require__(106);
	var ReactDOMIDOperations = __webpack_require__(27);
	var ReactUpdates = __webpack_require__(54);
	
	var assign = __webpack_require__(39);
	var invariant = __webpack_require__(13);
	var warning = __webpack_require__(25);
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMTextarea.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements a <textarea> native component that allows setting `value`, and
	 * `defaultValue`. This differs from the traditional DOM API because value is
	 * usually set as PCDATA children.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that affect the
	 * value will trigger updates to the element.
	 *
	 * If `value` is supplied (and not null/undefined), the rendered element will
	 * not trigger updates to the element. Instead, the `value` prop must change in
	 * order for the rendered element to be updated.
	 *
	 * The rendered element will be initialized with an empty value, the prop
	 * `defaultValue` if specified, or the children content (deprecated).
	 */
	var ReactDOMTextarea = {
	  getNativeProps: function (inst, props, context) {
	    !(props.dangerouslySetInnerHTML == null) ?  false ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : invariant(false) : undefined;
	
	    // Always set children to the same thing. In IE9, the selection range will
	    // get reset if `textContent` is mutated.
	    var nativeProps = assign({}, props, {
	      defaultValue: undefined,
	      value: undefined,
	      children: inst._wrapperState.initialValue,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return nativeProps;
	  },
	
	  mountWrapper: function (inst, props) {
	    if (false) {
	      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
	    }
	
	    var defaultValue = props.defaultValue;
	    // TODO (yungsters): Remove support for children content in <textarea>.
	    var children = props.children;
	    if (children != null) {
	      if (false) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : undefined;
	      }
	      !(defaultValue == null) ?  false ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : invariant(false) : undefined;
	      if (Array.isArray(children)) {
	        !(children.length <= 1) ?  false ? invariant(false, '<textarea> can only have at most one child.') : invariant(false) : undefined;
	        children = children[0];
	      }
	
	      defaultValue = '' + children;
	    }
	    if (defaultValue == null) {
	      defaultValue = '';
	    }
	    var value = LinkedValueUtils.getValue(props);
	
	    inst._wrapperState = {
	      // We save the initial value so that `ReactDOMComponent` doesn't update
	      // `textContent` (unnecessary since we update value).
	      // The initial value can be a boolean or object so that's why it's
	      // forced to be a string.
	      initialValue: '' + (value != null ? value : defaultValue),
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMTextarea;

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChild
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactComponentEnvironment = __webpack_require__(64);
	var ReactMultiChildUpdateTypes = __webpack_require__(16);
	
	var ReactCurrentOwner = __webpack_require__(5);
	var ReactReconciler = __webpack_require__(50);
	var ReactChildReconciler = __webpack_require__(115);
	
	var flattenChildren = __webpack_require__(116);
	
	/**
	 * Updating children of a component may trigger recursive updates. The depth is
	 * used to batch recursive updates to render markup more efficiently.
	 *
	 * @type {number}
	 * @private
	 */
	var updateDepth = 0;
	
	/**
	 * Queue of update configuration objects.
	 *
	 * Each object has a `type` property that is in `ReactMultiChildUpdateTypes`.
	 *
	 * @type {array<object>}
	 * @private
	 */
	var updateQueue = [];
	
	/**
	 * Queue of markup to be rendered.
	 *
	 * @type {array<string>}
	 * @private
	 */
	var markupQueue = [];
	
	/**
	 * Enqueues markup to be rendered and inserted at a supplied index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} markup Markup that renders into an element.
	 * @param {number} toIndex Destination index.
	 * @private
	 */
	function enqueueInsertMarkup(parentID, markup, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
	    markupIndex: markupQueue.push(markup) - 1,
	    content: null,
	    fromIndex: null,
	    toIndex: toIndex
	  });
	}
	
	/**
	 * Enqueues moving an existing element to another index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {number} fromIndex Source index of the existing element.
	 * @param {number} toIndex Destination index of the element.
	 * @private
	 */
	function enqueueMove(parentID, fromIndex, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
	    markupIndex: null,
	    content: null,
	    fromIndex: fromIndex,
	    toIndex: toIndex
	  });
	}
	
	/**
	 * Enqueues removing an element at an index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {number} fromIndex Index of the element to remove.
	 * @private
	 */
	function enqueueRemove(parentID, fromIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
	    markupIndex: null,
	    content: null,
	    fromIndex: fromIndex,
	    toIndex: null
	  });
	}
	
	/**
	 * Enqueues setting the markup of a node.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} markup Markup that renders into an element.
	 * @private
	 */
	function enqueueSetMarkup(parentID, markup) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.SET_MARKUP,
	    markupIndex: null,
	    content: markup,
	    fromIndex: null,
	    toIndex: null
	  });
	}
	
	/**
	 * Enqueues setting the text content.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} textContent Text content to set.
	 * @private
	 */
	function enqueueTextContent(parentID, textContent) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
	    markupIndex: null,
	    content: textContent,
	    fromIndex: null,
	    toIndex: null
	  });
	}
	
	/**
	 * Processes any enqueued updates.
	 *
	 * @private
	 */
	function processQueue() {
	  if (updateQueue.length) {
	    ReactComponentEnvironment.processChildrenUpdates(updateQueue, markupQueue);
	    clearQueue();
	  }
	}
	
	/**
	 * Clears any enqueued updates.
	 *
	 * @private
	 */
	function clearQueue() {
	  updateQueue.length = 0;
	  markupQueue.length = 0;
	}
	
	/**
	 * ReactMultiChild are capable of reconciling multiple children.
	 *
	 * @class ReactMultiChild
	 * @internal
	 */
	var ReactMultiChild = {
	
	  /**
	   * Provides common functionality for components that must reconcile multiple
	   * children. This is used by `ReactDOMComponent` to mount, update, and
	   * unmount child components.
	   *
	   * @lends {ReactMultiChild.prototype}
	   */
	  Mixin: {
	
	    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
	      if (false) {
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	        }
	      }
	      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	    },
	
	    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, transaction, context) {
	      var nextChildren;
	      if (false) {
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            nextChildren = flattenChildren(nextNestedChildrenElements);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	          return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
	        }
	      }
	      nextChildren = flattenChildren(nextNestedChildrenElements);
	      return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
	    },
	
	    /**
	     * Generates a "mount image" for each of the supplied children. In the case
	     * of `ReactDOMComponent`, a mount image is a string of markup.
	     *
	     * @param {?object} nestedChildren Nested child maps.
	     * @return {array} An array of mounted representations.
	     * @internal
	     */
	    mountChildren: function (nestedChildren, transaction, context) {
	      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
	      this._renderedChildren = children;
	      var mountImages = [];
	      var index = 0;
	      for (var name in children) {
	        if (children.hasOwnProperty(name)) {
	          var child = children[name];
	          // Inlined for performance, see `ReactInstanceHandles.createReactID`.
	          var rootID = this._rootNodeID + name;
	          var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
	          child._mountIndex = index++;
	          mountImages.push(mountImage);
	        }
	      }
	      return mountImages;
	    },
	
	    /**
	     * Replaces any rendered children with a text content string.
	     *
	     * @param {string} nextContent String of content.
	     * @internal
	     */
	    updateTextContent: function (nextContent) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        var prevChildren = this._renderedChildren;
	        // Remove any rendered children.
	        ReactChildReconciler.unmountChildren(prevChildren);
	        // TODO: The setTextContent operation should be enough
	        for (var name in prevChildren) {
	          if (prevChildren.hasOwnProperty(name)) {
	            this._unmountChild(prevChildren[name]);
	          }
	        }
	        // Set new text content.
	        this.setTextContent(nextContent);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },
	
	    /**
	     * Replaces any rendered children with a markup string.
	     *
	     * @param {string} nextMarkup String of markup.
	     * @internal
	     */
	    updateMarkup: function (nextMarkup) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        var prevChildren = this._renderedChildren;
	        // Remove any rendered children.
	        ReactChildReconciler.unmountChildren(prevChildren);
	        for (var name in prevChildren) {
	          if (prevChildren.hasOwnProperty(name)) {
	            this._unmountChildByName(prevChildren[name], name);
	          }
	        }
	        this.setMarkup(nextMarkup);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },
	
	    /**
	     * Updates the rendered children with new children.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     */
	    updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        this._updateChildren(nextNestedChildrenElements, transaction, context);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },
	
	    /**
	     * Improve performance by isolating this hot code path from the try/catch
	     * block in `updateChildren`.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @final
	     * @protected
	     */
	    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      var prevChildren = this._renderedChildren;
	      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, transaction, context);
	      this._renderedChildren = nextChildren;
	      if (!nextChildren && !prevChildren) {
	        return;
	      }
	      var name;
	      // `nextIndex` will increment for each child in `nextChildren`, but
	      // `lastIndex` will be the last index visited in `prevChildren`.
	      var lastIndex = 0;
	      var nextIndex = 0;
	      for (name in nextChildren) {
	        if (!nextChildren.hasOwnProperty(name)) {
	          continue;
	        }
	        var prevChild = prevChildren && prevChildren[name];
	        var nextChild = nextChildren[name];
	        if (prevChild === nextChild) {
	          this.moveChild(prevChild, nextIndex, lastIndex);
	          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	          prevChild._mountIndex = nextIndex;
	        } else {
	          if (prevChild) {
	            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
	            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	            this._unmountChild(prevChild);
	          }
	          // The child must be instantiated before it's mounted.
	          this._mountChildByNameAtIndex(nextChild, name, nextIndex, transaction, context);
	        }
	        nextIndex++;
	      }
	      // Remove children that are no longer present.
	      for (name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	          this._unmountChild(prevChildren[name]);
	        }
	      }
	    },
	
	    /**
	     * Unmounts all rendered children. This should be used to clean up children
	     * when this component is unmounted.
	     *
	     * @internal
	     */
	    unmountChildren: function () {
	      var renderedChildren = this._renderedChildren;
	      ReactChildReconciler.unmountChildren(renderedChildren);
	      this._renderedChildren = null;
	    },
	
	    /**
	     * Moves a child component to the supplied index.
	     *
	     * @param {ReactComponent} child Component to move.
	     * @param {number} toIndex Destination index of the element.
	     * @param {number} lastIndex Last index visited of the siblings of `child`.
	     * @protected
	     */
	    moveChild: function (child, toIndex, lastIndex) {
	      // If the index of `child` is less than `lastIndex`, then it needs to
	      // be moved. Otherwise, we do not need to move it because a child will be
	      // inserted or moved before `child`.
	      if (child._mountIndex < lastIndex) {
	        enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
	      }
	    },
	
	    /**
	     * Creates a child component.
	     *
	     * @param {ReactComponent} child Component to create.
	     * @param {string} mountImage Markup to insert.
	     * @protected
	     */
	    createChild: function (child, mountImage) {
	      enqueueInsertMarkup(this._rootNodeID, mountImage, child._mountIndex);
	    },
	
	    /**
	     * Removes a child component.
	     *
	     * @param {ReactComponent} child Child to remove.
	     * @protected
	     */
	    removeChild: function (child) {
	      enqueueRemove(this._rootNodeID, child._mountIndex);
	    },
	
	    /**
	     * Sets this text content string.
	     *
	     * @param {string} textContent Text content to set.
	     * @protected
	     */
	    setTextContent: function (textContent) {
	      enqueueTextContent(this._rootNodeID, textContent);
	    },
	
	    /**
	     * Sets this markup string.
	     *
	     * @param {string} markup Markup to set.
	     * @protected
	     */
	    setMarkup: function (markup) {
	      enqueueSetMarkup(this._rootNodeID, markup);
	    },
	
	    /**
	     * Mounts a child with the supplied name.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to mount.
	     * @param {string} name Name of the child.
	     * @param {number} index Index at which to insert the child.
	     * @param {ReactReconcileTransaction} transaction
	     * @private
	     */
	    _mountChildByNameAtIndex: function (child, name, index, transaction, context) {
	      // Inlined for performance, see `ReactInstanceHandles.createReactID`.
	      var rootID = this._rootNodeID + name;
	      var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
	      child._mountIndex = index;
	      this.createChild(child, mountImage);
	    },
	
	    /**
	     * Unmounts a rendered child.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to unmount.
	     * @private
	     */
	    _unmountChild: function (child) {
	      this.removeChild(child);
	      child._mountIndex = null;
	    }
	
	  }
	
	};
	
	module.exports = ReactMultiChild;

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildReconciler
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactReconciler = __webpack_require__(50);
	
	var instantiateReactComponent = __webpack_require__(62);
	var shouldUpdateReactComponent = __webpack_require__(67);
	var traverseAllChildren = __webpack_require__(111);
	var warning = __webpack_require__(25);
	
	function instantiateChild(childInstances, child, name) {
	  // We found a component instance.
	  var keyUnique = childInstances[name] === undefined;
	  if (false) {
	    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
	  }
	  if (child != null && keyUnique) {
	    childInstances[name] = instantiateReactComponent(child, null);
	  }
	}
	
	/**
	 * ReactChildReconciler provides helpers for initializing or updating a set of
	 * children. Its output is suitable for passing it onto ReactMultiChild which
	 * does diffed reordering and insertion.
	 */
	var ReactChildReconciler = {
	  /**
	   * Generates a "mount image" for each of the supplied children. In the case
	   * of `ReactDOMComponent`, a mount image is a string of markup.
	   *
	   * @param {?object} nestedChildNodes Nested child maps.
	   * @return {?object} A set of child instances.
	   * @internal
	   */
	  instantiateChildren: function (nestedChildNodes, transaction, context) {
	    if (nestedChildNodes == null) {
	      return null;
	    }
	    var childInstances = {};
	    traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
	    return childInstances;
	  },
	
	  /**
	   * Updates the rendered children and returns a new set of children.
	   *
	   * @param {?object} prevChildren Previously initialized set of children.
	   * @param {?object} nextChildren Flat child element maps.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @return {?object} A new set of child instances.
	   * @internal
	   */
	  updateChildren: function (prevChildren, nextChildren, transaction, context) {
	    // We currently don't have a way to track moves here but if we use iterators
	    // instead of for..in we can zip the iterators and check if an item has
	    // moved.
	    // TODO: If nothing has changed, return the prevChildren object so that we
	    // can quickly bailout if nothing has changed.
	    if (!nextChildren && !prevChildren) {
	      return null;
	    }
	    var name;
	    for (name in nextChildren) {
	      if (!nextChildren.hasOwnProperty(name)) {
	        continue;
	      }
	      var prevChild = prevChildren && prevChildren[name];
	      var prevElement = prevChild && prevChild._currentElement;
	      var nextElement = nextChildren[name];
	      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
	        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
	        nextChildren[name] = prevChild;
	      } else {
	        if (prevChild) {
	          ReactReconciler.unmountComponent(prevChild, name);
	        }
	        // The child must be instantiated before it's mounted.
	        var nextChildInstance = instantiateReactComponent(nextElement, null);
	        nextChildren[name] = nextChildInstance;
	      }
	    }
	    // Unmount children that are no longer present.
	    for (name in prevChildren) {
	      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	        ReactReconciler.unmountComponent(prevChildren[name]);
	      }
	    }
	    return nextChildren;
	  },
	
	  /**
	   * Unmounts all rendered children. This should be used to clean up children
	   * when this component is unmounted.
	   *
	   * @param {?object} renderedChildren Previously initialized set of children.
	   * @internal
	   */
	  unmountChildren: function (renderedChildren) {
	    for (var name in renderedChildren) {
	      if (renderedChildren.hasOwnProperty(name)) {
	        var renderedChild = renderedChildren[name];
	        ReactReconciler.unmountComponent(renderedChild);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactChildReconciler;

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule flattenChildren
	 */
	
	'use strict';
	
	var traverseAllChildren = __webpack_require__(111);
	var warning = __webpack_require__(25);
	
	/**
	 * @param {function} traverseContext Context passed through traversal.
	 * @param {?ReactComponent} child React child component.
	 * @param {!string} name String name of key path to child.
	 */
	function flattenSingleChildIntoContext(traverseContext, child, name) {
	  // We found a component instance.
	  var result = traverseContext;
	  var keyUnique = result[name] === undefined;
	  if (false) {
	    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
	  }
	  if (keyUnique && child != null) {
	    result[name] = child;
	  }
	}
	
	/**
	 * Flattens children that are typically specified as `props.children`. Any null
	 * children will not be included in the resulting object.
	 * @return {!object} flattened children keyed by name.
	 */
	function flattenChildren(children) {
	  if (children == null) {
	    return children;
	  }
	  var result = {};
	  traverseAllChildren(children, flattenSingleChildIntoContext, result);
	  return result;
	}
	
	module.exports = flattenChildren;

/***/ },
/* 117 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shallowEqual
	 * @typechecks
	 * 
	 */
	
	'use strict';
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (objA === objB) {
	    return true;
	  }
	
	  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
	    return false;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  var bHasOwnProperty = hasOwnProperty.bind(objB);
	  for (var i = 0; i < keysA.length; i++) {
	    if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	module.exports = shallowEqual;

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventListener
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventListener = __webpack_require__(119);
	var ExecutionEnvironment = __webpack_require__(9);
	var PooledClass = __webpack_require__(56);
	var ReactInstanceHandles = __webpack_require__(45);
	var ReactMount = __webpack_require__(28);
	var ReactUpdates = __webpack_require__(54);
	
	var assign = __webpack_require__(39);
	var getEventTarget = __webpack_require__(81);
	var getUnboundedScrollPosition = __webpack_require__(120);
	
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	/**
	 * Finds the parent React component of `node`.
	 *
	 * @param {*} node
	 * @return {?DOMEventTarget} Parent container, or `null` if the specified node
	 *                           is not nested.
	 */
	function findParent(node) {
	  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
	  // traversal, but caching is difficult to do correctly without using a
	  // mutation observer to listen for all DOM changes.
	  var nodeID = ReactMount.getID(node);
	  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
	  var container = ReactMount.findReactContainerForID(rootID);
	  var parent = ReactMount.getFirstReactDOM(container);
	  return parent;
	}
	
	// Used to store ancestor hierarchy in top level callback
	function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
	  this.topLevelType = topLevelType;
	  this.nativeEvent = nativeEvent;
	  this.ancestors = [];
	}
	assign(TopLevelCallbackBookKeeping.prototype, {
	  destructor: function () {
	    this.topLevelType = null;
	    this.nativeEvent = null;
	    this.ancestors.length = 0;
	  }
	});
	PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
	
	function handleTopLevelImpl(bookKeeping) {
	  // TODO: Re-enable event.path handling
	  //
	  // if (bookKeeping.nativeEvent.path && bookKeeping.nativeEvent.path.length > 1) {
	  //   // New browsers have a path attribute on native events
	  //   handleTopLevelWithPath(bookKeeping);
	  // } else {
	  //   // Legacy browsers don't have a path attribute on native events
	  //   handleTopLevelWithoutPath(bookKeeping);
	  // }
	
	  void handleTopLevelWithPath; // temporarily unused
	  handleTopLevelWithoutPath(bookKeeping);
	}
	
	// Legacy browsers don't have a path attribute on native events
	function handleTopLevelWithoutPath(bookKeeping) {
	  var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;
	
	  // Loop through the hierarchy, in case there's any nested components.
	  // It's important that we build the array of ancestors before calling any
	  // event handlers, because event handlers can modify the DOM, leading to
	  // inconsistencies with ReactMount's node cache. See #1105.
	  var ancestor = topLevelTarget;
	  while (ancestor) {
	    bookKeeping.ancestors.push(ancestor);
	    ancestor = findParent(ancestor);
	  }
	
	  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
	    topLevelTarget = bookKeeping.ancestors[i];
	    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	// New browsers have a path attribute on native events
	function handleTopLevelWithPath(bookKeeping) {
	  var path = bookKeeping.nativeEvent.path;
	  var currentNativeTarget = path[0];
	  var eventsFired = 0;
	  for (var i = 0; i < path.length; i++) {
	    var currentPathElement = path[i];
	    if (currentPathElement.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE) {
	      currentNativeTarget = path[i + 1];
	    }
	    // TODO: slow
	    var reactParent = ReactMount.getFirstReactDOM(currentPathElement);
	    if (reactParent === currentPathElement) {
	      var currentPathElementID = ReactMount.getID(currentPathElement);
	      var newRootID = ReactInstanceHandles.getReactRootIDFromNodeID(currentPathElementID);
	      bookKeeping.ancestors.push(currentPathElement);
	
	      var topLevelTargetID = ReactMount.getID(currentPathElement) || '';
	      eventsFired++;
	      ReactEventListener._handleTopLevel(bookKeeping.topLevelType, currentPathElement, topLevelTargetID, bookKeeping.nativeEvent, currentNativeTarget);
	
	      // Jump to the root of this React render tree
	      while (currentPathElementID !== newRootID) {
	        i++;
	        currentPathElement = path[i];
	        currentPathElementID = ReactMount.getID(currentPathElement);
	      }
	    }
	  }
	  if (eventsFired === 0) {
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, window, '', bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	function scrollValueMonitor(cb) {
	  var scrollPosition = getUnboundedScrollPosition(window);
	  cb(scrollPosition);
	}
	
	var ReactEventListener = {
	  _enabled: true,
	  _handleTopLevel: null,
	
	  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
	
	  setHandleTopLevel: function (handleTopLevel) {
	    ReactEventListener._handleTopLevel = handleTopLevel;
	  },
	
	  setEnabled: function (enabled) {
	    ReactEventListener._enabled = !!enabled;
	  },
	
	  isEnabled: function () {
	    return ReactEventListener._enabled;
	  },
	
	  /**
	   * Traps top-level events by using event bubbling.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  /**
	   * Traps a top-level event by using event capturing.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  monitorScrollValue: function (refresh) {
	    var callback = scrollValueMonitor.bind(null, refresh);
	    EventListener.listen(window, 'scroll', callback);
	  },
	
	  dispatchEvent: function (topLevelType, nativeEvent) {
	    if (!ReactEventListener._enabled) {
	      return;
	    }
	
	    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
	    try {
	      // Event queue being processed in the same cycle allows
	      // `preventDefault`.
	      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
	    } finally {
	      TopLevelCallbackBookKeeping.release(bookKeeping);
	    }
	  }
	};
	
	module.exports = ReactEventListener;

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * @providesModule EventListener
	 * @typechecks
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(15);
	
	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function (target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function () {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function () {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },
	
	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function (target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function () {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (false) {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: emptyFunction
	      };
	    }
	  },
	
	  registerDefault: function () {}
	};
	
	module.exports = EventListener;

/***/ },
/* 120 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getUnboundedScrollPosition
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Gets the scroll position of the supplied element or window.
	 *
	 * The return values are unbounded, unlike `getScrollPosition`. This means they
	 * may be negative or exceed the element boundaries (which is possible using
	 * inertial scrolling).
	 *
	 * @param {DOMWindow|DOMElement} scrollable
	 * @return {object} Map with `x` and `y` keys.
	 */
	function getUnboundedScrollPosition(scrollable) {
	  if (scrollable === window) {
	    return {
	      x: window.pageXOffset || document.documentElement.scrollLeft,
	      y: window.pageYOffset || document.documentElement.scrollTop
	    };
	  }
	  return {
	    x: scrollable.scrollLeft,
	    y: scrollable.scrollTop
	  };
	}
	
	module.exports = getUnboundedScrollPosition;

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInjection
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(23);
	var EventPluginHub = __webpack_require__(31);
	var ReactComponentEnvironment = __webpack_require__(64);
	var ReactClass = __webpack_require__(122);
	var ReactEmptyComponent = __webpack_require__(68);
	var ReactBrowserEventEmitter = __webpack_require__(29);
	var ReactNativeComponent = __webpack_require__(69);
	var ReactPerf = __webpack_require__(18);
	var ReactRootIndex = __webpack_require__(46);
	var ReactUpdates = __webpack_require__(54);
	
	var ReactInjection = {
	  Component: ReactComponentEnvironment.injection,
	  Class: ReactClass.injection,
	  DOMProperty: DOMProperty.injection,
	  EmptyComponent: ReactEmptyComponent.injection,
	  EventPluginHub: EventPluginHub.injection,
	  EventEmitter: ReactBrowserEventEmitter.injection,
	  NativeComponent: ReactNativeComponent.injection,
	  Perf: ReactPerf.injection,
	  RootIndex: ReactRootIndex.injection,
	  Updates: ReactUpdates.injection
	};
	
	module.exports = ReactInjection;

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactClass
	 */
	
	'use strict';
	
	var ReactComponent = __webpack_require__(123);
	var ReactElement = __webpack_require__(42);
	var ReactPropTypeLocations = __webpack_require__(65);
	var ReactPropTypeLocationNames = __webpack_require__(66);
	var ReactNoopUpdateQueue = __webpack_require__(124);
	
	var assign = __webpack_require__(39);
	var emptyObject = __webpack_require__(58);
	var invariant = __webpack_require__(13);
	var keyMirror = __webpack_require__(17);
	var keyOf = __webpack_require__(79);
	var warning = __webpack_require__(25);
	
	var MIXINS_KEY = keyOf({ mixins: null });
	
	/**
	 * Policies that describe methods in `ReactClassInterface`.
	 */
	var SpecPolicy = keyMirror({
	  /**
	   * These methods may be defined only once by the class specification or mixin.
	   */
	  DEFINE_ONCE: null,
	  /**
	   * These methods may be defined by both the class specification and mixins.
	   * Subsequent definitions will be chained. These methods must return void.
	   */
	  DEFINE_MANY: null,
	  /**
	   * These methods are overriding the base class.
	   */
	  OVERRIDE_BASE: null,
	  /**
	   * These methods are similar to DEFINE_MANY, except we assume they return
	   * objects. We try to merge the keys of the return values of all the mixed in
	   * functions. If there is a key conflict we throw.
	   */
	  DEFINE_MANY_MERGED: null
	});
	
	var injectedMixins = [];
	
	var warnedSetProps = false;
	function warnSetProps() {
	  if (!warnedSetProps) {
	    warnedSetProps = true;
	     false ? warning(false, 'setProps(...) and replaceProps(...) are deprecated. ' + 'Instead, call render again at the top level.') : undefined;
	  }
	}
	
	/**
	 * Composite components are higher-level components that compose other composite
	 * or native components.
	 *
	 * To create a new type of `ReactClass`, pass a specification of
	 * your new class to `React.createClass`. The only requirement of your class
	 * specification is that you implement a `render` method.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return <div>Hello World</div>;
	 *     }
	 *   });
	 *
	 * The class specification supports a specific protocol of methods that have
	 * special meaning (e.g. `render`). See `ReactClassInterface` for
	 * more the comprehensive protocol. Any other properties and methods in the
	 * class specification will be available on the prototype.
	 *
	 * @interface ReactClassInterface
	 * @internal
	 */
	var ReactClassInterface = {
	
	  /**
	   * An array of Mixin objects to include when defining your component.
	   *
	   * @type {array}
	   * @optional
	   */
	  mixins: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * An object containing properties and methods that should be defined on
	   * the component's constructor instead of its prototype (static methods).
	   *
	   * @type {object}
	   * @optional
	   */
	  statics: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of prop types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  propTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  contextTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types this component sets for its children.
	   *
	   * @type {object}
	   * @optional
	   */
	  childContextTypes: SpecPolicy.DEFINE_MANY,
	
	  // ==== Definition methods ====
	
	  /**
	   * Invoked when the component is mounted. Values in the mapping will be set on
	   * `this.props` if that prop is not specified (i.e. using an `in` check).
	   *
	   * This method is invoked before `getInitialState` and therefore cannot rely
	   * on `this.state` or use `this.setState`.
	   *
	   * @return {object}
	   * @optional
	   */
	  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Invoked once before the component is mounted. The return value will be used
	   * as the initial value of `this.state`.
	   *
	   *   getInitialState: function() {
	   *     return {
	   *       isOn: false,
	   *       fooBaz: new BazFoo()
	   *     }
	   *   }
	   *
	   * @return {object}
	   * @optional
	   */
	  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * @return {object}
	   * @optional
	   */
	  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Uses props from `this.props` and state from `this.state` to render the
	   * structure of the component.
	   *
	   * No guarantees are made about when or how often this method is invoked, so
	   * it must not have side effects.
	   *
	   *   render: function() {
	   *     var name = this.props.name;
	   *     return <div>Hello, {name}!</div>;
	   *   }
	   *
	   * @return {ReactComponent}
	   * @nosideeffects
	   * @required
	   */
	  render: SpecPolicy.DEFINE_ONCE,
	
	  // ==== Delegate methods ====
	
	  /**
	   * Invoked when the component is initially created and about to be mounted.
	   * This may have side effects, but any external subscriptions or data created
	   * by this method must be cleaned up in `componentWillUnmount`.
	   *
	   * @optional
	   */
	  componentWillMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component has been mounted and has a DOM representation.
	   * However, there is no guarantee that the DOM node is in the document.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been mounted (initialized and rendered) for the first time.
	   *
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked before the component receives new props.
	   *
	   * Use this as an opportunity to react to a prop transition by updating the
	   * state using `this.setState`. Current props are accessed via `this.props`.
	   *
	   *   componentWillReceiveProps: function(nextProps, nextContext) {
	   *     this.setState({
	   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	   *     });
	   *   }
	   *
	   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	   * transition may cause a state change, but the opposite is not true. If you
	   * need it, you are probably looking for `componentWillUpdate`.
	   *
	   * @param {object} nextProps
	   * @optional
	   */
	  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked while deciding if the component should be updated as a result of
	   * receiving new props, state and/or context.
	   *
	   * Use this as an opportunity to `return false` when you're certain that the
	   * transition to the new props/state/context will not require a component
	   * update.
	   *
	   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	   *     return !equal(nextProps, this.props) ||
	   *       !equal(nextState, this.state) ||
	   *       !equal(nextContext, this.context);
	   *   }
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @return {boolean} True if the component should update.
	   * @optional
	   */
	  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,
	
	  /**
	   * Invoked when the component is about to update due to a transition from
	   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	   * and `nextContext`.
	   *
	   * Use this as an opportunity to perform preparation before an update occurs.
	   *
	   * NOTE: You **cannot** use `this.setState()` in this method.
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @param {ReactReconcileTransaction} transaction
	   * @optional
	   */
	  componentWillUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component's DOM representation has been updated.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been updated.
	   *
	   * @param {object} prevProps
	   * @param {?object} prevState
	   * @param {?object} prevContext
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component is about to be removed from its parent and have
	   * its DOM representation destroyed.
	   *
	   * Use this as an opportunity to deallocate any external resources.
	   *
	   * NOTE: There is no `componentDidUnmount` since your component will have been
	   * destroyed by that point.
	   *
	   * @optional
	   */
	  componentWillUnmount: SpecPolicy.DEFINE_MANY,
	
	  // ==== Advanced methods ====
	
	  /**
	   * Updates the component's currently mounted DOM representation.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   * @overridable
	   */
	  updateComponent: SpecPolicy.OVERRIDE_BASE
	
	};
	
	/**
	 * Mapping from class specification keys to special processing functions.
	 *
	 * Although these are declared like instance properties in the specification
	 * when defining classes using `React.createClass`, they are actually static
	 * and are accessible on the constructor instead of the prototype. Despite
	 * being static, they must be defined outside of the "statics" key under
	 * which all other static methods are defined.
	 */
	var RESERVED_SPEC_KEYS = {
	  displayName: function (Constructor, displayName) {
	    Constructor.displayName = displayName;
	  },
	  mixins: function (Constructor, mixins) {
	    if (mixins) {
	      for (var i = 0; i < mixins.length; i++) {
	        mixSpecIntoComponent(Constructor, mixins[i]);
	      }
	    }
	  },
	  childContextTypes: function (Constructor, childContextTypes) {
	    if (false) {
	      validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
	    }
	    Constructor.childContextTypes = assign({}, Constructor.childContextTypes, childContextTypes);
	  },
	  contextTypes: function (Constructor, contextTypes) {
	    if (false) {
	      validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
	    }
	    Constructor.contextTypes = assign({}, Constructor.contextTypes, contextTypes);
	  },
	  /**
	   * Special case getDefaultProps which should move into statics but requires
	   * automatic merging.
	   */
	  getDefaultProps: function (Constructor, getDefaultProps) {
	    if (Constructor.getDefaultProps) {
	      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
	    } else {
	      Constructor.getDefaultProps = getDefaultProps;
	    }
	  },
	  propTypes: function (Constructor, propTypes) {
	    if (false) {
	      validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
	    }
	    Constructor.propTypes = assign({}, Constructor.propTypes, propTypes);
	  },
	  statics: function (Constructor, statics) {
	    mixStaticSpecIntoComponent(Constructor, statics);
	  },
	  autobind: function () {} };
	
	// noop
	function validateTypeDef(Constructor, typeDef, location) {
	  for (var propName in typeDef) {
	    if (typeDef.hasOwnProperty(propName)) {
	      // use a warning instead of an invariant so components
	      // don't show up in prod but not in __DEV__
	       false ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : undefined;
	    }
	  }
	}
	
	function validateMethodOverride(proto, name) {
	  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
	
	  // Disallow overriding of base class methods unless explicitly allowed.
	  if (ReactClassMixin.hasOwnProperty(name)) {
	    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ?  false ? invariant(false, 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name) : invariant(false) : undefined;
	  }
	
	  // Disallow defining methods more than once unless explicitly allowed.
	  if (proto.hasOwnProperty(name)) {
	    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ?  false ? invariant(false, 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name) : invariant(false) : undefined;
	  }
	}
	
	/**
	 * Mixin helper which handles policy validation and reserved
	 * specification keys when building React classses.
	 */
	function mixSpecIntoComponent(Constructor, spec) {
	  if (!spec) {
	    return;
	  }
	
	  !(typeof spec !== 'function') ?  false ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component class as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
	  !!ReactElement.isValidElement(spec) ?  false ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
	
	  var proto = Constructor.prototype;
	
	  // By handling mixins before any other properties, we ensure the same
	  // chaining order is applied to methods with DEFINE_MANY policy, whether
	  // mixins are listed before or after these methods in the spec.
	  if (spec.hasOwnProperty(MIXINS_KEY)) {
	    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
	  }
	
	  for (var name in spec) {
	    if (!spec.hasOwnProperty(name)) {
	      continue;
	    }
	
	    if (name === MIXINS_KEY) {
	      // We have already handled mixins in a special case above.
	      continue;
	    }
	
	    var property = spec[name];
	    validateMethodOverride(proto, name);
	
	    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
	      RESERVED_SPEC_KEYS[name](Constructor, property);
	    } else {
	      // Setup methods on prototype:
	      // The following member methods should not be automatically bound:
	      // 1. Expected ReactClass methods (in the "interface").
	      // 2. Overridden methods (that were mixed in).
	      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
	      var isAlreadyDefined = proto.hasOwnProperty(name);
	      var isFunction = typeof property === 'function';
	      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
	
	      if (shouldAutoBind) {
	        if (!proto.__reactAutoBindMap) {
	          proto.__reactAutoBindMap = {};
	        }
	        proto.__reactAutoBindMap[name] = property;
	        proto[name] = property;
	      } else {
	        if (isAlreadyDefined) {
	          var specPolicy = ReactClassInterface[name];
	
	          // These cases should already be caught by validateMethodOverride.
	          !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ?  false ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name) : invariant(false) : undefined;
	
	          // For methods which are defined more than once, call the existing
	          // methods before calling the new property, merging if appropriate.
	          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
	            proto[name] = createMergedResultFunction(proto[name], property);
	          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
	            proto[name] = createChainedFunction(proto[name], property);
	          }
	        } else {
	          proto[name] = property;
	          if (false) {
	            // Add verbose displayName to the function, which helps when looking
	            // at profiling tools.
	            if (typeof property === 'function' && spec.displayName) {
	              proto[name].displayName = spec.displayName + '_' + name;
	            }
	          }
	        }
	      }
	    }
	  }
	}
	
	function mixStaticSpecIntoComponent(Constructor, statics) {
	  if (!statics) {
	    return;
	  }
	  for (var name in statics) {
	    var property = statics[name];
	    if (!statics.hasOwnProperty(name)) {
	      continue;
	    }
	
	    var isReserved = (name in RESERVED_SPEC_KEYS);
	    !!isReserved ?  false ? invariant(false, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name) : invariant(false) : undefined;
	
	    var isInherited = (name in Constructor);
	    !!isInherited ?  false ? invariant(false, 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name) : invariant(false) : undefined;
	    Constructor[name] = property;
	  }
	}
	
	/**
	 * Merge two objects, but throw if both contain the same key.
	 *
	 * @param {object} one The first object, which is mutated.
	 * @param {object} two The second object
	 * @return {object} one after it has been mutated to contain everything in two.
	 */
	function mergeIntoWithNoDuplicateKeys(one, two) {
	  !(one && two && typeof one === 'object' && typeof two === 'object') ?  false ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : invariant(false) : undefined;
	
	  for (var key in two) {
	    if (two.hasOwnProperty(key)) {
	      !(one[key] === undefined) ?  false ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key) : invariant(false) : undefined;
	      one[key] = two[key];
	    }
	  }
	  return one;
	}
	
	/**
	 * Creates a function that invokes two functions and merges their return values.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createMergedResultFunction(one, two) {
	  return function mergedResult() {
	    var a = one.apply(this, arguments);
	    var b = two.apply(this, arguments);
	    if (a == null) {
	      return b;
	    } else if (b == null) {
	      return a;
	    }
	    var c = {};
	    mergeIntoWithNoDuplicateKeys(c, a);
	    mergeIntoWithNoDuplicateKeys(c, b);
	    return c;
	  };
	}
	
	/**
	 * Creates a function that invokes two functions and ignores their return vales.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createChainedFunction(one, two) {
	  return function chainedFunction() {
	    one.apply(this, arguments);
	    two.apply(this, arguments);
	  };
	}
	
	/**
	 * Binds a method to the component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 * @param {function} method Method to be bound.
	 * @return {function} The bound method.
	 */
	function bindAutoBindMethod(component, method) {
	  var boundMethod = method.bind(component);
	  if (false) {
	    boundMethod.__reactBoundContext = component;
	    boundMethod.__reactBoundMethod = method;
	    boundMethod.__reactBoundArguments = null;
	    var componentName = component.constructor.displayName;
	    var _bind = boundMethod.bind;
	    /* eslint-disable block-scoped-var, no-undef */
	    boundMethod.bind = function (newThis) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      // User is trying to bind() an autobound method; we effectively will
	      // ignore the value of "this" that the user is trying to use, so
	      // let's warn.
	      if (newThis !== component && newThis !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : undefined;
	      } else if (!args.length) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : undefined;
	        return boundMethod;
	      }
	      var reboundMethod = _bind.apply(boundMethod, arguments);
	      reboundMethod.__reactBoundContext = component;
	      reboundMethod.__reactBoundMethod = method;
	      reboundMethod.__reactBoundArguments = args;
	      return reboundMethod;
	      /* eslint-enable */
	    };
	  }
	  return boundMethod;
	}
	
	/**
	 * Binds all auto-bound methods in a component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 */
	function bindAutoBindMethods(component) {
	  for (var autoBindKey in component.__reactAutoBindMap) {
	    if (component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
	      var method = component.__reactAutoBindMap[autoBindKey];
	      component[autoBindKey] = bindAutoBindMethod(component, method);
	    }
	  }
	}
	
	/**
	 * Add more to the ReactClass base class. These are all legacy features and
	 * therefore not already part of the modern ReactComponent.
	 */
	var ReactClassMixin = {
	
	  /**
	   * TODO: This will be deprecated because state should always keep a consistent
	   * type signature and the only use case for this, is to avoid that.
	   */
	  replaceState: function (newState, callback) {
	    this.updater.enqueueReplaceState(this, newState);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  },
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function () {
	    return this.updater.isMounted(this);
	  },
	
	  /**
	   * Sets a subset of the props.
	   *
	   * @param {object} partialProps Subset of the next props.
	   * @param {?function} callback Called after props are updated.
	   * @final
	   * @public
	   * @deprecated
	   */
	  setProps: function (partialProps, callback) {
	    if (false) {
	      warnSetProps();
	    }
	    this.updater.enqueueSetProps(this, partialProps);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  },
	
	  /**
	   * Replace all the props.
	   *
	   * @param {object} newProps Subset of the next props.
	   * @param {?function} callback Called after props are updated.
	   * @final
	   * @public
	   * @deprecated
	   */
	  replaceProps: function (newProps, callback) {
	    if (false) {
	      warnSetProps();
	    }
	    this.updater.enqueueReplaceProps(this, newProps);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  }
	};
	
	var ReactClassComponent = function () {};
	assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
	
	/**
	 * Module for creating composite components.
	 *
	 * @class ReactClass
	 */
	var ReactClass = {
	
	  /**
	   * Creates a composite component class given a class specification.
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
	  createClass: function (spec) {
	    var Constructor = function (props, context, updater) {
	      // This constructor is overridden by mocks. The argument is used
	      // by mocks to assert on what gets mounted.
	
	      if (false) {
	        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : undefined;
	      }
	
	      // Wire up auto-binding
	      if (this.__reactAutoBindMap) {
	        bindAutoBindMethods(this);
	      }
	
	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;
	
	      this.state = null;
	
	      // ReactClasses doesn't have constructors. Instead, they use the
	      // getInitialState and componentWillMount methods for initialization.
	
	      var initialState = this.getInitialState ? this.getInitialState() : null;
	      if (false) {
	        // We allow auto-mocks to proceed as if they're returning null.
	        if (typeof initialState === 'undefined' && this.getInitialState._isMockFunction) {
	          // This is probably bad practice. Consider warning here and
	          // deprecating this convenience.
	          initialState = null;
	        }
	      }
	      !(typeof initialState === 'object' && !Array.isArray(initialState)) ?  false ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : invariant(false) : undefined;
	
	      this.state = initialState;
	    };
	    Constructor.prototype = new ReactClassComponent();
	    Constructor.prototype.constructor = Constructor;
	
	    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
	
	    mixSpecIntoComponent(Constructor, spec);
	
	    // Initialize the defaultProps property after all mixins have been merged.
	    if (Constructor.getDefaultProps) {
	      Constructor.defaultProps = Constructor.getDefaultProps();
	    }
	
	    if (false) {
	      // This is a tag to indicate that the use of these method names is ok,
	      // since it's used with createClass. If it's not, then it's likely a
	      // mistake so we'll warn you to use the static property, property
	      // initializer or constructor respectively.
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps.isReactClassApproved = {};
	      }
	      if (Constructor.prototype.getInitialState) {
	        Constructor.prototype.getInitialState.isReactClassApproved = {};
	      }
	    }
	
	    !Constructor.prototype.render ?  false ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : invariant(false) : undefined;
	
	    if (false) {
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : undefined;
	    }
	
	    // Reduce time spent doing lookups by setting these on the prototype.
	    for (var methodName in ReactClassInterface) {
	      if (!Constructor.prototype[methodName]) {
	        Constructor.prototype[methodName] = null;
	      }
	    }
	
	    return Constructor;
	  },
	
	  injection: {
	    injectMixin: function (mixin) {
	      injectedMixins.push(mixin);
	    }
	  }
	
	};
	
	module.exports = ReactClass;

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponent
	 */
	
	'use strict';
	
	var ReactNoopUpdateQueue = __webpack_require__(124);
	
	var canDefineProperty = __webpack_require__(43);
	var emptyObject = __webpack_require__(58);
	var invariant = __webpack_require__(13);
	var warning = __webpack_require__(25);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	ReactComponent.prototype.isReactComponent = {};
	
	/**
	 * Sets a subset of the state. Always use this to mutate
	 * state. You should treat `this.state` as immutable.
	 *
	 * There is no guarantee that `this.state` will be immediately updated, so
	 * accessing `this.state` after calling this method may return the old value.
	 *
	 * There is no guarantee that calls to `setState` will run synchronously,
	 * as they may eventually be batched together.  You can provide an optional
	 * callback that will be executed when the call to setState is actually
	 * completed.
	 *
	 * When a function is provided to setState, it will be called at some point in
	 * the future (not synchronously). It will be called with the up to date
	 * component arguments (state, props, context). These values can be different
	 * from this.* because your function may be called after receiveProps but before
	 * shouldComponentUpdate, and this new state, props, and context will not yet be
	 * assigned to this.
	 *
	 * @param {object|function} partialState Next partial state or function to
	 *        produce next partial state to be merged with current state.
	 * @param {?function} callback Called after state is updated.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.setState = function (partialState, callback) {
	  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ?  false ? invariant(false, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.') : invariant(false) : undefined;
	  if (false) {
	    process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : undefined;
	  }
	  this.updater.enqueueSetState(this, partialState);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback);
	  }
	};
	
	/**
	 * Forces an update. This should only be invoked when it is known with
	 * certainty that we are **not** in a DOM transaction.
	 *
	 * You may want to call this when you know that some deeper aspect of the
	 * component's state has changed but `setState` was not called.
	 *
	 * This will not invoke `shouldComponentUpdate`, but it will invoke
	 * `componentWillUpdate` and `componentDidUpdate`.
	 *
	 * @param {?function} callback Called after update is complete.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback);
	  }
	};
	
	/**
	 * Deprecated APIs. These APIs used to exist on classic React classes but since
	 * we would like to deprecate them, we're not going to move them over to this
	 * modern base class. Instead, we define a getter that warns if it's accessed.
	 */
	if (false) {
	  var deprecatedAPIs = {
	    getDOMNode: ['getDOMNode', 'Use ReactDOM.findDOMNode(component) instead.'],
	    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
	    replaceProps: ['replaceProps', 'Instead, call render again at the top level.'],
	    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'],
	    setProps: ['setProps', 'Instead, call render again at the top level.']
	  };
	  var defineDeprecationWarning = function (methodName, info) {
	    if (canDefineProperty) {
	      Object.defineProperty(ReactComponent.prototype, methodName, {
	        get: function () {
	          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : undefined;
	          return undefined;
	        }
	      });
	    }
	  };
	  for (var fnName in deprecatedAPIs) {
	    if (deprecatedAPIs.hasOwnProperty(fnName)) {
	      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	    }
	  }
	}
	
	module.exports = ReactComponent;

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNoopUpdateQueue
	 */
	
	'use strict';
	
	var warning = __webpack_require__(25);
	
	function warnTDZ(publicInstance, callerName) {
	  if (false) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor && publicInstance.constructor.displayName || '') : undefined;
	  }
	}
	
	/**
	 * This is the abstract API for an update queue.
	 */
	var ReactNoopUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    return false;
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback) {},
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    warnTDZ(publicInstance, 'forceUpdate');
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    warnTDZ(publicInstance, 'replaceState');
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    warnTDZ(publicInstance, 'setState');
	  },
	
	  /**
	   * Sets a subset of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialProps Subset of the next props.
	   * @internal
	   */
	  enqueueSetProps: function (publicInstance, partialProps) {
	    warnTDZ(publicInstance, 'setProps');
	  },
	
	  /**
	   * Replaces all of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} props New props.
	   * @internal
	   */
	  enqueueReplaceProps: function (publicInstance, props) {
	    warnTDZ(publicInstance, 'replaceProps');
	  }
	
	};
	
	module.exports = ReactNoopUpdateQueue;

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconcileTransaction
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CallbackQueue = __webpack_require__(55);
	var PooledClass = __webpack_require__(56);
	var ReactBrowserEventEmitter = __webpack_require__(29);
	var ReactDOMFeatureFlags = __webpack_require__(41);
	var ReactInputSelection = __webpack_require__(126);
	var Transaction = __webpack_require__(57);
	
	var assign = __webpack_require__(39);
	
	/**
	 * Ensures that, when possible, the selection range (currently selected text
	 * input) is not disturbed by performing the transaction.
	 */
	var SELECTION_RESTORATION = {
	  /**
	   * @return {Selection} Selection information.
	   */
	  initialize: ReactInputSelection.getSelectionInformation,
	  /**
	   * @param {Selection} sel Selection information returned from `initialize`.
	   */
	  close: ReactInputSelection.restoreSelection
	};
	
	/**
	 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
	 * high level DOM manipulations (like temporarily removing a text input from the
	 * DOM).
	 */
	var EVENT_SUPPRESSION = {
	  /**
	   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
	   * the reconciliation.
	   */
	  initialize: function () {
	    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
	    ReactBrowserEventEmitter.setEnabled(false);
	    return currentlyEnabled;
	  },
	
	  /**
	   * @param {boolean} previouslyEnabled Enabled status of
	   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
	   *   restores the previous value.
	   */
	  close: function (previouslyEnabled) {
	    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
	  }
	};
	
	/**
	 * Provides a queue for collecting `componentDidMount` and
	 * `componentDidUpdate` callbacks during the the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function () {
	    this.reactMountReady.reset();
	  },
	
	  /**
	   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
	   */
	  close: function () {
	    this.reactMountReady.notifyAll();
	  }
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
	
	/**
	 * Currently:
	 * - The order that these are listed in the transaction is critical:
	 * - Suppresses events.
	 * - Restores selection range.
	 *
	 * Future:
	 * - Restore document/overflow scroll positions that were unintentionally
	 *   modified via DOM insertions above the top viewport boundary.
	 * - Implement/integrate with customized constraint based layout system and keep
	 *   track of which dimensions must be remeasured.
	 *
	 * @class ReactReconcileTransaction
	 */
	function ReactReconcileTransaction(forceHTML) {
	  this.reinitializeTransaction();
	  // Only server-side rendering really needs this option (see
	  // `ReactServerRendering`), but server-side uses
	  // `ReactServerRenderingTransaction` instead. This option is here so that it's
	  // accessible and defaults to false when `ReactDOMComponent` and
	  // `ReactTextComponent` checks it in `mountComponent`.`
	  this.renderToStaticMarkup = false;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = !forceHTML && ReactDOMFeatureFlags.useCreateElement;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array<object>} List of operation wrap procedures.
	   *   TODO: convert to array<TransactionWrapper>
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return this.reactMountReady;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactReconcileTransaction);
	
	module.exports = ReactReconcileTransaction;

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInputSelection
	 */
	
	'use strict';
	
	var ReactDOMSelection = __webpack_require__(127);
	
	var containsNode = __webpack_require__(59);
	var focusNode = __webpack_require__(95);
	var getActiveElement = __webpack_require__(129);
	
	function isInDocument(node) {
	  return containsNode(document.documentElement, node);
	}
	
	/**
	 * @ReactInputSelection: React input selection module. Based on Selection.js,
	 * but modified to be suitable for react and has a couple of bug fixes (doesn't
	 * assume buttons have range selections allowed).
	 * Input selection module for React.
	 */
	var ReactInputSelection = {
	
	  hasSelectionCapabilities: function (elem) {
	    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
	  },
	
	  getSelectionInformation: function () {
	    var focusedElem = getActiveElement();
	    return {
	      focusedElem: focusedElem,
	      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
	    };
	  },
	
	  /**
	   * @restoreSelection: If any selection information was potentially lost,
	   * restore it. This is useful when performing operations that could remove dom
	   * nodes and place them back in, resulting in focus being lost.
	   */
	  restoreSelection: function (priorSelectionInformation) {
	    var curFocusedElem = getActiveElement();
	    var priorFocusedElem = priorSelectionInformation.focusedElem;
	    var priorSelectionRange = priorSelectionInformation.selectionRange;
	    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
	      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
	        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
	      }
	      focusNode(priorFocusedElem);
	    }
	  },
	
	  /**
	   * @getSelection: Gets the selection bounds of a focused textarea, input or
	   * contentEditable node.
	   * -@input: Look up selection bounds of this input
	   * -@return {start: selectionStart, end: selectionEnd}
	   */
	  getSelection: function (input) {
	    var selection;
	
	    if ('selectionStart' in input) {
	      // Modern browser with input or textarea.
	      selection = {
	        start: input.selectionStart,
	        end: input.selectionEnd
	      };
	    } else if (document.selection && (input.nodeName && input.nodeName.toLowerCase() === 'input')) {
	      // IE8 input.
	      var range = document.selection.createRange();
	      // There can only be one selection per document in IE, so it must
	      // be in our element.
	      if (range.parentElement() === input) {
	        selection = {
	          start: -range.moveStart('character', -input.value.length),
	          end: -range.moveEnd('character', -input.value.length)
	        };
	      }
	    } else {
	      // Content editable or old IE textarea.
	      selection = ReactDOMSelection.getOffsets(input);
	    }
	
	    return selection || { start: 0, end: 0 };
	  },
	
	  /**
	   * @setSelection: Sets the selection bounds of a textarea or input and focuses
	   * the input.
	   * -@input     Set selection bounds of this input or textarea
	   * -@offsets   Object of same form that is returned from get*
	   */
	  setSelection: function (input, offsets) {
	    var start = offsets.start;
	    var end = offsets.end;
	    if (typeof end === 'undefined') {
	      end = start;
	    }
	
	    if ('selectionStart' in input) {
	      input.selectionStart = start;
	      input.selectionEnd = Math.min(end, input.value.length);
	    } else if (document.selection && (input.nodeName && input.nodeName.toLowerCase() === 'input')) {
	      var range = input.createTextRange();
	      range.collapse(true);
	      range.moveStart('character', start);
	      range.moveEnd('character', end - start);
	      range.select();
	    } else {
	      ReactDOMSelection.setOffsets(input, offsets);
	    }
	  }
	};
	
	module.exports = ReactInputSelection;

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelection
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var getNodeForCharacterOffset = __webpack_require__(128);
	var getTextContentAccessor = __webpack_require__(75);
	
	/**
	 * While `isCollapsed` is available on the Selection object and `collapsed`
	 * is available on the Range object, IE11 sometimes gets them wrong.
	 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
	 */
	function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
	  return anchorNode === focusNode && anchorOffset === focusOffset;
	}
	
	/**
	 * Get the appropriate anchor and focus node/offset pairs for IE.
	 *
	 * The catch here is that IE's selection API doesn't provide information
	 * about whether the selection is forward or backward, so we have to
	 * behave as though it's always forward.
	 *
	 * IE text differs from modern selection in that it behaves as though
	 * block elements end with a new line. This means character offsets will
	 * differ between the two APIs.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getIEOffsets(node) {
	  var selection = document.selection;
	  var selectedRange = selection.createRange();
	  var selectedLength = selectedRange.text.length;
	
	  // Duplicate selection so we can move range without breaking user selection.
	  var fromStart = selectedRange.duplicate();
	  fromStart.moveToElementText(node);
	  fromStart.setEndPoint('EndToStart', selectedRange);
	
	  var startOffset = fromStart.text.length;
	  var endOffset = startOffset + selectedLength;
	
	  return {
	    start: startOffset,
	    end: endOffset
	  };
	}
	
	/**
	 * @param {DOMElement} node
	 * @return {?object}
	 */
	function getModernOffsets(node) {
	  var selection = window.getSelection && window.getSelection();
	
	  if (!selection || selection.rangeCount === 0) {
	    return null;
	  }
	
	  var anchorNode = selection.anchorNode;
	  var anchorOffset = selection.anchorOffset;
	  var focusNode = selection.focusNode;
	  var focusOffset = selection.focusOffset;
	
	  var currentRange = selection.getRangeAt(0);
	
	  // In Firefox, range.startContainer and range.endContainer can be "anonymous
	  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
	  // divs do not seem to expose properties, triggering a "Permission denied
	  // error" if any of its properties are accessed. The only seemingly possible
	  // way to avoid erroring is to access a property that typically works for
	  // non-anonymous divs and catch any error that may otherwise arise. See
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
	  try {
	    /* eslint-disable no-unused-expressions */
	    currentRange.startContainer.nodeType;
	    currentRange.endContainer.nodeType;
	    /* eslint-enable no-unused-expressions */
	  } catch (e) {
	    return null;
	  }
	
	  // If the node and offset values are the same, the selection is collapsed.
	  // `Selection.isCollapsed` is available natively, but IE sometimes gets
	  // this value wrong.
	  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
	
	  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
	
	  var tempRange = currentRange.cloneRange();
	  tempRange.selectNodeContents(node);
	  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
	
	  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
	
	  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
	  var end = start + rangeLength;
	
	  // Detect whether the selection is backward.
	  var detectionRange = document.createRange();
	  detectionRange.setStart(anchorNode, anchorOffset);
	  detectionRange.setEnd(focusNode, focusOffset);
	  var isBackward = detectionRange.collapsed;
	
	  return {
	    start: isBackward ? end : start,
	    end: isBackward ? start : end
	  };
	}
	
	/**
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setIEOffsets(node, offsets) {
	  var range = document.selection.createRange().duplicate();
	  var start, end;
	
	  if (typeof offsets.end === 'undefined') {
	    start = offsets.start;
	    end = start;
	  } else if (offsets.start > offsets.end) {
	    start = offsets.end;
	    end = offsets.start;
	  } else {
	    start = offsets.start;
	    end = offsets.end;
	  }
	
	  range.moveToElementText(node);
	  range.moveStart('character', start);
	  range.setEndPoint('EndToStart', range);
	  range.moveEnd('character', end - start);
	  range.select();
	}
	
	/**
	 * In modern non-IE browsers, we can support both forward and backward
	 * selections.
	 *
	 * Note: IE10+ supports the Selection object, but it does not support
	 * the `extend` method, which means that even in modern IE, it's not possible
	 * to programatically create a backward selection. Thus, for all IE
	 * versions, we use the old IE API to create our selections.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setModernOffsets(node, offsets) {
	  if (!window.getSelection) {
	    return;
	  }
	
	  var selection = window.getSelection();
	  var length = node[getTextContentAccessor()].length;
	  var start = Math.min(offsets.start, length);
	  var end = typeof offsets.end === 'undefined' ? start : Math.min(offsets.end, length);
	
	  // IE 11 uses modern selection, but doesn't support the extend method.
	  // Flip backward selections, so we can set with a single range.
	  if (!selection.extend && start > end) {
	    var temp = end;
	    end = start;
	    start = temp;
	  }
	
	  var startMarker = getNodeForCharacterOffset(node, start);
	  var endMarker = getNodeForCharacterOffset(node, end);
	
	  if (startMarker && endMarker) {
	    var range = document.createRange();
	    range.setStart(startMarker.node, startMarker.offset);
	    selection.removeAllRanges();
	
	    if (start > end) {
	      selection.addRange(range);
	      selection.extend(endMarker.node, endMarker.offset);
	    } else {
	      range.setEnd(endMarker.node, endMarker.offset);
	      selection.addRange(range);
	    }
	  }
	}
	
	var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);
	
	var ReactDOMSelection = {
	  /**
	   * @param {DOMElement} node
	   */
	  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
	
	  /**
	   * @param {DOMElement|DOMTextNode} node
	   * @param {object} offsets
	   */
	  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
	};
	
	module.exports = ReactDOMSelection;

/***/ },
/* 128 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getNodeForCharacterOffset
	 */
	
	'use strict';
	
	/**
	 * Given any node return the first leaf node without children.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {DOMElement|DOMTextNode}
	 */
	function getLeafNode(node) {
	  while (node && node.firstChild) {
	    node = node.firstChild;
	  }
	  return node;
	}
	
	/**
	 * Get the next sibling within a container. This will walk up the
	 * DOM if a node's siblings have been exhausted.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {?DOMElement|DOMTextNode}
	 */
	function getSiblingNode(node) {
	  while (node) {
	    if (node.nextSibling) {
	      return node.nextSibling;
	    }
	    node = node.parentNode;
	  }
	}
	
	/**
	 * Get object describing the nodes which contain characters at offset.
	 *
	 * @param {DOMElement|DOMTextNode} root
	 * @param {number} offset
	 * @return {?object}
	 */
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  var nodeStart = 0;
	  var nodeEnd = 0;
	
	  while (node) {
	    if (node.nodeType === 3) {
	      nodeEnd = nodeStart + node.textContent.length;
	
	      if (nodeStart <= offset && nodeEnd >= offset) {
	        return {
	          node: node,
	          offset: offset - nodeStart
	        };
	      }
	
	      nodeStart = nodeEnd;
	    }
	
	    node = getLeafNode(getSiblingNode(node));
	  }
	}
	
	module.exports = getNodeForCharacterOffset;

/***/ },
/* 129 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getActiveElement
	 * @typechecks
	 */
	
	/* eslint-disable fb-www/typeof-undefined */
	
	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document or document body is not
	 * yet defined.
	 */
	'use strict';
	
	function getActiveElement() /*?DOMElement*/{
	  if (typeof document === 'undefined') {
	    return null;
	  }
	  try {
	    return document.activeElement || document.body;
	  } catch (e) {
	    return document.body;
	  }
	}
	
	module.exports = getActiveElement;

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SelectEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(30);
	var EventPropagators = __webpack_require__(73);
	var ExecutionEnvironment = __webpack_require__(9);
	var ReactInputSelection = __webpack_require__(126);
	var SyntheticEvent = __webpack_require__(77);
	
	var getActiveElement = __webpack_require__(129);
	var isTextInputElement = __webpack_require__(82);
	var keyOf = __webpack_require__(79);
	var shallowEqual = __webpack_require__(117);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;
	
	var eventTypes = {
	  select: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSelect: null }),
	      captured: keyOf({ onSelectCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	var activeElement = null;
	var activeElementID = null;
	var lastSelection = null;
	var mouseDown = false;
	
	// Track whether a listener exists for this plugin. If none exist, we do
	// not extract events.
	var hasListener = false;
	var ON_SELECT_KEY = keyOf({ onSelect: null });
	
	/**
	 * Get an object which is a unique representation of the current selection.
	 *
	 * The return value will not be consistent across nodes or browsers, but
	 * two identical selections on the same node will return identical objects.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getSelection(node) {
	  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
	    return {
	      start: node.selectionStart,
	      end: node.selectionEnd
	    };
	  } else if (window.getSelection) {
	    var selection = window.getSelection();
	    return {
	      anchorNode: selection.anchorNode,
	      anchorOffset: selection.anchorOffset,
	      focusNode: selection.focusNode,
	      focusOffset: selection.focusOffset
	    };
	  } else if (document.selection) {
	    var range = document.selection.createRange();
	    return {
	      parentElement: range.parentElement(),
	      text: range.text,
	      top: range.boundingTop,
	      left: range.boundingLeft
	    };
	  }
	}
	
	/**
	 * Poll selection to see whether it's changed.
	 *
	 * @param {object} nativeEvent
	 * @return {?SyntheticEvent}
	 */
	function constructSelectEvent(nativeEvent, nativeEventTarget) {
	  // Ensure we have the right element, and that the user is not dragging a
	  // selection (this matches native `select` event behavior). In HTML5, select
	  // fires only on input and textarea thus if there's no focused element we
	  // won't dispatch.
	  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
	    return null;
	  }
	
	  // Only fire when selection has actually changed.
	  var currentSelection = getSelection(activeElement);
	  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
	    lastSelection = currentSelection;
	
	    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent, nativeEventTarget);
	
	    syntheticEvent.type = 'select';
	    syntheticEvent.target = activeElement;
	
	    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
	
	    return syntheticEvent;
	  }
	
	  return null;
	}
	
	/**
	 * This plugin creates an `onSelect` event that normalizes select events
	 * across form elements.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - contentEditable
	 *
	 * This differs from native browser implementations in the following ways:
	 * - Fires on contentEditable fields as well as inputs.
	 * - Fires for collapsed selection.
	 * - Fires after user input.
	 */
	var SelectEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    if (!hasListener) {
	      return null;
	    }
	
	    switch (topLevelType) {
	      // Track the input node that has focus.
	      case topLevelTypes.topFocus:
	        if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === 'true') {
	          activeElement = topLevelTarget;
	          activeElementID = topLevelTargetID;
	          lastSelection = null;
	        }
	        break;
	      case topLevelTypes.topBlur:
	        activeElement = null;
	        activeElementID = null;
	        lastSelection = null;
	        break;
	
	      // Don't fire the event while the user is dragging. This matches the
	      // semantics of the native select event.
	      case topLevelTypes.topMouseDown:
	        mouseDown = true;
	        break;
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topMouseUp:
	        mouseDown = false;
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	
	      // Chrome and IE fire non-standard event when selection is changed (and
	      // sometimes when it hasn't). IE's event fires out of order with respect
	      // to key and input events on deletion, so we discard it.
	      //
	      // Firefox doesn't support selectionchange, so check selection status
	      // after each key entry. The selection changes after keydown and before
	      // keyup, but we check on keydown as well in the case of holding down a
	      // key, when multiple keydown events are fired but only one keyup is.
	      // This is also our approach for IE handling, for the reason above.
	      case topLevelTypes.topSelectionChange:
	        if (skipSelectionChangeEvent) {
	          break;
	        }
	      // falls through
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	    }
	
	    return null;
	  },
	
	  didPutListener: function (id, registrationName, listener) {
	    if (registrationName === ON_SELECT_KEY) {
	      hasListener = true;
	    }
	  }
	};
	
	module.exports = SelectEventPlugin;

/***/ },
/* 131 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ServerReactRootIndex
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Size of the reactRoot ID space. We generate random numbers for React root
	 * IDs and if there's a collision the events and DOM update system will
	 * get confused. In the future we need a way to generate GUIDs but for
	 * now this will work on a smaller scale.
	 */
	var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);
	
	var ServerReactRootIndex = {
	  createReactRootIndex: function () {
	    return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
	  }
	};
	
	module.exports = ServerReactRootIndex;

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SimpleEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(30);
	var EventListener = __webpack_require__(119);
	var EventPropagators = __webpack_require__(73);
	var ReactMount = __webpack_require__(28);
	var SyntheticClipboardEvent = __webpack_require__(133);
	var SyntheticEvent = __webpack_require__(77);
	var SyntheticFocusEvent = __webpack_require__(134);
	var SyntheticKeyboardEvent = __webpack_require__(135);
	var SyntheticMouseEvent = __webpack_require__(86);
	var SyntheticDragEvent = __webpack_require__(138);
	var SyntheticTouchEvent = __webpack_require__(139);
	var SyntheticUIEvent = __webpack_require__(87);
	var SyntheticWheelEvent = __webpack_require__(140);
	
	var emptyFunction = __webpack_require__(15);
	var getEventCharCode = __webpack_require__(136);
	var invariant = __webpack_require__(13);
	var keyOf = __webpack_require__(79);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  abort: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAbort: true }),
	      captured: keyOf({ onAbortCapture: true })
	    }
	  },
	  blur: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBlur: true }),
	      captured: keyOf({ onBlurCapture: true })
	    }
	  },
	  canPlay: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlay: true }),
	      captured: keyOf({ onCanPlayCapture: true })
	    }
	  },
	  canPlayThrough: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlayThrough: true }),
	      captured: keyOf({ onCanPlayThroughCapture: true })
	    }
	  },
	  click: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onClick: true }),
	      captured: keyOf({ onClickCapture: true })
	    }
	  },
	  contextMenu: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onContextMenu: true }),
	      captured: keyOf({ onContextMenuCapture: true })
	    }
	  },
	  copy: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCopy: true }),
	      captured: keyOf({ onCopyCapture: true })
	    }
	  },
	  cut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCut: true }),
	      captured: keyOf({ onCutCapture: true })
	    }
	  },
	  doubleClick: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDoubleClick: true }),
	      captured: keyOf({ onDoubleClickCapture: true })
	    }
	  },
	  drag: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrag: true }),
	      captured: keyOf({ onDragCapture: true })
	    }
	  },
	  dragEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnd: true }),
	      captured: keyOf({ onDragEndCapture: true })
	    }
	  },
	  dragEnter: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnter: true }),
	      captured: keyOf({ onDragEnterCapture: true })
	    }
	  },
	  dragExit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragExit: true }),
	      captured: keyOf({ onDragExitCapture: true })
	    }
	  },
	  dragLeave: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragLeave: true }),
	      captured: keyOf({ onDragLeaveCapture: true })
	    }
	  },
	  dragOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragOver: true }),
	      captured: keyOf({ onDragOverCapture: true })
	    }
	  },
	  dragStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragStart: true }),
	      captured: keyOf({ onDragStartCapture: true })
	    }
	  },
	  drop: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrop: true }),
	      captured: keyOf({ onDropCapture: true })
	    }
	  },
	  durationChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDurationChange: true }),
	      captured: keyOf({ onDurationChangeCapture: true })
	    }
	  },
	  emptied: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEmptied: true }),
	      captured: keyOf({ onEmptiedCapture: true })
	    }
	  },
	  encrypted: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEncrypted: true }),
	      captured: keyOf({ onEncryptedCapture: true })
	    }
	  },
	  ended: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEnded: true }),
	      captured: keyOf({ onEndedCapture: true })
	    }
	  },
	  error: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onError: true }),
	      captured: keyOf({ onErrorCapture: true })
	    }
	  },
	  focus: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onFocus: true }),
	      captured: keyOf({ onFocusCapture: true })
	    }
	  },
	  input: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onInput: true }),
	      captured: keyOf({ onInputCapture: true })
	    }
	  },
	  keyDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyDown: true }),
	      captured: keyOf({ onKeyDownCapture: true })
	    }
	  },
	  keyPress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyPress: true }),
	      captured: keyOf({ onKeyPressCapture: true })
	    }
	  },
	  keyUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyUp: true }),
	      captured: keyOf({ onKeyUpCapture: true })
	    }
	  },
	  load: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoad: true }),
	      captured: keyOf({ onLoadCapture: true })
	    }
	  },
	  loadedData: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedData: true }),
	      captured: keyOf({ onLoadedDataCapture: true })
	    }
	  },
	  loadedMetadata: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedMetadata: true }),
	      captured: keyOf({ onLoadedMetadataCapture: true })
	    }
	  },
	  loadStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadStart: true }),
	      captured: keyOf({ onLoadStartCapture: true })
	    }
	  },
	  // Note: We do not allow listening to mouseOver events. Instead, use the
	  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
	  mouseDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseDown: true }),
	      captured: keyOf({ onMouseDownCapture: true })
	    }
	  },
	  mouseMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseMove: true }),
	      captured: keyOf({ onMouseMoveCapture: true })
	    }
	  },
	  mouseOut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOut: true }),
	      captured: keyOf({ onMouseOutCapture: true })
	    }
	  },
	  mouseOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOver: true }),
	      captured: keyOf({ onMouseOverCapture: true })
	    }
	  },
	  mouseUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseUp: true }),
	      captured: keyOf({ onMouseUpCapture: true })
	    }
	  },
	  paste: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPaste: true }),
	      captured: keyOf({ onPasteCapture: true })
	    }
	  },
	  pause: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPause: true }),
	      captured: keyOf({ onPauseCapture: true })
	    }
	  },
	  play: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlay: true }),
	      captured: keyOf({ onPlayCapture: true })
	    }
	  },
	  playing: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlaying: true }),
	      captured: keyOf({ onPlayingCapture: true })
	    }
	  },
	  progress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onProgress: true }),
	      captured: keyOf({ onProgressCapture: true })
	    }
	  },
	  rateChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onRateChange: true }),
	      captured: keyOf({ onRateChangeCapture: true })
	    }
	  },
	  reset: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onReset: true }),
	      captured: keyOf({ onResetCapture: true })
	    }
	  },
	  scroll: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onScroll: true }),
	      captured: keyOf({ onScrollCapture: true })
	    }
	  },
	  seeked: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeked: true }),
	      captured: keyOf({ onSeekedCapture: true })
	    }
	  },
	  seeking: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeking: true }),
	      captured: keyOf({ onSeekingCapture: true })
	    }
	  },
	  stalled: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onStalled: true }),
	      captured: keyOf({ onStalledCapture: true })
	    }
	  },
	  submit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSubmit: true }),
	      captured: keyOf({ onSubmitCapture: true })
	    }
	  },
	  suspend: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSuspend: true }),
	      captured: keyOf({ onSuspendCapture: true })
	    }
	  },
	  timeUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTimeUpdate: true }),
	      captured: keyOf({ onTimeUpdateCapture: true })
	    }
	  },
	  touchCancel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchCancel: true }),
	      captured: keyOf({ onTouchCancelCapture: true })
	    }
	  },
	  touchEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchEnd: true }),
	      captured: keyOf({ onTouchEndCapture: true })
	    }
	  },
	  touchMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchMove: true }),
	      captured: keyOf({ onTouchMoveCapture: true })
	    }
	  },
	  touchStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchStart: true }),
	      captured: keyOf({ onTouchStartCapture: true })
	    }
	  },
	  volumeChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onVolumeChange: true }),
	      captured: keyOf({ onVolumeChangeCapture: true })
	    }
	  },
	  waiting: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWaiting: true }),
	      captured: keyOf({ onWaitingCapture: true })
	    }
	  },
	  wheel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWheel: true }),
	      captured: keyOf({ onWheelCapture: true })
	    }
	  }
	};
	
	var topLevelEventsToDispatchConfig = {
	  topAbort: eventTypes.abort,
	  topBlur: eventTypes.blur,
	  topCanPlay: eventTypes.canPlay,
	  topCanPlayThrough: eventTypes.canPlayThrough,
	  topClick: eventTypes.click,
	  topContextMenu: eventTypes.contextMenu,
	  topCopy: eventTypes.copy,
	  topCut: eventTypes.cut,
	  topDoubleClick: eventTypes.doubleClick,
	  topDrag: eventTypes.drag,
	  topDragEnd: eventTypes.dragEnd,
	  topDragEnter: eventTypes.dragEnter,
	  topDragExit: eventTypes.dragExit,
	  topDragLeave: eventTypes.dragLeave,
	  topDragOver: eventTypes.dragOver,
	  topDragStart: eventTypes.dragStart,
	  topDrop: eventTypes.drop,
	  topDurationChange: eventTypes.durationChange,
	  topEmptied: eventTypes.emptied,
	  topEncrypted: eventTypes.encrypted,
	  topEnded: eventTypes.ended,
	  topError: eventTypes.error,
	  topFocus: eventTypes.focus,
	  topInput: eventTypes.input,
	  topKeyDown: eventTypes.keyDown,
	  topKeyPress: eventTypes.keyPress,
	  topKeyUp: eventTypes.keyUp,
	  topLoad: eventTypes.load,
	  topLoadedData: eventTypes.loadedData,
	  topLoadedMetadata: eventTypes.loadedMetadata,
	  topLoadStart: eventTypes.loadStart,
	  topMouseDown: eventTypes.mouseDown,
	  topMouseMove: eventTypes.mouseMove,
	  topMouseOut: eventTypes.mouseOut,
	  topMouseOver: eventTypes.mouseOver,
	  topMouseUp: eventTypes.mouseUp,
	  topPaste: eventTypes.paste,
	  topPause: eventTypes.pause,
	  topPlay: eventTypes.play,
	  topPlaying: eventTypes.playing,
	  topProgress: eventTypes.progress,
	  topRateChange: eventTypes.rateChange,
	  topReset: eventTypes.reset,
	  topScroll: eventTypes.scroll,
	  topSeeked: eventTypes.seeked,
	  topSeeking: eventTypes.seeking,
	  topStalled: eventTypes.stalled,
	  topSubmit: eventTypes.submit,
	  topSuspend: eventTypes.suspend,
	  topTimeUpdate: eventTypes.timeUpdate,
	  topTouchCancel: eventTypes.touchCancel,
	  topTouchEnd: eventTypes.touchEnd,
	  topTouchMove: eventTypes.touchMove,
	  topTouchStart: eventTypes.touchStart,
	  topVolumeChange: eventTypes.volumeChange,
	  topWaiting: eventTypes.waiting,
	  topWheel: eventTypes.wheel
	};
	
	for (var type in topLevelEventsToDispatchConfig) {
	  topLevelEventsToDispatchConfig[type].dependencies = [type];
	}
	
	var ON_CLICK_KEY = keyOf({ onClick: null });
	var onClickListeners = {};
	
	var SimpleEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
	    if (!dispatchConfig) {
	      return null;
	    }
	    var EventConstructor;
	    switch (topLevelType) {
	      case topLevelTypes.topAbort:
	      case topLevelTypes.topCanPlay:
	      case topLevelTypes.topCanPlayThrough:
	      case topLevelTypes.topDurationChange:
	      case topLevelTypes.topEmptied:
	      case topLevelTypes.topEncrypted:
	      case topLevelTypes.topEnded:
	      case topLevelTypes.topError:
	      case topLevelTypes.topInput:
	      case topLevelTypes.topLoad:
	      case topLevelTypes.topLoadedData:
	      case topLevelTypes.topLoadedMetadata:
	      case topLevelTypes.topLoadStart:
	      case topLevelTypes.topPause:
	      case topLevelTypes.topPlay:
	      case topLevelTypes.topPlaying:
	      case topLevelTypes.topProgress:
	      case topLevelTypes.topRateChange:
	      case topLevelTypes.topReset:
	      case topLevelTypes.topSeeked:
	      case topLevelTypes.topSeeking:
	      case topLevelTypes.topStalled:
	      case topLevelTypes.topSubmit:
	      case topLevelTypes.topSuspend:
	      case topLevelTypes.topTimeUpdate:
	      case topLevelTypes.topVolumeChange:
	      case topLevelTypes.topWaiting:
	        // HTML Events
	        // @see http://www.w3.org/TR/html5/index.html#events-0
	        EventConstructor = SyntheticEvent;
	        break;
	      case topLevelTypes.topKeyPress:
	        // FireFox creates a keypress event for function keys too. This removes
	        // the unwanted keypress events. Enter is however both printable and
	        // non-printable. One would expect Tab to be as well (but it isn't).
	        if (getEventCharCode(nativeEvent) === 0) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        EventConstructor = SyntheticKeyboardEvent;
	        break;
	      case topLevelTypes.topBlur:
	      case topLevelTypes.topFocus:
	        EventConstructor = SyntheticFocusEvent;
	        break;
	      case topLevelTypes.topClick:
	        // Firefox creates a click event on right mouse clicks. This removes the
	        // unwanted click events.
	        if (nativeEvent.button === 2) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topDoubleClick:
	      case topLevelTypes.topMouseDown:
	      case topLevelTypes.topMouseMove:
	      case topLevelTypes.topMouseOut:
	      case topLevelTypes.topMouseOver:
	      case topLevelTypes.topMouseUp:
	        EventConstructor = SyntheticMouseEvent;
	        break;
	      case topLevelTypes.topDrag:
	      case topLevelTypes.topDragEnd:
	      case topLevelTypes.topDragEnter:
	      case topLevelTypes.topDragExit:
	      case topLevelTypes.topDragLeave:
	      case topLevelTypes.topDragOver:
	      case topLevelTypes.topDragStart:
	      case topLevelTypes.topDrop:
	        EventConstructor = SyntheticDragEvent;
	        break;
	      case topLevelTypes.topTouchCancel:
	      case topLevelTypes.topTouchEnd:
	      case topLevelTypes.topTouchMove:
	      case topLevelTypes.topTouchStart:
	        EventConstructor = SyntheticTouchEvent;
	        break;
	      case topLevelTypes.topScroll:
	        EventConstructor = SyntheticUIEvent;
	        break;
	      case topLevelTypes.topWheel:
	        EventConstructor = SyntheticWheelEvent;
	        break;
	      case topLevelTypes.topCopy:
	      case topLevelTypes.topCut:
	      case topLevelTypes.topPaste:
	        EventConstructor = SyntheticClipboardEvent;
	        break;
	    }
	    !EventConstructor ?  false ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : invariant(false) : undefined;
	    var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent, nativeEventTarget);
	    EventPropagators.accumulateTwoPhaseDispatches(event);
	    return event;
	  },
	
	  didPutListener: function (id, registrationName, listener) {
	    // Mobile Safari does not fire properly bubble click events on
	    // non-interactive elements, which means delegated click listeners do not
	    // fire. The workaround for this bug involves attaching an empty click
	    // listener on the target node.
	    if (registrationName === ON_CLICK_KEY) {
	      var node = ReactMount.getNode(id);
	      if (!onClickListeners[id]) {
	        onClickListeners[id] = EventListener.listen(node, 'click', emptyFunction);
	      }
	    }
	  },
	
	  willDeleteListener: function (id, registrationName) {
	    if (registrationName === ON_CLICK_KEY) {
	      onClickListeners[id].remove();
	      delete onClickListeners[id];
	    }
	  }
	
	};
	
	module.exports = SimpleEventPlugin;

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticClipboardEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(77);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/clipboard-apis/
	 */
	var ClipboardEventInterface = {
	  clipboardData: function (event) {
	    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
	
	module.exports = SyntheticClipboardEvent;

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticFocusEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(87);
	
	/**
	 * @interface FocusEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var FocusEventInterface = {
	  relatedTarget: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
	
	module.exports = SyntheticFocusEvent;

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticKeyboardEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(87);
	
	var getEventCharCode = __webpack_require__(136);
	var getEventKey = __webpack_require__(137);
	var getEventModifierState = __webpack_require__(88);
	
	/**
	 * @interface KeyboardEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var KeyboardEventInterface = {
	  key: getEventKey,
	  location: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  repeat: null,
	  locale: null,
	  getModifierState: getEventModifierState,
	  // Legacy Interface
	  charCode: function (event) {
	    // `charCode` is the result of a KeyPress event and represents the value of
	    // the actual printable character.
	
	    // KeyPress is deprecated, but its replacement is not yet final and not
	    // implemented in any major browser. Only KeyPress has charCode.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    return 0;
	  },
	  keyCode: function (event) {
	    // `keyCode` is the result of a KeyDown/Up event and represents the value of
	    // physical keyboard key.
	
	    // The actual meaning of the value depends on the users' keyboard layout
	    // which cannot be detected. Assuming that it is a US keyboard layout
	    // provides a surprisingly accurate mapping for US and European users.
	    // Due to this, it is left to the user to implement at this time.
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  },
	  which: function (event) {
	    // `which` is an alias for either `keyCode` or `charCode` depending on the
	    // type of the event.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
	
	module.exports = SyntheticKeyboardEvent;

/***/ },
/* 136 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventCharCode
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * `charCode` represents the actual "character code" and is safe to use with
	 * `String.fromCharCode`. As such, only keys that correspond to printable
	 * characters produce a valid `charCode`, the only exception to this is Enter.
	 * The Tab-key is considered non-printable and does not have a `charCode`,
	 * presumably because it does not produce a tab-character in browsers.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {number} Normalized `charCode` property.
	 */
	function getEventCharCode(nativeEvent) {
	  var charCode;
	  var keyCode = nativeEvent.keyCode;
	
	  if ('charCode' in nativeEvent) {
	    charCode = nativeEvent.charCode;
	
	    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
	    if (charCode === 0 && keyCode === 13) {
	      charCode = 13;
	    }
	  } else {
	    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
	    charCode = keyCode;
	  }
	
	  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
	  // Must not discard the (non-)printable Enter-key.
	  if (charCode >= 32 || charCode === 13) {
	    return charCode;
	  }
	
	  return 0;
	}
	
	module.exports = getEventCharCode;

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventKey
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var getEventCharCode = __webpack_require__(136);
	
	/**
	 * Normalization of deprecated HTML5 `key` values
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var normalizeKey = {
	  'Esc': 'Escape',
	  'Spacebar': ' ',
	  'Left': 'ArrowLeft',
	  'Up': 'ArrowUp',
	  'Right': 'ArrowRight',
	  'Down': 'ArrowDown',
	  'Del': 'Delete',
	  'Win': 'OS',
	  'Menu': 'ContextMenu',
	  'Apps': 'ContextMenu',
	  'Scroll': 'ScrollLock',
	  'MozPrintableKey': 'Unidentified'
	};
	
	/**
	 * Translation from legacy `keyCode` to HTML5 `key`
	 * Only special keys supported, all others depend on keyboard layout or browser
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var translateToKey = {
	  8: 'Backspace',
	  9: 'Tab',
	  12: 'Clear',
	  13: 'Enter',
	  16: 'Shift',
	  17: 'Control',
	  18: 'Alt',
	  19: 'Pause',
	  20: 'CapsLock',
	  27: 'Escape',
	  32: ' ',
	  33: 'PageUp',
	  34: 'PageDown',
	  35: 'End',
	  36: 'Home',
	  37: 'ArrowLeft',
	  38: 'ArrowUp',
	  39: 'ArrowRight',
	  40: 'ArrowDown',
	  45: 'Insert',
	  46: 'Delete',
	  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
	  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
	  144: 'NumLock',
	  145: 'ScrollLock',
	  224: 'Meta'
	};
	
	/**
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `key` property.
	 */
	function getEventKey(nativeEvent) {
	  if (nativeEvent.key) {
	    // Normalize inconsistent values reported by browsers due to
	    // implementations of a working draft specification.
	
	    // FireFox implements `key` but returns `MozPrintableKey` for all
	    // printable characters (normalized to `Unidentified`), ignore it.
	    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	    if (key !== 'Unidentified') {
	      return key;
	    }
	  }
	
	  // Browser does not implement `key`, polyfill as much of it as we can.
	  if (nativeEvent.type === 'keypress') {
	    var charCode = getEventCharCode(nativeEvent);
	
	    // The enter-key is technically both printable and non-printable and can
	    // thus be captured by `keypress`, no other non-printable key should.
	    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
	  }
	  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
	    // While user keyboard layout determines the actual meaning of each
	    // `keyCode` value, almost all function keys have a universal value.
	    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
	  }
	  return '';
	}
	
	module.exports = getEventKey;

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticDragEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(86);
	
	/**
	 * @interface DragEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var DragEventInterface = {
	  dataTransfer: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
	
	module.exports = SyntheticDragEvent;

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticTouchEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(87);
	
	var getEventModifierState = __webpack_require__(88);
	
	/**
	 * @interface TouchEvent
	 * @see http://www.w3.org/TR/touch-events/
	 */
	var TouchEventInterface = {
	  touches: null,
	  targetTouches: null,
	  changedTouches: null,
	  altKey: null,
	  metaKey: null,
	  ctrlKey: null,
	  shiftKey: null,
	  getModifierState: getEventModifierState
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
	
	module.exports = SyntheticTouchEvent;

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticWheelEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(86);
	
	/**
	 * @interface WheelEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var WheelEventInterface = {
	  deltaX: function (event) {
	    return 'deltaX' in event ? event.deltaX :
	    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
	    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
	  },
	  deltaY: function (event) {
	    return 'deltaY' in event ? event.deltaY :
	    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
	    'wheelDeltaY' in event ? -event.wheelDeltaY :
	    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
	    'wheelDelta' in event ? -event.wheelDelta : 0;
	  },
	  deltaZ: null,
	
	  // Browsers without "deltaMode" is reporting in raw wheel delta where one
	  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
	  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
	  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
	  deltaMode: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticMouseEvent}
	 */
	function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
	
	module.exports = SyntheticWheelEvent;

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SVGDOMPropertyConfig
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(23);
	
	var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
	
	var NS = {
	  xlink: 'http://www.w3.org/1999/xlink',
	  xml: 'http://www.w3.org/XML/1998/namespace'
	};
	
	var SVGDOMPropertyConfig = {
	  Properties: {
	    clipPath: MUST_USE_ATTRIBUTE,
	    cx: MUST_USE_ATTRIBUTE,
	    cy: MUST_USE_ATTRIBUTE,
	    d: MUST_USE_ATTRIBUTE,
	    dx: MUST_USE_ATTRIBUTE,
	    dy: MUST_USE_ATTRIBUTE,
	    fill: MUST_USE_ATTRIBUTE,
	    fillOpacity: MUST_USE_ATTRIBUTE,
	    fontFamily: MUST_USE_ATTRIBUTE,
	    fontSize: MUST_USE_ATTRIBUTE,
	    fx: MUST_USE_ATTRIBUTE,
	    fy: MUST_USE_ATTRIBUTE,
	    gradientTransform: MUST_USE_ATTRIBUTE,
	    gradientUnits: MUST_USE_ATTRIBUTE,
	    markerEnd: MUST_USE_ATTRIBUTE,
	    markerMid: MUST_USE_ATTRIBUTE,
	    markerStart: MUST_USE_ATTRIBUTE,
	    offset: MUST_USE_ATTRIBUTE,
	    opacity: MUST_USE_ATTRIBUTE,
	    patternContentUnits: MUST_USE_ATTRIBUTE,
	    patternUnits: MUST_USE_ATTRIBUTE,
	    points: MUST_USE_ATTRIBUTE,
	    preserveAspectRatio: MUST_USE_ATTRIBUTE,
	    r: MUST_USE_ATTRIBUTE,
	    rx: MUST_USE_ATTRIBUTE,
	    ry: MUST_USE_ATTRIBUTE,
	    spreadMethod: MUST_USE_ATTRIBUTE,
	    stopColor: MUST_USE_ATTRIBUTE,
	    stopOpacity: MUST_USE_ATTRIBUTE,
	    stroke: MUST_USE_ATTRIBUTE,
	    strokeDasharray: MUST_USE_ATTRIBUTE,
	    strokeLinecap: MUST_USE_ATTRIBUTE,
	    strokeOpacity: MUST_USE_ATTRIBUTE,
	    strokeWidth: MUST_USE_ATTRIBUTE,
	    textAnchor: MUST_USE_ATTRIBUTE,
	    transform: MUST_USE_ATTRIBUTE,
	    version: MUST_USE_ATTRIBUTE,
	    viewBox: MUST_USE_ATTRIBUTE,
	    x1: MUST_USE_ATTRIBUTE,
	    x2: MUST_USE_ATTRIBUTE,
	    x: MUST_USE_ATTRIBUTE,
	    xlinkActuate: MUST_USE_ATTRIBUTE,
	    xlinkArcrole: MUST_USE_ATTRIBUTE,
	    xlinkHref: MUST_USE_ATTRIBUTE,
	    xlinkRole: MUST_USE_ATTRIBUTE,
	    xlinkShow: MUST_USE_ATTRIBUTE,
	    xlinkTitle: MUST_USE_ATTRIBUTE,
	    xlinkType: MUST_USE_ATTRIBUTE,
	    xmlBase: MUST_USE_ATTRIBUTE,
	    xmlLang: MUST_USE_ATTRIBUTE,
	    xmlSpace: MUST_USE_ATTRIBUTE,
	    y1: MUST_USE_ATTRIBUTE,
	    y2: MUST_USE_ATTRIBUTE,
	    y: MUST_USE_ATTRIBUTE
	  },
	  DOMAttributeNamespaces: {
	    xlinkActuate: NS.xlink,
	    xlinkArcrole: NS.xlink,
	    xlinkHref: NS.xlink,
	    xlinkRole: NS.xlink,
	    xlinkShow: NS.xlink,
	    xlinkTitle: NS.xlink,
	    xlinkType: NS.xlink,
	    xmlBase: NS.xml,
	    xmlLang: NS.xml,
	    xmlSpace: NS.xml
	  },
	  DOMAttributeNames: {
	    clipPath: 'clip-path',
	    fillOpacity: 'fill-opacity',
	    fontFamily: 'font-family',
	    fontSize: 'font-size',
	    gradientTransform: 'gradientTransform',
	    gradientUnits: 'gradientUnits',
	    markerEnd: 'marker-end',
	    markerMid: 'marker-mid',
	    markerStart: 'marker-start',
	    patternContentUnits: 'patternContentUnits',
	    patternUnits: 'patternUnits',
	    preserveAspectRatio: 'preserveAspectRatio',
	    spreadMethod: 'spreadMethod',
	    stopColor: 'stop-color',
	    stopOpacity: 'stop-opacity',
	    strokeDasharray: 'stroke-dasharray',
	    strokeLinecap: 'stroke-linecap',
	    strokeOpacity: 'stroke-opacity',
	    strokeWidth: 'stroke-width',
	    textAnchor: 'text-anchor',
	    viewBox: 'viewBox',
	    xlinkActuate: 'xlink:actuate',
	    xlinkArcrole: 'xlink:arcrole',
	    xlinkHref: 'xlink:href',
	    xlinkRole: 'xlink:role',
	    xlinkShow: 'xlink:show',
	    xlinkTitle: 'xlink:title',
	    xlinkType: 'xlink:type',
	    xmlBase: 'xml:base',
	    xmlLang: 'xml:lang',
	    xmlSpace: 'xml:space'
	  }
	};
	
	module.exports = SVGDOMPropertyConfig;

/***/ },
/* 142 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactVersion
	 */
	
	'use strict';
	
	module.exports = '0.14.6';

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	* @providesModule renderSubtreeIntoContainer
	*/
	
	'use strict';
	
	var ReactMount = __webpack_require__(28);
	
	module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMServer
	 */
	
	'use strict';
	
	var ReactDefaultInjection = __webpack_require__(71);
	var ReactServerRendering = __webpack_require__(145);
	var ReactVersion = __webpack_require__(142);
	
	ReactDefaultInjection.inject();
	
	var ReactDOMServer = {
	  renderToString: ReactServerRendering.renderToString,
	  renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,
	  version: ReactVersion
	};
	
	module.exports = ReactDOMServer;

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks static-only
	 * @providesModule ReactServerRendering
	 */
	'use strict';
	
	var ReactDefaultBatchingStrategy = __webpack_require__(92);
	var ReactElement = __webpack_require__(42);
	var ReactInstanceHandles = __webpack_require__(45);
	var ReactMarkupChecksum = __webpack_require__(48);
	var ReactServerBatchingStrategy = __webpack_require__(146);
	var ReactServerRenderingTransaction = __webpack_require__(147);
	var ReactUpdates = __webpack_require__(54);
	
	var emptyObject = __webpack_require__(58);
	var instantiateReactComponent = __webpack_require__(62);
	var invariant = __webpack_require__(13);
	
	/**
	 * @param {ReactElement} element
	 * @return {string} the HTML markup
	 */
	function renderToString(element) {
	  !ReactElement.isValidElement(element) ?  false ? invariant(false, 'renderToString(): You must pass a valid ReactElement.') : invariant(false) : undefined;
	
	  var transaction;
	  try {
	    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);
	
	    var id = ReactInstanceHandles.createReactRootID();
	    transaction = ReactServerRenderingTransaction.getPooled(false);
	
	    return transaction.perform(function () {
	      var componentInstance = instantiateReactComponent(element, null);
	      var markup = componentInstance.mountComponent(id, transaction, emptyObject);
	      return ReactMarkupChecksum.addChecksumToMarkup(markup);
	    }, null);
	  } finally {
	    ReactServerRenderingTransaction.release(transaction);
	    // Revert to the DOM batching strategy since these two renderers
	    // currently share these stateful modules.
	    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	  }
	}
	
	/**
	 * @param {ReactElement} element
	 * @return {string} the HTML markup, without the extra React ID and checksum
	 * (for generating static pages)
	 */
	function renderToStaticMarkup(element) {
	  !ReactElement.isValidElement(element) ?  false ? invariant(false, 'renderToStaticMarkup(): You must pass a valid ReactElement.') : invariant(false) : undefined;
	
	  var transaction;
	  try {
	    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);
	
	    var id = ReactInstanceHandles.createReactRootID();
	    transaction = ReactServerRenderingTransaction.getPooled(true);
	
	    return transaction.perform(function () {
	      var componentInstance = instantiateReactComponent(element, null);
	      return componentInstance.mountComponent(id, transaction, emptyObject);
	    }, null);
	  } finally {
	    ReactServerRenderingTransaction.release(transaction);
	    // Revert to the DOM batching strategy since these two renderers
	    // currently share these stateful modules.
	    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	  }
	}
	
	module.exports = {
	  renderToString: renderToString,
	  renderToStaticMarkup: renderToStaticMarkup
	};

/***/ },
/* 146 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerBatchingStrategy
	 * @typechecks
	 */
	
	'use strict';
	
	var ReactServerBatchingStrategy = {
	  isBatchingUpdates: false,
	  batchedUpdates: function (callback) {
	    // Don't do anything here. During the server rendering we don't want to
	    // schedule any updates. We will simply ignore them.
	  }
	};
	
	module.exports = ReactServerBatchingStrategy;

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerRenderingTransaction
	 * @typechecks
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(56);
	var CallbackQueue = __webpack_require__(55);
	var Transaction = __webpack_require__(57);
	
	var assign = __webpack_require__(39);
	var emptyFunction = __webpack_require__(15);
	
	/**
	 * Provides a `CallbackQueue` queue for collecting `onDOMReady` callbacks
	 * during the performing of the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function () {
	    this.reactMountReady.reset();
	  },
	
	  close: emptyFunction
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [ON_DOM_READY_QUEUEING];
	
	/**
	 * @class ReactServerRenderingTransaction
	 * @param {boolean} renderToStaticMarkup
	 */
	function ReactServerRenderingTransaction(renderToStaticMarkup) {
	  this.reinitializeTransaction();
	  this.renderToStaticMarkup = renderToStaticMarkup;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = false;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array} Empty list of operation wrap procedures.
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return this.reactMountReady;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactServerRenderingTransaction);
	
	module.exports = ReactServerRenderingTransaction;

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactIsomorphic
	 */
	
	'use strict';
	
	var ReactChildren = __webpack_require__(110);
	var ReactComponent = __webpack_require__(123);
	var ReactClass = __webpack_require__(122);
	var ReactDOMFactories = __webpack_require__(149);
	var ReactElement = __webpack_require__(42);
	var ReactElementValidator = __webpack_require__(150);
	var ReactPropTypes = __webpack_require__(107);
	var ReactVersion = __webpack_require__(142);
	
	var assign = __webpack_require__(39);
	var onlyChild = __webpack_require__(152);
	
	var createElement = ReactElement.createElement;
	var createFactory = ReactElement.createFactory;
	var cloneElement = ReactElement.cloneElement;
	
	if (false) {
	  createElement = ReactElementValidator.createElement;
	  createFactory = ReactElementValidator.createFactory;
	  cloneElement = ReactElementValidator.cloneElement;
	}
	
	var React = {
	
	  // Modern
	
	  Children: {
	    map: ReactChildren.map,
	    forEach: ReactChildren.forEach,
	    count: ReactChildren.count,
	    toArray: ReactChildren.toArray,
	    only: onlyChild
	  },
	
	  Component: ReactComponent,
	
	  createElement: createElement,
	  cloneElement: cloneElement,
	  isValidElement: ReactElement.isValidElement,
	
	  // Classic
	
	  PropTypes: ReactPropTypes,
	  createClass: ReactClass.createClass,
	  createFactory: createFactory,
	  createMixin: function (mixin) {
	    // Currently a noop. Will be used to validate and trace mixins.
	    return mixin;
	  },
	
	  // This looks DOM specific but these are actually isomorphic helpers
	  // since they are just generating DOM strings.
	  DOM: ReactDOMFactories,
	
	  version: ReactVersion,
	
	  // Hook for JSX spread, don't use this for anything else.
	  __spread: assign
	};
	
	module.exports = React;

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFactories
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(42);
	var ReactElementValidator = __webpack_require__(150);
	
	var mapObject = __webpack_require__(151);
	
	/**
	 * Create a factory that creates HTML tag elements.
	 *
	 * @param {string} tag Tag name (e.g. `div`).
	 * @private
	 */
	function createDOMFactory(tag) {
	  if (false) {
	    return ReactElementValidator.createFactory(tag);
	  }
	  return ReactElement.createFactory(tag);
	}
	
	/**
	 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
	 * This is also accessible via `React.DOM`.
	 *
	 * @public
	 */
	var ReactDOMFactories = mapObject({
	  a: 'a',
	  abbr: 'abbr',
	  address: 'address',
	  area: 'area',
	  article: 'article',
	  aside: 'aside',
	  audio: 'audio',
	  b: 'b',
	  base: 'base',
	  bdi: 'bdi',
	  bdo: 'bdo',
	  big: 'big',
	  blockquote: 'blockquote',
	  body: 'body',
	  br: 'br',
	  button: 'button',
	  canvas: 'canvas',
	  caption: 'caption',
	  cite: 'cite',
	  code: 'code',
	  col: 'col',
	  colgroup: 'colgroup',
	  data: 'data',
	  datalist: 'datalist',
	  dd: 'dd',
	  del: 'del',
	  details: 'details',
	  dfn: 'dfn',
	  dialog: 'dialog',
	  div: 'div',
	  dl: 'dl',
	  dt: 'dt',
	  em: 'em',
	  embed: 'embed',
	  fieldset: 'fieldset',
	  figcaption: 'figcaption',
	  figure: 'figure',
	  footer: 'footer',
	  form: 'form',
	  h1: 'h1',
	  h2: 'h2',
	  h3: 'h3',
	  h4: 'h4',
	  h5: 'h5',
	  h6: 'h6',
	  head: 'head',
	  header: 'header',
	  hgroup: 'hgroup',
	  hr: 'hr',
	  html: 'html',
	  i: 'i',
	  iframe: 'iframe',
	  img: 'img',
	  input: 'input',
	  ins: 'ins',
	  kbd: 'kbd',
	  keygen: 'keygen',
	  label: 'label',
	  legend: 'legend',
	  li: 'li',
	  link: 'link',
	  main: 'main',
	  map: 'map',
	  mark: 'mark',
	  menu: 'menu',
	  menuitem: 'menuitem',
	  meta: 'meta',
	  meter: 'meter',
	  nav: 'nav',
	  noscript: 'noscript',
	  object: 'object',
	  ol: 'ol',
	  optgroup: 'optgroup',
	  option: 'option',
	  output: 'output',
	  p: 'p',
	  param: 'param',
	  picture: 'picture',
	  pre: 'pre',
	  progress: 'progress',
	  q: 'q',
	  rp: 'rp',
	  rt: 'rt',
	  ruby: 'ruby',
	  s: 's',
	  samp: 'samp',
	  script: 'script',
	  section: 'section',
	  select: 'select',
	  small: 'small',
	  source: 'source',
	  span: 'span',
	  strong: 'strong',
	  style: 'style',
	  sub: 'sub',
	  summary: 'summary',
	  sup: 'sup',
	  table: 'table',
	  tbody: 'tbody',
	  td: 'td',
	  textarea: 'textarea',
	  tfoot: 'tfoot',
	  th: 'th',
	  thead: 'thead',
	  time: 'time',
	  title: 'title',
	  tr: 'tr',
	  track: 'track',
	  u: 'u',
	  ul: 'ul',
	  'var': 'var',
	  video: 'video',
	  wbr: 'wbr',
	
	  // SVG
	  circle: 'circle',
	  clipPath: 'clipPath',
	  defs: 'defs',
	  ellipse: 'ellipse',
	  g: 'g',
	  image: 'image',
	  line: 'line',
	  linearGradient: 'linearGradient',
	  mask: 'mask',
	  path: 'path',
	  pattern: 'pattern',
	  polygon: 'polygon',
	  polyline: 'polyline',
	  radialGradient: 'radialGradient',
	  rect: 'rect',
	  stop: 'stop',
	  svg: 'svg',
	  text: 'text',
	  tspan: 'tspan'
	
	}, createDOMFactory);
	
	module.exports = ReactDOMFactories;

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElementValidator
	 */
	
	/**
	 * ReactElementValidator provides a wrapper around a element factory
	 * which validates the props passed to the element. This is intended to be
	 * used only in DEV and could be replaced by a static type checker for languages
	 * that support it.
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(42);
	var ReactPropTypeLocations = __webpack_require__(65);
	var ReactPropTypeLocationNames = __webpack_require__(66);
	var ReactCurrentOwner = __webpack_require__(5);
	
	var canDefineProperty = __webpack_require__(43);
	var getIteratorFn = __webpack_require__(108);
	var invariant = __webpack_require__(13);
	var warning = __webpack_require__(25);
	
	function getDeclarationErrorAddendum() {
	  if (ReactCurrentOwner.current) {
	    var name = ReactCurrentOwner.current.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */
	var ownerHasKeyUseWarning = {};
	
	var loggedTypeFailures = {};
	
	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function validateExplicitKey(element, parentType) {
	  if (!element._store || element._store.validated || element.key != null) {
	    return;
	  }
	  element._store.validated = true;
	
	  var addenda = getAddendaForKeyUse('uniqueKey', element, parentType);
	  if (addenda === null) {
	    // we already showed the warning
	    return;
	  }
	   false ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s%s', addenda.parentOrOwner || '', addenda.childOwner || '', addenda.url || '') : undefined;
	}
	
	/**
	 * Shared warning and monitoring code for the key warnings.
	 *
	 * @internal
	 * @param {string} messageType A key used for de-duping warnings.
	 * @param {ReactElement} element Component that requires a key.
	 * @param {*} parentType element's parent's type.
	 * @returns {?object} A set of addenda to use in the warning message, or null
	 * if the warning has already been shown before (and shouldn't be shown again).
	 */
	function getAddendaForKeyUse(messageType, element, parentType) {
	  var addendum = getDeclarationErrorAddendum();
	  if (!addendum) {
	    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
	    if (parentName) {
	      addendum = ' Check the top-level render call using <' + parentName + '>.';
	    }
	  }
	
	  var memoizer = ownerHasKeyUseWarning[messageType] || (ownerHasKeyUseWarning[messageType] = {});
	  if (memoizer[addendum]) {
	    return null;
	  }
	  memoizer[addendum] = true;
	
	  var addenda = {
	    parentOrOwner: addendum,
	    url: ' See https://fb.me/react-warning-keys for more information.',
	    childOwner: null
	  };
	
	  // Usually the current owner is the offender, but if it accepts children as a
	  // property, it may be the creator of the child that's responsible for
	  // assigning it a key.
	  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
	    // Give the component that originally created this child.
	    addenda.childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
	  }
	
	  return addenda;
	}
	
	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */
	function validateChildKeys(node, parentType) {
	  if (typeof node !== 'object') {
	    return;
	  }
	  if (Array.isArray(node)) {
	    for (var i = 0; i < node.length; i++) {
	      var child = node[i];
	      if (ReactElement.isValidElement(child)) {
	        validateExplicitKey(child, parentType);
	      }
	    }
	  } else if (ReactElement.isValidElement(node)) {
	    // This element was passed in a valid location.
	    if (node._store) {
	      node._store.validated = true;
	    }
	  } else if (node) {
	    var iteratorFn = getIteratorFn(node);
	    // Entry iterators provide implicit keys.
	    if (iteratorFn) {
	      if (iteratorFn !== node.entries) {
	        var iterator = iteratorFn.call(node);
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (ReactElement.isValidElement(step.value)) {
	            validateExplicitKey(step.value, parentType);
	          }
	        }
	      }
	    }
	  }
	}
	
	/**
	 * Assert that the props are valid
	 *
	 * @param {string} componentName Name of the component for error messages.
	 * @param {object} propTypes Map of prop name to a ReactPropType
	 * @param {object} props
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @private
	 */
	function checkPropTypes(componentName, propTypes, props, location) {
	  for (var propName in propTypes) {
	    if (propTypes.hasOwnProperty(propName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof propTypes[propName] === 'function') ?  false ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
	        error = propTypes[propName](props, propName, componentName, location);
	      } catch (ex) {
	        error = ex;
	      }
	       false ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], propName, typeof error) : undefined;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum();
	         false ? warning(false, 'Failed propType: %s%s', error.message, addendum) : undefined;
	      }
	    }
	  }
	}
	
	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */
	function validatePropTypes(element) {
	  var componentClass = element.type;
	  if (typeof componentClass !== 'function') {
	    return;
	  }
	  var name = componentClass.displayName || componentClass.name;
	  if (componentClass.propTypes) {
	    checkPropTypes(name, componentClass.propTypes, element.props, ReactPropTypeLocations.prop);
	  }
	  if (typeof componentClass.getDefaultProps === 'function') {
	     false ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : undefined;
	  }
	}
	
	var ReactElementValidator = {
	
	  createElement: function (type, props, children) {
	    var validType = typeof type === 'string' || typeof type === 'function';
	    // We warn in this case but don't throw. We expect the element creation to
	    // succeed and there will likely be errors in render.
	     false ? warning(validType, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : undefined;
	
	    var element = ReactElement.createElement.apply(this, arguments);
	
	    // The result can be nullish if a mock or a custom function is used.
	    // TODO: Drop this when these are no longer allowed as the type argument.
	    if (element == null) {
	      return element;
	    }
	
	    // Skip key warning if the type isn't valid since our key validation logic
	    // doesn't expect a non-string/function type and can throw confusing errors.
	    // We don't want exception behavior to differ between dev and prod.
	    // (Rendering will throw with a helpful message and as soon as the type is
	    // fixed, the key warnings will appear.)
	    if (validType) {
	      for (var i = 2; i < arguments.length; i++) {
	        validateChildKeys(arguments[i], type);
	      }
	    }
	
	    validatePropTypes(element);
	
	    return element;
	  },
	
	  createFactory: function (type) {
	    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
	    // Legacy hook TODO: Warn if this is accessed
	    validatedFactory.type = type;
	
	    if (false) {
	      if (canDefineProperty) {
	        Object.defineProperty(validatedFactory, 'type', {
	          enumerable: false,
	          get: function () {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : undefined;
	            Object.defineProperty(this, 'type', {
	              value: type
	            });
	            return type;
	          }
	        });
	      }
	    }
	
	    return validatedFactory;
	  },
	
	  cloneElement: function (element, props, children) {
	    var newElement = ReactElement.cloneElement.apply(this, arguments);
	    for (var i = 2; i < arguments.length; i++) {
	      validateChildKeys(arguments[i], newElement.type);
	    }
	    validatePropTypes(newElement);
	    return newElement;
	  }
	
	};
	
	module.exports = ReactElementValidator;

/***/ },
/* 151 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule mapObject
	 */
	
	'use strict';
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * Executes the provided `callback` once for each enumerable own property in the
	 * object and constructs a new object from the results. The `callback` is
	 * invoked with three arguments:
	 *
	 *  - the property value
	 *  - the property name
	 *  - the object being traversed
	 *
	 * Properties that are added after the call to `mapObject` will not be visited
	 * by `callback`. If the values of existing properties are changed, the value
	 * passed to `callback` will be the value at the time `mapObject` visits them.
	 * Properties that are deleted before being visited are not visited.
	 *
	 * @grep function objectMap()
	 * @grep function objMap()
	 *
	 * @param {?object} object
	 * @param {function} callback
	 * @param {*} context
	 * @return {?object}
	 */
	function mapObject(object, callback, context) {
	  if (!object) {
	    return null;
	  }
	  var result = {};
	  for (var name in object) {
	    if (hasOwnProperty.call(object, name)) {
	      result[name] = callback.call(context, object[name], name, object);
	    }
	  }
	  return result;
	}
	
	module.exports = mapObject;

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule onlyChild
	 */
	'use strict';
	
	var ReactElement = __webpack_require__(42);
	
	var invariant = __webpack_require__(13);
	
	/**
	 * Returns the first child in a collection of children and verifies that there
	 * is only one child in the collection. The current implementation of this
	 * function assumes that a single child gets passed without a wrapper, but the
	 * purpose of this helper function is to abstract away the particular structure
	 * of children.
	 *
	 * @param {?object} children Child collection structure.
	 * @return {ReactComponent} The first and only `ReactComponent` contained in the
	 * structure.
	 */
	function onlyChild(children) {
	  !ReactElement.isValidElement(children) ?  false ? invariant(false, 'onlyChild must be passed a children with exactly one child.') : invariant(false) : undefined;
	  return children;
	}
	
	module.exports = onlyChild;

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule deprecated
	 */
	
	'use strict';
	
	var assign = __webpack_require__(39);
	var warning = __webpack_require__(25);
	
	/**
	 * This will log a single deprecation notice per function and forward the call
	 * on to the new API.
	 *
	 * @param {string} fnName The name of the function
	 * @param {string} newModule The module that fn will exist in
	 * @param {string} newPackage The module that fn will exist in
	 * @param {*} ctx The context this forwarded call should run in
	 * @param {function} fn The function to forward on to
	 * @return {function} The function that will warn once and then call fn
	 */
	function deprecated(fnName, newModule, newPackage, ctx, fn) {
	  var warned = false;
	  if (false) {
	    var newFn = function () {
	      process.env.NODE_ENV !== 'production' ? warning(warned,
	      // Require examples in this string must be split to prevent React's
	      // build tools from mistaking them for real requires.
	      // Otherwise the build tools will attempt to build a '%s' module.
	      'React.%s is deprecated. Please use %s.%s from require' + '(\'%s\') ' + 'instead.', fnName, newModule, fnName, newPackage) : undefined;
	      warned = true;
	      return fn.apply(ctx, arguments);
	    };
	    // We need to make sure all properties of the original fn are copied over.
	    // In particular, this is needed to support PropTypes
	    return assign(newFn, fn);
	  }
	
	  return fn;
	}
	
	module.exports = deprecated;

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * @providesModule ReactStyleSheet
	 */
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _extendPropertiesWeb = __webpack_require__(155);
	
	var _extendPropertiesWeb2 = _interopRequireDefault(_extendPropertiesWeb);
	
	var _reference = __webpack_require__(159);
	
	var _reference2 = _interopRequireDefault(_reference);
	
	var _setDefaultStyleWeb = __webpack_require__(160);
	
	var _setDefaultStyleWeb2 = _interopRequireDefault(_setDefaultStyleWeb);
	
	// Make React support array of style object like React Native
	
	var _extendCreateElement2 = __webpack_require__(161);
	
	var _extendCreateElement3 = _interopRequireDefault(_extendCreateElement2);
	
	var _flattenStyleWeb = __webpack_require__(162);
	
	var _flattenStyleWeb2 = _interopRequireDefault(_flattenStyleWeb);
	
	var inited = false;
	
	var ROOT_CLASS_NAME = 'react-root';
	var VIEW_CLASS_NAME = 'react-view';
	
	var StyleSheet = {
	  create: function create(styles) {
	    return styles;
	  },
	  extendCreateElement: function extendCreateElement(React) {
	    (0, _extendCreateElement3['default'])(React, function (style) {
	      if (!inited) {
	        inited = true;
	        (0, _setDefaultStyleWeb2['default'])({
	          reference: _reference2['default'].getWidth(),
	          rootClassName: ROOT_CLASS_NAME,
	          viewClassName: VIEW_CLASS_NAME
	        });
	      }
	
	      return (0, _flattenStyleWeb2['default'])(style, _extendPropertiesWeb2['default']);
	    });
	  },
	  setReferenceWidth: _reference2['default'].setWidth,
	  rootClassName: ROOT_CLASS_NAME,
	  viewClassName: VIEW_CLASS_NAME
	};
	
	module.exports = StyleSheet;

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 */
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _domkitGetVendorPropertyName = __webpack_require__(156);
	
	var _domkitGetVendorPropertyName2 = _interopRequireDefault(_domkitGetVendorPropertyName);
	
	var _CSSProperty = __webpack_require__(158);
	
	var _CSSProperty2 = _interopRequireDefault(_CSSProperty);
	
	var shorthandProperties = {
	  margin: true,
	  padding: true,
	  borderWidth: true,
	  borderRadius: true
	};
	
	// some number that react not auto add px
	var numberProperties = {
	  translateX: true,
	  translateY: true,
	  translateZ: true,
	  lineHeight: true
	};
	
	var boxProperties = {
	  paddingHorizontal: true,
	  paddingVertical: true,
	  marginHorizontal: true,
	  marginVertical: true
	};
	
	var borderProperties = {
	  borderColor: true,
	  borderWidth: true,
	  borderTopColor: true,
	  borderRightColor: true,
	  borderBottomColor: true,
	  borderLeftColor: true,
	  borderTopWidth: true,
	  borderRightWidth: true,
	  borderBottomWidth: true,
	  borderLeftWidth: true
	};
	
	// prefix 2009 spec
	var flexboxProperties = {
	  flex: 'WebkitBoxFlex',
	  order: 'WebkitBoxOrdinalGroup',
	  // https://github.com/postcss/autoprefixer/blob/master/lib/hacks/flex-direction.coffee
	  flexDirection: 'WebkitBoxOrient',
	  // https://github.com/postcss/autoprefixer/blob/master/lib/hacks/align-items.coffee
	  alignItems: 'WebkitBoxAlign',
	  // https://github.com/postcss/autoprefixer/blob/master/lib/hacks/justify-content.coffee
	  justifyContent: 'WebkitBoxPack',
	  flexWrap: null,
	  alignSelf: null
	};
	
	var oldFlexboxValues = {
	  'flex-end': 'end',
	  'flex-start': 'start',
	  'space-between': 'justify',
	  'space-around': 'distribute'
	};
	
	var builtinStyle = document.createElement('div').style;
	var flexboxSpec;
	if ('alignSelf' in builtinStyle) flexboxSpec = 'final';else if ('webkitAlignSelf' in builtinStyle) flexboxSpec = 'finalVendor';else flexboxSpec = '2009';
	
	// FIXME: UCBrowser is cheat
	var isUCBrowser = /UCBrowser/i.test(navigator.userAgent);
	if (isUCBrowser) flexboxSpec = '2009';
	
	// TODO: cache the result
	function prefixOldFlexbox(property, value, result) {
	
	  if (flexboxSpec === '2009') {
	    var oldValue = oldFlexboxValues[value] || value;
	    var oldProperty = flexboxProperties[property] || property;
	    if (oldProperty === 'WebkitBoxOrient') {
	      // boxOrient
	      if (value.indexOf('row') != -1) {
	        oldValue = 'horizontal';
	      } else {
	        oldValue = 'vertical';
	      }
	      // boxDirection
	      var dir = '';
	      if (value.indexOf('reverse') != -1) {
	        dir = 'reverse';
	      } else {
	        dir = 'normal';
	      }
	      result.WebkitBoxDirection = dir;
	    }
	    return result[oldProperty] = oldValue;
	  } else if (flexboxSpec === 'finalVendor') {
	    return result[(0, _domkitGetVendorPropertyName2['default'])(property)] = value;
	  } else {
	    return result[property] = value;
	  }
	}
	
	function extendBoxProperties(property, value, result) {
	  var padding = 'padding';
	  var margin = 'margin';
	  var horizontal = 'Horizontal';
	  var vertical = 'Vertical';
	  var type = property.indexOf(margin) == 0 ? margin : padding;
	  var directionType = property.indexOf(vertical) !== -1 ? vertical : horizontal;
	
	  if (directionType == horizontal) {
	    result[type + 'Left'] = result[type + 'Right'] = value;
	  } else if (directionType == vertical) {
	    result[type + 'Top'] = result[type + 'Bottom'] = value;
	  }
	}
	
	function isValidValue(value) {
	  return value !== '' && value !== null && value !== undefined;
	}
	
	function processValueForProp(value, prop) {
	
	  if (typeof value == 'number') {
	    // transform less then 1px value to 1px, 0.5 to be 1
	    if (!_CSSProperty2['default'].isUnitlessNumber[prop] && value > 0 && value < 1) {
	      value = 1;
	    }
	
	    // Add px to numeric values
	    if (numberProperties[prop] && typeof value == 'number') {
	      value += 'px';
	    }
	  }
	
	  // [
	  //   {scaleX: 2},
	  //   {scaleY: 2}
	  // ] => scaleX(2) scaleY(2)
	  if (prop == 'transform' && Array.isArray(value)) {
	    var transformations = [];
	    value.forEach(function (transformation) {
	
	      var key = Object.keys(transformation)[0];
	      var val = transformation[key];
	
	      // for animated value
	      if (val.__getValue) {
	        val = val.__getValue();
	      }
	
	      // translate matrix have an array as the value
	      if (Array.isArray(val)) {
	
	        var len = val.length;
	
	        if (key === 'matrix' && len === 16 || key === 'translate' && len === 3) {
	          key += '3d';
	        }
	
	        val = val.map(function (v) {
	          return processValueForProp(v, key);
	        }).join(',');
	      } else {
	        val = processValueForProp(val, key);
	      }
	
	      transformations.push(key + '(' + val + ')');
	    });
	
	    value = transformations.join(' ');
	  }
	
	  if (shorthandProperties[prop] && typeof value == 'string') {
	    value = value.replace(/\d*\.?\d+(rem|em|in|cm|mm|pt|pc|px|vh|vw|vmin|vmax|%)*/g, function (val, unit) {
	      return unit ? val : val + 'px';
	    });
	  }
	
	  return value;
	}
	
	function defaultBorderStyle(style, result) {
	  if (!style.borderStyle && !result.borderStyle) {
	    result.borderStyle = 'solid';
	  }
	
	  if (!style.borderWidth && !result.borderWidth) {
	    result.borderWidth = 0;
	  }
	
	  if (!style.borderColor && !result.borderColor) {
	    result.borderColor = 'black';
	  }
	}
	
	function extendProperties(style) {
	  var result = {};
	
	  for (var property in style) {
	    var value = style[property];
	    if (!isValidValue(value)) {
	      continue;
	    }
	    // set a default border style if there has border about property
	    if (borderProperties[property]) {
	      defaultBorderStyle(style, result);
	    }
	
	    if (boxProperties[property]) {
	      extendBoxProperties(property, value, result);
	    } else if (flexboxProperties[property]) {
	      prefixOldFlexbox(property, value, result);
	    } else {
	      value = processValueForProp(value, property);
	      property = (0, _domkitGetVendorPropertyName2['default'])(property);
	      result[property] = value;
	    }
	  }
	
	  return result;
	}
	
	module.exports = extendProperties;

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var builtinStyle = __webpack_require__(157);
	var prefixes = ['Moz', 'Webkit', 'O', 'ms'];
	var domVendorPrefix;
	
	// Helper function to get the proper vendor property name. (transition => WebkitTransition)
	module.exports = function(prop, isSupportTest) {
	
	  var vendorProp;
	  if (prop in builtinStyle) return prop;
	
	  var UpperProp = prop.charAt(0).toUpperCase() + prop.substr(1);
	
	  if (domVendorPrefix) {
	
	    vendorProp = domVendorPrefix + UpperProp;
	    if (vendorProp in builtinStyle) {
	      return vendorProp;
	    }
	  } else {
	
	    for (var i = 0; i < prefixes.length; ++i) {
	      vendorProp = prefixes[i] + UpperProp;
	      if (vendorProp in builtinStyle) {
	        domVendorPrefix = prefixes[i];
	        return vendorProp;
	      }
	    }
	  }
	
	  // if support test, not fallback to origin prop name
	  if (!isSupportTest) {
	    return prop;
	  }
	
	}


/***/ },
/* 157 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = document.createElement('div').style;


/***/ },
/* 158 */
97,
/* 159 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 */
	'use strict';
	
	var referenceWidth = 750 / 100;
	
	module.exports = {
	  setWidth: function setWidth(width) {
	    referenceWidth = width;
	  },
	  getWidth: function getWidth() {
	    return referenceWidth;
	  }
	};

/***/ },
/* 160 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 */
	'use strict';
	
	function appendSytle(_ref) {
	  var reference = _ref.reference;
	  var rootClassName = _ref.rootClassName;
	  var viewClassName = _ref.viewClassName;
	
	  var docEl = document.documentElement;
	  var styleEl = document.createElement('style');
	  docEl.firstElementChild.appendChild(styleEl);
	  var rem = docEl.clientWidth / reference;
	
	  var boxStyle = '\n  box-sizing: border-box;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-orient: vertical;\n  -webkit-box-direction: normal;\n  -webkit-flex-direction: column;\n  -ms-flex-direction: column;\n  flex-direction: column;\n  ';
	
	  styleEl.innerHTML = '\n  html {\n    font-size: ' + rem + 'px!important;\n  }\n  body {\n    font-size: 14px;\n    margin: 0;\n  }\n  .' + rootClassName + ' {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    ' + boxStyle + '\n  }\n  .' + rootClassName + ' .' + viewClassName + ' {\n    position: relative;\n    ' + boxStyle + '\n  }\n  ';
	}
	
	function setDefaultStyle(options) {
	  var metaEl = document.querySelector('meta[name="viewport"]');
	  if (!metaEl) {
	    console.warn('WARNING: Viewport meta not set, rendering may be affected!');
	  }
	
	  window.addEventListener('resize', function () {
	    appendSytle(options);
	  }, false);
	
	  appendSytle(options);
	}
	
	module.exports = setDefaultStyle;

/***/ },
/* 161 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 */
	'use strict';
	
	function extendCreateElement(React, processor) {
	  var originalCreateElement = React.createElement;
	  React.createElement = function (type, props) {
	    var args = arguments;
	
	    if (type && type.displayName !== 'AnimatedComponent' && props && props.style && (Array.isArray(props.style) || typeof props.style === 'object')) {
	      var style = processor(props.style);
	      // should copy it, props is read only
	      var target = {};
	      for (var key in props) {
	        if (Object.prototype.hasOwnProperty.call(props, key)) {
	          target[key] = props[key];
	        }
	      }
	
	      if (style.flex === undefined) {
	        style['display'] = 'flex'; // in RN Flexbox is the default
	      }
	
	      target.style = style;
	      props = target;
	    }
	
	    return originalCreateElement.apply(this, [type, props].concat(Array.prototype.slice.call(args, 2)));
	  };
	}
	
	module.exports = extendCreateElement;

/***/ },
/* 162 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * @providesModule ReactFlattenStyle
	 */
	'use strict';
	
	function flattenStyle(style, processor) {
	  if (!style) {
	    return undefined;
	  }
	
	  if (!Array.isArray(style)) {
	    return processor && processor(style) || style;
	  } else {
	
	    var result = {};
	    for (var i = 0; i < style.length; ++i) {
	      var computedStyle = flattenStyle(style[i]);
	      if (computedStyle) {
	        for (var key in computedStyle) {
	          result[key] = computedStyle[key];
	        }
	      }
	    }
	
	    return processor && processor(result) || result;;
	  }
	}
	
	module.exports = flattenStyle;

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * @providesModule ReactActivityIndicator
	 */
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _ReactView = __webpack_require__(164);
	
	var _ReactView2 = _interopRequireDefault(_ReactView);
	
	var _ReactStyleSheet = __webpack_require__(154);
	
	var _ReactStyleSheet2 = _interopRequireDefault(_ReactStyleSheet);
	
	var _domkitAppendVendorPrefix = __webpack_require__(168);
	
	var _domkitAppendVendorPrefix2 = _interopRequireDefault(_domkitAppendVendorPrefix);
	
	var _domkitInsertKeyframesRule = __webpack_require__(169);
	
	var _domkitInsertKeyframesRule2 = _interopRequireDefault(_domkitInsertKeyframesRule);
	
	var keyframes = {
	  '50%': {
	    opacity: 0.3
	  },
	  '100%': {
	    opacity: 1
	  }
	};
	
	var GRAY = '#999999';
	
	var animationName = (0, _domkitInsertKeyframesRule2['default'])(keyframes);
	
	var ActivityIndicator = _react2['default'].createClass({
	  displayName: 'ActivityIndicator',
	
	  propTypes: {
	    /**
	     * Whether to show the indicator (true, the default) or hide it (false).
	     */
	    animating: _react.PropTypes.bool,
	    /**
	     * The foreground color of the spinner (default is gray).
	     */
	    color: _react.PropTypes.string,
	    /**
	     * Size of the indicator. Small has a height of 20, large has a height of 36.
	     */
	    size: _react.PropTypes.oneOf(['small', 'large'])
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      animating: true,
	      color: GRAY,
	      size: 'small'
	    };
	  },
	
	  /**
	   * @param  {Number} i
	   * @return {Object}
	   */
	  getAnimationStyle: function getAnimationStyle(i) {
	    var animation = [animationName, '1.2s', i * 0.12 + 's', 'infinite', 'ease-in-out'].join(' ');
	    var animationFillMode = 'both';
	
	    return {
	      animation: animation,
	      animationFillMode: animationFillMode
	    };
	  },
	
	  /**
	   * @param  {Number} i
	   * @return {Object}
	   */
	  getLineStyle: function getLineStyle(i, lines) {
	    return {
	      backgroundColor: this.props.color,
	      position: 'absolute',
	      // FIXME: hacked a fixed value for align
	      top: -3,
	      left: -1,
	      transform: 'rotate(' + ~ ~(360 / lines * i) + 'deg) translate(0, -' + (this.props.size === 'large' ? 12 : 7) + 'px)'
	    };
	  },
	  /**
	   * @param  {Number} i
	   * @return {Object}
	   */
	  getStyle: function getStyle(i, lines) {
	    var sizeLineStyle = this.props.size === 'large' ? styles.sizeLargeLine : styles.sizeSmallLine;
	    return (0, _domkitAppendVendorPrefix2['default'])(this.getAnimationStyle(i), this.getLineStyle(i, lines), sizeLineStyle);
	  },
	
	  render: function render() {
	    var lines = [];
	    var sizeContainerStyle = this.props.size === 'large' ? styles.sizeLargeContainer : styles.sizeSmallContainer;
	
	    if (this.props.animating) {
	      for (var i = 1; i <= 12; i++) {
	        lines.push(_react2['default'].createElement(_ReactView2['default'], { key: i, style: this.getStyle(i, 12) }));
	      }
	    }
	
	    return _react2['default'].createElement(
	      _ReactView2['default'],
	      { style: [styles.container, sizeContainerStyle, this.props.style] },
	      _react2['default'].createElement(
	        _ReactView2['default'],
	        null,
	        lines
	      )
	    );
	  }
	});
	
	var styles = _ReactStyleSheet2['default'].create({
	  container: {
	    position: 'relative',
	    fontSize: 0,
	    alignItems: 'center',
	    justifyContent: 'center'
	  },
	  sizeSmallContainer: {
	    width: 20,
	    height: 20
	  },
	  sizeLargeContainer: {
	    width: 36,
	    height: 36
	  },
	  sizeSmallLine: {
	    width: 2,
	    height: 5,
	    borderRadius: 2
	  },
	  sizeLargeLine: {
	    width: 3,
	    height: 9,
	    borderRadius: 3
	  }
	});
	
	module.exports = ActivityIndicator;

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015, Facebook, Inc.  All rights reserved.
	 *
	 * @providesModule ReactView
	 */
	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _ReactStyleSheet = __webpack_require__(154);
	
	var _ReactStyleSheet2 = _interopRequireDefault(_ReactStyleSheet);
	
	var _ReactLayoutMixin = __webpack_require__(165);
	
	var View = _react2['default'].createClass({
	  displayName: 'View',
	
	  mixins: [_ReactLayoutMixin.Mixin],
	
	  propTypes: {
	    /**
	     * Used to locate this view in end-to-end tests. NB: disables the 'layout-only
	     * view removal' optimization for this view!
	     */
	    testID: _react.PropTypes.string,
	
	    /**
	     * For most touch interactions, you'll simply want to wrap your component in
	     * `TouchableHighlight` or `TouchableOpacity`. Check out `Touchable.js`,
	     * `ScrollResponder.js` and `ResponderEventPlugin.js` for more discussion.
	     */
	    onMoveShouldSetResponder: _react.PropTypes.func,
	    onResponderGrant: _react.PropTypes.func,
	    onResponderMove: _react.PropTypes.func,
	    onResponderReject: _react.PropTypes.func,
	    onResponderRelease: _react.PropTypes.func,
	    onResponderTerminate: _react.PropTypes.func,
	    onResponderTerminationRequest: _react.PropTypes.func,
	    onStartShouldSetResponder: _react.PropTypes.func,
	    onStartShouldSetResponderCapture: _react.PropTypes.func,
	
	    /**
	     * Invoked on mount and layout changes with
	     *
	     *   {nativeEvent: { layout: {x, y, width, height}}}.
	     *
	     * This event is fired immediately once the layout has been calculated, but
	     * the new layout may not yet be reflected on the screen at the time the
	     * event is received, especially if a layout animation is in progress.
	     */
	    onLayout: _react.PropTypes.func,
	
	    /**
	     * In the absence of `auto` property, `none` is much like `CSS`'s `none`
	     * value. `box-none` is as if you had applied the `CSS` class:
	     *
	     * ```
	     * .box-none {
	     *   pointer-events: none;
	     * }
	     * .box-none * {
	     *   pointer-events: all;
	     * }
	     * ```
	     *
	     * `box-only` is the equivalent of
	     *
	     * ```
	     * .box-only {
	     *   pointer-events: all;
	     * }
	     * .box-only * {
	     *   pointer-events: none;
	     * }
	     * ```
	     *
	     * But since `pointerEvents` does not affect layout/appearance, and we are
	     * already deviating from the spec by adding additional modes, we opt to not
	     * include `pointerEvents` on `style`. On some platforms, we would need to
	     * implement it as a `className` anyways. Using `style` or not is an
	     * implementation detail of the platform.
	     */
	    pointerEvents: _react.PropTypes.oneOf(['box-none', 'none', 'box-only', 'auto']),
	
	    style: _react.PropTypes.oneOfType([_react.PropTypes.object, _react.PropTypes.array])
	  },
	
	  render: function render() {
	    return _react2['default'].createElement(
	      'div',
	      _extends({ className: _ReactStyleSheet2['default'].viewClassName }, this.props),
	      this.props.children
	    );
	  }
	});
	
	module.exports = View;

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * @providesModule ReactLayoutMixin
	 */
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(166);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _ReactGetLayout = __webpack_require__(167);
	
	var _ReactGetLayout2 = _interopRequireDefault(_ReactGetLayout);
	
	var LayoutMixin = {
	  getInitialState: function getInitialState() {
	    return { layout: {} };
	  },
	
	  componentDidMount: function componentDidMount() {
	    this.layoutHandle();
	  },
	
	  componentDidUpdate: function componentDidUpdate() {
	    this.layoutHandle();
	  },
	
	  layoutHandle: function layoutHandle() {
	    if (this.props.onLayout) {
	
	      var layout = (0, _ReactGetLayout2['default'])(_reactDom2['default'].findDOMNode(this));
	      var stateLayout = this.state.layout;
	      if (stateLayout.x !== layout.x || stateLayout.y !== layout.y || stateLayout.width !== layout.width || stateLayout.height !== layout.height) {
	        this.props.onLayout({ nativeEvent: { layout: layout } });
	        this.setState({ layout: layout });
	      }
	    }
	  }
	};
	
	module.exports = {
	  Mixin: LayoutMixin
	};

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(4);


/***/ },
/* 167 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * @providesModule ReactGetLayout
	 */
	'use strict';
	
	// get element x, y
	function getCumulativeOffset(obj) {
	  var left, top;
	  left = top = 0;
	  if (obj.offsetParent) {
	    do {
	      left += obj.offsetLeft;
	      top += obj.offsetTop;
	    } while (obj = obj.offsetParent);
	  }
	  return {
	    x: left,
	    y: top
	  };
	}
	
	// this functions returns the x, y, width and height of a given dom node
	function getLayout(element) {
	  var rect = getCumulativeOffset(element);
	  return {
	    x: rect.x,
	    y: rect.y,
	    width: element.offsetWidth,
	    height: element.offsetHeight
	  };
	}
	
	module.exports = getLayout;

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var getVendorPropertyName = __webpack_require__(156);
	
	module.exports = function(target, sources) {
	  var to = Object(target);
	  var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
	    var nextSource = arguments[nextIndex];
	    if (nextSource == null) {
	      continue;
	    }
	
	    var from = Object(nextSource);
	
	    for (var key in from) {
	      if (hasOwnProperty.call(from, key)) {
	        to[key] = from[key];
	      }
	    }
	  }
	
	  var prefixed = {};
	  for (var key in to) {
	    prefixed[getVendorPropertyName(key)] = to[key]
	  }
	
	  return prefixed
	}


/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var insertRule = __webpack_require__(170);
	var vendorPrefix = __webpack_require__(171)();
	var index = 0;
	
	module.exports = function(keyframes) {
	  // random name
	  var name = 'anim_' + (++index) + (+new Date);
	  var css = "@" + vendorPrefix + "keyframes " + name + " {";
	
	  for (var key in keyframes) {
	    css += key + " {";
	
	    for (var property in keyframes[key]) {
	      var part = ":" + keyframes[key][property] + ";";
	      // We do vendor prefix for every property
	      css += vendorPrefix + property + part;
	      css += property + part;
	    }
	
	    css += "}";
	  }
	
	  css += "}";
	
	  insertRule(css);
	
	  return name
	}


/***/ },
/* 170 */
/***/ function(module, exports) {

	'use strict';
	
	var extraSheet;
	
	module.exports = function(css) {
	
	  if (!extraSheet) {
	    // First time, create an extra stylesheet for adding rules
	    extraSheet = document.createElement('style');
	    document.getElementsByTagName('head')[0].appendChild(extraSheet);
	    // Keep reference to actual StyleSheet object (`styleSheet` for IE < 9)
	    extraSheet = extraSheet.sheet || extraSheet.styleSheet;
	  }
	
	  var index = (extraSheet.cssRules || extraSheet.rules).length;
	  extraSheet.insertRule(css, index);
	
	  return extraSheet;
	}


/***/ },
/* 171 */
/***/ function(module, exports) {

	'use strict';
	
	var cssVendorPrefix;
	
	module.exports = function() {
	
	  if (cssVendorPrefix) return cssVendorPrefix;
	
	  var styles = window.getComputedStyle(document.documentElement, '');
	  var pre = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o']))[1];
	
	  return cssVendorPrefix = '-' + pre + '-';
	}


/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * @providesModule ReactDrawerLayout
	 */
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _ReactStyleSheet = __webpack_require__(154);
	
	var _ReactStyleSheet2 = _interopRequireDefault(_ReactStyleSheet);
	
	var _ReactView = __webpack_require__(164);
	
	var _ReactView2 = _interopRequireDefault(_ReactView);
	
	var _ReactAnimated = __webpack_require__(173);
	
	var _ReactAnimated2 = _interopRequireDefault(_ReactAnimated);
	
	var _ReactPanResponder = __webpack_require__(240);
	
	var _ReactPanResponder2 = _interopRequireDefault(_ReactPanResponder);
	
	var _ReactDimensions = __webpack_require__(247);
	
	var _ReactDimensions2 = _interopRequireDefault(_ReactDimensions);
	
	var DEVICE_WIDTH = parseFloat(_ReactDimensions2['default'].get('window').width);
	var THRESHOLD = DEVICE_WIDTH / 2;
	var VX_MAX = 0.1;
	
	var IDLE = 'Idle';
	var DRAGGING = 'Dragging';
	var SETTLING = 'Settling';
	
	var DrawerLayout = _react2['default'].createClass({
	  displayName: 'DrawerLayout',
	
	  statics: {
	    positions: {
	      Left: 'left',
	      Right: 'right'
	    }
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      drawerWidth: 0,
	      drawerPosition: 'left'
	    };
	  },
	
	  propTypes: {
	    drawerWidth: _react.PropTypes.number.isRequired,
	    drawerPosition: _react.PropTypes.oneOf(['left', 'right']).isRequired,
	    renderNavigationView: _react.PropTypes.func.isRequired,
	
	    onDrawerSlide: _react.PropTypes.func,
	    onDrawerStateChanged: _react.PropTypes.func,
	
	    onDrawerOpen: _react.PropTypes.func,
	    onDrawerClose: _react.PropTypes.func,
	
	    /* Not implemented */
	    keyboardDismissMode: _react.PropTypes.oneOf(['none', 'on-drag'])
	  },
	
	  getInitialState: function getInitialState() {
	    return {
	      openValue: new _ReactAnimated2['default'].Value(0)
	    };
	  },
	
	  componentWillMount: function componentWillMount() {
	    var _this = this;
	
	    var openValue = this.state.openValue;
	
	    openValue.addListener(function (_ref) {
	      var value = _ref.value;
	
	      _this._lastOpenValue = value;
	      _this.props.onDrawerSlide && _this.props.onDrawerSlide({ nativeEvent: { offset: value } });
	    });
	
	    this._panResponder = _ReactPanResponder2['default'].create({
	      onMoveShouldSetPanResponder: this._shouldSetPanResponder,
	      onPanResponderGrant: this._panResponderGrant,
	      onPanResponderMove: this._panResponderMove,
	      onPanResponderTerminationRequest: function onPanResponderTerminationRequest(evt, gestureState) {
	        return true;
	      },
	      onPanResponderRelease: this._panResponderRelease,
	      onPanResponderTerminate: function onPanResponderTerminate(evt, gestureState) {}
	    });
	  },
	
	  render: function render() {
	    var openValue = this.state.openValue;
	    var _props = this.props;
	    var drawerPosition = _props.drawerPosition;
	    var drawerWidth = _props.drawerWidth;
	
	    var dynamicDrawerStyles = {};
	    dynamicDrawerStyles[drawerPosition] = 0;
	    dynamicDrawerStyles.width = drawerWidth;
	
	    /* Drawer styles */
	    var outputRange = undefined;
	
	    if (drawerPosition === 'left') {
	      outputRange = [-drawerWidth, 0];
	    } else {
	      outputRange = [drawerWidth, 0];
	    }
	
	    var drawerTranslateX = openValue.interpolate({
	      inputRange: [0, 1],
	      outputRange: outputRange,
	      extrapolate: 'clamp'
	    });
	    var animatedDrawerStyles = { transform: [{ translateX: drawerTranslateX }] };
	
	    /* Overlay styles */
	    // let opacityOutputRange;
	
	    var overlayOpacity = openValue.interpolate({
	      inputRange: [0, 1],
	      outputRange: [0, 0.7],
	      extrapolate: 'clamp'
	    });
	    var animatedOverlayStyles = { opacity: overlayOpacity };
	
	    return _react2['default'].createElement(
	      _ReactView2['default'],
	      _extends({ style: { flex: 1, backgroundColor: 'transparent' } }, this._panResponder.panHandlers),
	      _react2['default'].createElement(
	        _ReactAnimated2['default'].View,
	        { style: styles.main },
	        this.props.children
	      ),
	      _react2['default'].createElement(_ReactAnimated2['default'].View, { style: [styles.overlay, animatedOverlayStyles], onClick: this.close }),
	      _react2['default'].createElement(
	        _ReactAnimated2['default'].View,
	        { style: [styles.drawer, dynamicDrawerStyles, animatedDrawerStyles] },
	        this.props.renderNavigationView()
	      )
	    );
	  },
	
	  _emitStateChanged: function _emitStateChanged(newState) {
	    this.props.onDrawerStateChanged && this.props.onDrawerStateChanged(newState);
	  },
	
	  open: function open() {
	    var _this2 = this;
	
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    this._emitStateChanged(SETTLING);
	    _ReactAnimated2['default'].spring(this.state.openValue, _extends({ toValue: 1, bounciness: 0, restSpeedThreshold: 0.1 }, options)).start(function () {
	      _this2.props.onDrawerOpen && _this2.props.onDrawerOpen();
	      _this2._emitStateChanged(IDLE);
	    });
	  },
	
	  close: function close() {
	    var _this3 = this;
	
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    this._emitStateChanged(SETTLING);
	    _ReactAnimated2['default'].spring(this.state.openValue, _extends({ toValue: 0, bounciness: 0, restSpeedThreshold: 1 }, options)).start(function () {
	      _this3.props.onDrawerClose && _this3.props.onDrawerClose();
	      _this3._emitStateChanged(IDLE);
	    });
	  },
	
	  _handleDrawerOpen: function _handleDrawerOpen() {
	    this.props.onDrawerOpen && this.props.onDrawerOpen();
	  },
	
	  _handleDrawerClose: function _handleDrawerClose() {
	    this.props.onDrawerClose && this.props.onDrawerClose();
	  },
	
	  _shouldSetPanResponder: function _shouldSetPanResponder(e, _ref2) {
	    var moveX = _ref2.moveX;
	    var dx = _ref2.dx;
	    var dy = _ref2.dy;
	    var drawerPosition = this.props.drawerPosition;
	
	    if (drawerPosition === 'left') {
	      var overlayArea = DEVICE_WIDTH - (DEVICE_WIDTH - this.props.drawerWidth);
	
	      if (this._lastOpenValue === 1) {
	        if (dx < 0 && Math.abs(dx) > Math.abs(dy) * 3 || moveX > overlayArea) {
	          this._isClosing = true;
	          this._closingAnchorValue = this._getOpenValueForX(moveX);
	          return true;
	        }
	      } else {
	        if (moveX <= 35 && dx > 0) {
	          this._isClosing = false;
	          return true;
	        } else {
	          return false;
	        }
	      }
	    } else {
	      var overlayArea = DEVICE_WIDTH - this.props.drawerWidth;
	
	      if (this._lastOpenValue === 1) {
	        if (dx > 0 && Math.abs(dx) > Math.abs(dy) * 3 || moveX < overlayArea) {
	          this._isClosing = true;
	          this._closingAnchorValue = this._getOpenValueForX(moveX);
	          return true;
	        }
	      } else {
	        if (moveX >= DEVICE_WIDTH - 35 && dx < 0) {
	          this._isClosing = false;
	          return true;
	        } else {
	          return false;
	        }
	      }
	    }
	  },
	
	  _panResponderGrant: function _panResponderGrant() {
	    this._emitStateChanged(DRAGGING);
	  },
	
	  _panResponderMove: function _panResponderMove(e, _ref3) {
	    var moveX = _ref3.moveX;
	
	    var openValue = this._getOpenValueForX(moveX);
	
	    if (this._isClosing) {
	      openValue = 1 - (this._closingAnchorValue - openValue);
	    }
	
	    if (openValue > 1) {
	      openValue = 1;
	    } else if (openValue < 0) {
	      openValue = 0;
	    }
	
	    this.state.openValue.setValue(openValue);
	  },
	
	  _panResponderRelease: function _panResponderRelease(e, _ref4) {
	    var moveX = _ref4.moveX;
	    var vx = _ref4.vx;
	    var drawerPosition = this.props.drawerPosition;
	
	    // let { openValue } = this.state;
	    var previouslyOpen = this._isClosing;
	    var isWithinVelocityThreshold = vx < VX_MAX && vx > -VX_MAX;
	
	    if (drawerPosition === 'left') {
	      if (vx > 0 && moveX > THRESHOLD || vx >= VX_MAX || isWithinVelocityThreshold && previouslyOpen && moveX > THRESHOLD) {
	        this.open({ velocity: vx });
	      } else if (vx < 0 && moveX < THRESHOLD || vx < -VX_MAX || isWithinVelocityThreshold && !previouslyOpen) {
	        this.close({ velocity: vx });
	      } else if (previouslyOpen) {
	        this.open();
	      } else {
	        this.close();
	      }
	    } else {
	      if (vx < 0 && moveX < THRESHOLD || vx <= -VX_MAX || isWithinVelocityThreshold && previouslyOpen && moveX < THRESHOLD) {
	        this.open({ velocity: -1 * vx });
	      } else if (vx > 0 && moveX > THRESHOLD || vx > VX_MAX || isWithinVelocityThreshold && !previouslyOpen) {
	        this.close({ velocity: -1 * vx });
	      } else if (previouslyOpen) {
	        this.open();
	      } else {
	        this.close();
	      }
	    }
	  },
	
	  _getOpenValueForX: function _getOpenValueForX(x) {
	    var _props2 = this.props;
	    var drawerPosition = _props2.drawerPosition;
	    var drawerWidth = _props2.drawerWidth;
	
	    if (drawerPosition === 'left') {
	      return x / drawerWidth;
	    } else if (drawerPosition === 'right') {
	      return (DEVICE_WIDTH - x) / drawerWidth;
	    }
	  }
	});
	
	var styles = _ReactStyleSheet2['default'].create({
	  drawer: {
	    position: 'absolute',
	    top: 0,
	    bottom: 0
	  },
	  main: {
	    flex: 1
	  },
	  overlay: {
	    backgroundColor: '#000',
	    position: 'absolute',
	    top: 0,
	    left: 0,
	    bottom: 0,
	    right: 0
	  }
	});
	
	exports['default'] = DrawerLayout;
	module.exports = exports['default'];

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * @providesModule ReactAnimated
	 * 
	 */
	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _AnimatedImplementation = __webpack_require__(174);
	
	var _AnimatedImplementation2 = _interopRequireDefault(_AnimatedImplementation);
	
	var _ReactImage = __webpack_require__(233);
	
	var _ReactImage2 = _interopRequireDefault(_ReactImage);
	
	var _ReactText = __webpack_require__(236);
	
	var _ReactText2 = _interopRequireDefault(_ReactText);
	
	var _ReactView = __webpack_require__(164);
	
	var _ReactView2 = _interopRequireDefault(_ReactView);
	
	module.exports = _extends({}, _AnimatedImplementation2['default'], {
	  View: _AnimatedImplementation2['default'].createAnimatedComponent(_ReactView2['default']),
	  Text: _AnimatedImplementation2['default'].createAnimatedComponent(_ReactText2['default']),
	  Image: _AnimatedImplementation2['default'].createAnimatedComponent(_ReactImage2['default'])
	});

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * 
	 */
	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _ReactEasing = __webpack_require__(175);
	
	var _ReactEasing2 = _interopRequireDefault(_ReactEasing);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _ReactInteractionManager = __webpack_require__(178);
	
	var _ReactInteractionManager2 = _interopRequireDefault(_ReactInteractionManager);
	
	var _Interpolation = __webpack_require__(179);
	
	var _Interpolation2 = _interopRequireDefault(_Interpolation);
	
	var _coreJsLibraryFnSet = __webpack_require__(181);
	
	var _coreJsLibraryFnSet2 = _interopRequireDefault(_coreJsLibraryFnSet);
	
	var _SpringConfig = __webpack_require__(230);
	
	var _SpringConfig2 = _interopRequireDefault(_SpringConfig);
	
	var _ReactFlattenStyle = __webpack_require__(162);
	
	var _ReactFlattenStyle2 = _interopRequireDefault(_ReactFlattenStyle);
	
	var _fbjsLibInvariant = __webpack_require__(231);
	
	var _fbjsLibInvariant2 = _interopRequireDefault(_fbjsLibInvariant);
	
	var _polyfillsRequestAnimationFrame = __webpack_require__(232);
	
	var _polyfillsRequestAnimationFrame2 = _interopRequireDefault(_polyfillsRequestAnimationFrame);
	
	// Note(vjeux): this would be better as an interface but flow doesn't
	// support them yet
	
	var Animated = (function () {
	  function Animated() {
	    _classCallCheck(this, Animated);
	  }
	
	  // Important note: start() and stop() will only be called at most once.
	  // Once an animation has been stopped or finished its course, it will
	  // not be reused.
	
	  _createClass(Animated, [{
	    key: '__attach',
	    value: function __attach() {}
	  }, {
	    key: '__detach',
	    value: function __detach() {}
	  }, {
	    key: '__getValue',
	    value: function __getValue() {}
	  }, {
	    key: '__getAnimatedValue',
	    value: function __getAnimatedValue() {
	      return this.__getValue();
	    }
	  }, {
	    key: '__addChild',
	    value: function __addChild(child) {}
	  }, {
	    key: '__removeChild',
	    value: function __removeChild(child) {}
	  }, {
	    key: '__getChildren',
	    value: function __getChildren() {
	      return [];
	    }
	  }]);
	
	  return Animated;
	})();
	
	var Animation = (function () {
	  function Animation() {
	    _classCallCheck(this, Animation);
	  }
	
	  _createClass(Animation, [{
	    key: 'start',
	    value: function start(fromValue, onUpdate, onEnd, previousAnimation) {}
	  }, {
	    key: 'stop',
	    value: function stop() {}
	
	    // Helper function for subclasses to make sure onEnd is only called once.
	  }, {
	    key: '__debouncedOnEnd',
	    value: function __debouncedOnEnd(result) {
	      var onEnd = this.__onEnd;
	      this.__onEnd = null;
	      onEnd && onEnd(result);
	    }
	  }]);
	
	  return Animation;
	})();
	
	var AnimatedWithChildren = (function (_Animated) {
	  _inherits(AnimatedWithChildren, _Animated);
	
	  function AnimatedWithChildren() {
	    _classCallCheck(this, AnimatedWithChildren);
	
	    _get(Object.getPrototypeOf(AnimatedWithChildren.prototype), 'constructor', this).call(this);
	    this._children = [];
	  }
	
	  /**
	   * Animated works by building a directed acyclic graph of dependencies
	   * transparently when you render your Animated components.
	   *
	   *               new Animated.Value(0)
	   *     .interpolate()        .interpolate()    new Animated.Value(1)
	   *         opacity               translateY      scale
	   *          style                         transform
	   *         View#234                         style
	   *                                         View#123
	   *
	   * A) Top Down phase
	   * When an Animated.Value is updated, we recursively go down through this
	   * graph in order to find leaf nodes: the views that we flag as needing
	   * an update.
	   *
	   * B) Bottom Up phase
	   * When a view is flagged as needing an update, we recursively go back up
	   * in order to build the new value that it needs. The reason why we need
	   * this two-phases process is to deal with composite props such as
	   * transform which can receive values from multiple parents.
	   */
	
	  _createClass(AnimatedWithChildren, [{
	    key: '__addChild',
	    value: function __addChild(child) {
	      if (this._children.length === 0) {
	        this.__attach();
	      }
	      this._children.push(child);
	    }
	  }, {
	    key: '__removeChild',
	    value: function __removeChild(child) {
	      var index = this._children.indexOf(child);
	      if (index === -1) {
	        console.warn('Trying to remove a child that doesn\'t exist');
	        return;
	      }
	      this._children.splice(index, 1);
	      if (this._children.length === 0) {
	        this.__detach();
	      }
	    }
	  }, {
	    key: '__getChildren',
	    value: function __getChildren() {
	      return this._children;
	    }
	  }]);
	
	  return AnimatedWithChildren;
	})(Animated);
	
	function _flush(rootNode) {
	  var animatedStyles = new _coreJsLibraryFnSet2['default']();
	  function findAnimatedStyles(node) {
	    if (typeof node.update === 'function') {
	      animatedStyles.add(node);
	    } else {
	      node.__getChildren().forEach(findAnimatedStyles);
	    }
	  }
	  findAnimatedStyles(rootNode);
	  animatedStyles.forEach(function (animatedStyle) {
	    return animatedStyle.update();
	  });
	}
	
	var easeInOut = _ReactEasing2['default'].inOut(_ReactEasing2['default'].ease);
	
	var TimingAnimation = (function (_Animation) {
	  _inherits(TimingAnimation, _Animation);
	
	  function TimingAnimation(config) {
	    _classCallCheck(this, TimingAnimation);
	
	    _get(Object.getPrototypeOf(TimingAnimation.prototype), 'constructor', this).call(this);
	    this._toValue = config.toValue;
	    this._easing = config.easing || easeInOut;
	    this._duration = config.duration !== undefined ? config.duration : 500;
	    this._delay = config.delay || 0;
	  }
	
	  _createClass(TimingAnimation, [{
	    key: 'start',
	    value: function start(fromValue, onUpdate, onEnd) {
	      var _this = this;
	
	      this.__active = true;
	      this._fromValue = fromValue;
	      this._onUpdate = onUpdate;
	      this.__onEnd = onEnd;
	
	      var start = function start() {
	        if (_this._duration === 0) {
	          _this._onUpdate(_this._toValue);
	          _this.__debouncedOnEnd({ finished: true });
	        } else {
	          _this._startTime = Date.now();
	          _this._animationFrame = (0, _polyfillsRequestAnimationFrame2['default'])(_this.onUpdate.bind(_this));
	        }
	      };
	      if (this._delay) {
	        this._timeout = setTimeout(start, this._delay);
	      } else {
	        start();
	      }
	    }
	  }, {
	    key: 'onUpdate',
	    value: function onUpdate() {
	      var now = Date.now();
	      if (now >= this._startTime + this._duration) {
	        if (this._duration === 0) {
	          this._onUpdate(this._toValue);
	        } else {
	          this._onUpdate(this._fromValue + this._easing(1) * (this._toValue - this._fromValue));
	        }
	        this.__debouncedOnEnd({ finished: true });
	        return;
	      }
	
	      this._onUpdate(this._fromValue + this._easing((now - this._startTime) / this._duration) * (this._toValue - this._fromValue));
	      if (this.__active) {
	        this._animationFrame = (0, _polyfillsRequestAnimationFrame2['default'])(this.onUpdate.bind(this));
	      }
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      this.__active = false;
	      clearTimeout(this._timeout);
	      window.cancelAnimationFrame(this._animationFrame);
	      this.__debouncedOnEnd({ finished: false });
	    }
	  }]);
	
	  return TimingAnimation;
	})(Animation);
	
	var DecayAnimation = (function (_Animation2) {
	  _inherits(DecayAnimation, _Animation2);
	
	  function DecayAnimation(config) {
	    _classCallCheck(this, DecayAnimation);
	
	    _get(Object.getPrototypeOf(DecayAnimation.prototype), 'constructor', this).call(this);
	    this._deceleration = config.deceleration || 0.998;
	    this._velocity = config.velocity;
	  }
	
	  _createClass(DecayAnimation, [{
	    key: 'start',
	    value: function start(fromValue, onUpdate, onEnd) {
	      this.__active = true;
	      this._lastValue = fromValue;
	      this._fromValue = fromValue;
	      this._onUpdate = onUpdate;
	      this.__onEnd = onEnd;
	      this._startTime = Date.now();
	      this._animationFrame = (0, _polyfillsRequestAnimationFrame2['default'])(this.onUpdate.bind(this));
	    }
	  }, {
	    key: 'onUpdate',
	    value: function onUpdate() {
	      var now = Date.now();
	
	      var value = this._fromValue + this._velocity / (1 - this._deceleration) * (1 - Math.exp(-(1 - this._deceleration) * (now - this._startTime)));
	
	      this._onUpdate(value);
	
	      if (Math.abs(this._lastValue - value) < 0.1) {
	        this.__debouncedOnEnd({ finished: true });
	        return;
	      }
	
	      this._lastValue = value;
	      if (this.__active) {
	        this._animationFrame = (0, _polyfillsRequestAnimationFrame2['default'])(this.onUpdate.bind(this));
	      }
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      this.__active = false;
	      window.cancelAnimationFrame(this._animationFrame);
	      this.__debouncedOnEnd({ finished: false });
	    }
	  }]);
	
	  return DecayAnimation;
	})(Animation);
	
	function withDefault(value, defaultValue) {
	  if (value === undefined || value === null) {
	    return defaultValue;
	  }
	  return value;
	}
	
	var SpringAnimation = (function (_Animation3) {
	  _inherits(SpringAnimation, _Animation3);
	
	  function SpringAnimation(config) {
	    _classCallCheck(this, SpringAnimation);
	
	    _get(Object.getPrototypeOf(SpringAnimation.prototype), 'constructor', this).call(this);
	
	    this._overshootClamping = withDefault(config.overshootClamping, false);
	    this._restDisplacementThreshold = withDefault(config.restDisplacementThreshold, 0.001);
	    this._restSpeedThreshold = withDefault(config.restSpeedThreshold, 0.001);
	    this._initialVelocity = config.velocity;
	    this._lastVelocity = withDefault(config.velocity, 0);
	    this._toValue = config.toValue;
	
	    var springConfig;
	    if (config.bounciness !== undefined || config.speed !== undefined) {
	      (0, _fbjsLibInvariant2['default'])(config.tension === undefined && config.friction === undefined, 'You can only define bounciness/speed or tension/friction but not both');
	      springConfig = _SpringConfig2['default'].fromBouncinessAndSpeed(withDefault(config.bounciness, 8), withDefault(config.speed, 12));
	    } else {
	      springConfig = _SpringConfig2['default'].fromOrigamiTensionAndFriction(withDefault(config.tension, 40), withDefault(config.friction, 7));
	    }
	    this._tension = springConfig.tension;
	    this._friction = springConfig.friction;
	  }
	
	  _createClass(SpringAnimation, [{
	    key: 'start',
	    value: function start(fromValue, onUpdate, onEnd, previousAnimation) {
	      this.__active = true;
	      this._startPosition = fromValue;
	      this._lastPosition = this._startPosition;
	
	      this._onUpdate = onUpdate;
	      this.__onEnd = onEnd;
	      this._lastTime = Date.now();
	
	      if (previousAnimation instanceof SpringAnimation) {
	        var internalState = previousAnimation.getInternalState();
	        this._lastPosition = internalState.lastPosition;
	        this._lastVelocity = internalState.lastVelocity;
	        this._lastTime = internalState.lastTime;
	      }
	      if (this._initialVelocity !== undefined && this._initialVelocity !== null) {
	        this._lastVelocity = this._initialVelocity;
	      }
	      this.onUpdate();
	    }
	  }, {
	    key: 'getInternalState',
	    value: function getInternalState() {
	      return {
	        lastPosition: this._lastPosition,
	        lastVelocity: this._lastVelocity,
	        lastTime: this._lastTime
	      };
	    }
	  }, {
	    key: 'onUpdate',
	    value: function onUpdate() {
	      var position = this._lastPosition;
	      var velocity = this._lastVelocity;
	
	      var tempPosition = this._lastPosition;
	      var tempVelocity = this._lastVelocity;
	
	      // If for some reason we lost a lot of frames (e.g. process large payload or
	      // stopped in the debugger), we only advance by 4 frames worth of
	      // computation and will continue on the next frame. It's better to have it
	      // running at faster speed than jumping to the end.
	      var MAX_STEPS = 64;
	      var now = Date.now();
	      if (now > this._lastTime + MAX_STEPS) {
	        now = this._lastTime + MAX_STEPS;
	      }
	
	      // We are using a fixed time step and a maximum number of iterations.
	      // The following post provides a lot of thoughts into how to build this
	      // loop: http://gafferongames.com/game-physics/fix-your-timestep/
	      var TIMESTEP_MSEC = 1;
	      var numSteps = Math.floor((now - this._lastTime) / TIMESTEP_MSEC);
	
	      for (var i = 0; i < numSteps; ++i) {
	        // Velocity is based on seconds instead of milliseconds
	        var step = TIMESTEP_MSEC / 1000;
	
	        // This is using RK4. A good blog post to understand how it works:
	        // http://gafferongames.com/game-physics/integration-basics/
	        var aVelocity = velocity;
	        var aAcceleration = this._tension * (this._toValue - tempPosition) - this._friction * tempVelocity;
	        var tempPosition = position + aVelocity * step / 2;
	        var tempVelocity = velocity + aAcceleration * step / 2;
	
	        var bVelocity = tempVelocity;
	        var bAcceleration = this._tension * (this._toValue - tempPosition) - this._friction * tempVelocity;
	        tempPosition = position + bVelocity * step / 2;
	        tempVelocity = velocity + bAcceleration * step / 2;
	
	        var cVelocity = tempVelocity;
	        var cAcceleration = this._tension * (this._toValue - tempPosition) - this._friction * tempVelocity;
	        tempPosition = position + cVelocity * step / 2;
	        tempVelocity = velocity + cAcceleration * step / 2;
	
	        var dVelocity = tempVelocity;
	        var dAcceleration = this._tension * (this._toValue - tempPosition) - this._friction * tempVelocity;
	        tempPosition = position + cVelocity * step / 2;
	        tempVelocity = velocity + cAcceleration * step / 2;
	
	        var dxdt = (aVelocity + 2 * (bVelocity + cVelocity) + dVelocity) / 6;
	        var dvdt = (aAcceleration + 2 * (bAcceleration + cAcceleration) + dAcceleration) / 6;
	
	        position += dxdt * step;
	        velocity += dvdt * step;
	      }
	
	      this._lastTime = now;
	      this._lastPosition = position;
	      this._lastVelocity = velocity;
	
	      this._onUpdate(position);
	      if (!this.__active) {
	        // a listener might have stopped us in _onUpdate
	        return;
	      }
	
	      // Conditions for stopping the spring animation
	      var isOvershooting = false;
	      if (this._overshootClamping && this._tension !== 0) {
	        if (this._startPosition < this._toValue) {
	          isOvershooting = position > this._toValue;
	        } else {
	          isOvershooting = position < this._toValue;
	        }
	      }
	      var isVelocity = Math.abs(velocity) <= this._restSpeedThreshold;
	      var isDisplacement = true;
	      if (this._tension !== 0) {
	        isDisplacement = Math.abs(this._toValue - position) <= this._restDisplacementThreshold;
	      }
	
	      if (isOvershooting || isVelocity && isDisplacement) {
	        if (this._tension !== 0) {
	          // Ensure that we end up with a round value
	          this._onUpdate(this._toValue);
	        }
	
	        this.__debouncedOnEnd({ finished: true });
	        return;
	      }
	      this._animationFrame = (0, _polyfillsRequestAnimationFrame2['default'])(this.onUpdate.bind(this));
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      this.__active = false;
	      window.cancelAnimationFrame(this._animationFrame);
	      this.__debouncedOnEnd({ finished: false });
	    }
	  }]);
	
	  return SpringAnimation;
	})(Animation);
	
	var _uniqueId = 1;
	
	/**
	 * Standard value for driving animations.  One `Animated.Value` can drive
	 * multiple properties in a synchronized fashion, but can only be driven by one
	 * mechanism at a time.  Using a new mechanism (e.g. starting a new animation,
	 * or calling `setValue`) will stop any previous ones.
	 */
	
	var AnimatedValue = (function (_AnimatedWithChildren) {
	  _inherits(AnimatedValue, _AnimatedWithChildren);
	
	  function AnimatedValue(value) {
	    _classCallCheck(this, AnimatedValue);
	
	    _get(Object.getPrototypeOf(AnimatedValue.prototype), 'constructor', this).call(this);
	    this._value = value;
	    this._offset = 0;
	    this._animation = null;
	    this._listeners = {};
	  }
	
	  _createClass(AnimatedValue, [{
	    key: '__detach',
	    value: function __detach() {
	      this.stopAnimation();
	    }
	  }, {
	    key: '__getValue',
	    value: function __getValue() {
	      return this._value + this._offset;
	    }
	
	    /**
	     * Directly set the value.  This will stop any animations running on the value
	     * and udpate all the bound properties.
	     */
	  }, {
	    key: 'setValue',
	    value: function setValue(value) {
	      if (this._animation) {
	        this._animation.stop();
	        this._animation = null;
	      }
	      this._updateValue(value);
	    }
	
	    /**
	     * Sets an offset that is applied on top of whatever value is set, whether via
	     * `setValue`, an animation, or `Animated.event`.  Useful for compensating
	     * things like the start of a pan gesture.
	     */
	  }, {
	    key: 'setOffset',
	    value: function setOffset(offset) {
	      this._offset = offset;
	    }
	
	    /**
	     * Merges the offset value into the base value and resets the offset to zero.
	     * The final output of the value is unchanged.
	     */
	  }, {
	    key: 'flattenOffset',
	    value: function flattenOffset() {
	      this._value += this._offset;
	      this._offset = 0;
	    }
	
	    /**
	     * Adds an asynchronous listener to the value so you can observe updates from
	     * animations or whathaveyou.  This is useful because there is no way to
	     * syncronously read the value because it might be driven natively.
	     */
	  }, {
	    key: 'addListener',
	    value: function addListener(callback) {
	      var id = String(_uniqueId++);
	      this._listeners[id] = callback;
	      return id;
	    }
	  }, {
	    key: 'removeListener',
	    value: function removeListener(id) {
	      delete this._listeners[id];
	    }
	  }, {
	    key: 'removeAllListeners',
	    value: function removeAllListeners() {
	      this._listeners = {};
	    }
	
	    /**
	     * Stops any running animation or tracking.  `callback` is invoked with the
	     * final value after stopping the animation, which is useful for updating
	     * state to match the animation position with layout.
	     */
	  }, {
	    key: 'stopAnimation',
	    value: function stopAnimation(callback) {
	      this.stopTracking();
	      this._animation && this._animation.stop();
	      this._animation = null;
	      callback && callback(this.__getValue());
	    }
	
	    /**
	     * Interpolates the value before updating the property, e.g. mapping 0-1 to
	     * 0-10.
	     */
	  }, {
	    key: 'interpolate',
	    value: function interpolate(config) {
	      return new AnimatedInterpolation(this, _Interpolation2['default'].create(config));
	    }
	
	    /**
	     * Typically only used internally, but could be used by a custom Animation
	     * class.
	     */
	  }, {
	    key: 'animate',
	    value: function animate(animation, callback) {
	      var _this2 = this;
	
	      var handle = _ReactInteractionManager2['default'].createInteractionHandle();
	      var previousAnimation = this._animation;
	      this._animation && this._animation.stop();
	      this._animation = animation;
	      animation.start(this._value, function (value) {
	        _this2._updateValue(value);
	      }, function (result) {
	        _this2._animation = null;
	        _ReactInteractionManager2['default'].clearInteractionHandle(handle);
	        callback && callback(result);
	      }, previousAnimation);
	    }
	
	    /**
	     * Typically only used internally.
	     */
	  }, {
	    key: 'stopTracking',
	    value: function stopTracking() {
	      this._tracking && this._tracking.__detach();
	      this._tracking = null;
	    }
	
	    /**
	     * Typically only used internally.
	     */
	  }, {
	    key: 'track',
	    value: function track(tracking) {
	      this.stopTracking();
	      this._tracking = tracking;
	    }
	  }, {
	    key: '_updateValue',
	    value: function _updateValue(value) {
	      this._value = value;
	      _flush(this);
	      for (var key in this._listeners) {
	        this._listeners[key]({ value: this.__getValue() });
	      }
	    }
	  }]);
	
	  return AnimatedValue;
	})(AnimatedWithChildren);
	
	/**
	 * 2D Value for driving 2D animations, such as pan gestures.  Almost identical
	 * API to normal `Animated.Value`, but multiplexed.  Contains two regular
	 * `Animated.Value`s under the hood.  Example:
	 *
	 *```javascript
	 *  class DraggableView extends React.Component {
	 *    constructor(props) {
	 *      super(props);
	 *      this.state = {
	 *        pan: new Animated.ValueXY(), // inits to zero
	 *      };
	 *      this.state.panResponder = PanResponder.create({
	 *        onStartShouldSetPanResponder: () => true,
	 *        onPanResponderMove: Animated.event([null, {
	 *          dx: this.state.pan.x, // x,y are Animated.Value
	 *          dy: this.state.pan.y,
	 *        }]),
	 *        onPanResponderRelease: () => {
	 *          Animated.spring(
	 *            this.state.pan,         // Auto-multiplexed
	 *            {toValue: {x: 0, y: 0}} // Back to zero
	 *          ).start();
	 *        },
	 *      });
	 *    }
	 *    render() {
	 *      return (
	 *        <Animated.View
	 *          {...this.state.panResponder.panHandlers}
	 *          style={this.state.pan.getLayout()}>
	 *          {this.props.children}
	 *        </Animated.View>
	 *      );
	 *    }
	 *  }
	 *```
	 */
	
	var AnimatedValueXY = (function (_AnimatedWithChildren2) {
	  _inherits(AnimatedValueXY, _AnimatedWithChildren2);
	
	  function AnimatedValueXY(valueIn) {
	    _classCallCheck(this, AnimatedValueXY);
	
	    _get(Object.getPrototypeOf(AnimatedValueXY.prototype), 'constructor', this).call(this);
	    var value = valueIn || { x: 0, y: 0 }; // fixme: shouldn't need `: any`
	    if (typeof value.x === 'number' && typeof value.y === 'number') {
	      this.x = new AnimatedValue(value.x);
	      this.y = new AnimatedValue(value.y);
	    } else {
	      (0, _fbjsLibInvariant2['default'])(value.x instanceof AnimatedValue && value.y instanceof AnimatedValue, 'AnimatedValueXY must be initalized with an object of numbers or ' + 'AnimatedValues.');
	      this.x = value.x;
	      this.y = value.y;
	    }
	    this._listeners = {};
	  }
	
	  _createClass(AnimatedValueXY, [{
	    key: 'setValue',
	    value: function setValue(value) {
	      this.x.setValue(value.x);
	      this.y.setValue(value.y);
	    }
	  }, {
	    key: 'setOffset',
	    value: function setOffset(offset) {
	      this.x.setOffset(offset.x);
	      this.y.setOffset(offset.y);
	    }
	  }, {
	    key: 'flattenOffset',
	    value: function flattenOffset() {
	      this.x.flattenOffset();
	      this.y.flattenOffset();
	    }
	  }, {
	    key: '__getValue',
	    value: function __getValue() {
	      return {
	        x: this.x.__getValue(),
	        y: this.y.__getValue()
	      };
	    }
	  }, {
	    key: 'stopAnimation',
	    value: function stopAnimation(callback) {
	      this.x.stopAnimation();
	      this.y.stopAnimation();
	      callback && callback(this.__getValue());
	    }
	  }, {
	    key: 'addListener',
	    value: function addListener(callback) {
	      var _this3 = this;
	
	      var id = String(_uniqueId++);
	      var jointCallback = function jointCallback(_ref) {
	        var number = _ref.value;
	
	        callback(_this3.__getValue());
	      };
	      this._listeners[id] = {
	        x: this.x.addListener(jointCallback),
	        y: this.y.addListener(jointCallback)
	      };
	      return id;
	    }
	  }, {
	    key: 'removeListener',
	    value: function removeListener(id) {
	      this.x.removeListener(this._listeners[id].x);
	      this.y.removeListener(this._listeners[id].y);
	      delete this._listeners[id];
	    }
	
	    /**
	     * Converts `{x, y}` into `{left, top}` for use in style, e.g.
	     *
	     *```javascript
	     *  style={this.state.anim.getLayout()}
	     *```
	     */
	  }, {
	    key: 'getLayout',
	    value: function getLayout() {
	      return {
	        left: this.x,
	        top: this.y
	      };
	    }
	
	    /**
	     * Converts `{x, y}` into a useable translation transform, e.g.
	     *
	     *```javascript
	     *  style={{
	     *    transform: this.state.anim.getTranslateTransform()
	     *  }}
	     *```
	     */
	  }, {
	    key: 'getTranslateTransform',
	    value: function getTranslateTransform() {
	      return [{ translateX: this.x }, { translateY: this.y }];
	    }
	  }]);
	
	  return AnimatedValueXY;
	})(AnimatedWithChildren);
	
	var AnimatedInterpolation = (function (_AnimatedWithChildren3) {
	  _inherits(AnimatedInterpolation, _AnimatedWithChildren3);
	
	  function AnimatedInterpolation(parent, interpolation) {
	    _classCallCheck(this, AnimatedInterpolation);
	
	    _get(Object.getPrototypeOf(AnimatedInterpolation.prototype), 'constructor', this).call(this);
	    this._parent = parent;
	    this._interpolation = interpolation;
	  }
	
	  _createClass(AnimatedInterpolation, [{
	    key: '__getValue',
	    value: function __getValue() {
	      var parentValue = this._parent.__getValue();
	      (0, _fbjsLibInvariant2['default'])(typeof parentValue === 'number', 'Cannot interpolate an input which is not a number.');
	      return this._interpolation(parentValue);
	    }
	  }, {
	    key: 'interpolate',
	    value: function interpolate(config) {
	      return new AnimatedInterpolation(this, _Interpolation2['default'].create(config));
	    }
	  }, {
	    key: '__attach',
	    value: function __attach() {
	      this._parent.__addChild(this);
	    }
	  }, {
	    key: '__detach',
	    value: function __detach() {
	      this._parent.__removeChild(this);
	    }
	  }]);
	
	  return AnimatedInterpolation;
	})(AnimatedWithChildren);
	
	var AnimatedTransform = (function (_AnimatedWithChildren4) {
	  _inherits(AnimatedTransform, _AnimatedWithChildren4);
	
	  function AnimatedTransform(transforms) {
	    _classCallCheck(this, AnimatedTransform);
	
	    _get(Object.getPrototypeOf(AnimatedTransform.prototype), 'constructor', this).call(this);
	    this._transforms = transforms;
	  }
	
	  _createClass(AnimatedTransform, [{
	    key: '__getValue',
	    value: function __getValue() {
	      // return this._transforms.map(transform => {
	      //   var result = {};
	      //   for (var key in transform) {
	      //     var value = transform[key];
	      //     if (value instanceof Animated) {
	      //       result[key] = value.__getValue();
	      //     } else {
	      //       result[key] = value;
	      //     }
	      //   }
	      //   return result;
	      // });
	
	      // NOTE: transform的处理在StyleSheet中
	      return this._transforms;
	    }
	  }, {
	    key: '__getAnimatedValue',
	    value: function __getAnimatedValue() {
	      return this._transforms.map(function (transform) {
	        var result = {};
	        for (var key in transform) {
	          var value = transform[key];
	          if (value instanceof Animated) {
	            result[key] = value.__getAnimatedValue();
	          } else {
	            // All transform components needed to recompose matrix
	            result[key] = value;
	          }
	        }
	        return result;
	      });
	    }
	  }, {
	    key: '__attach',
	    value: function __attach() {
	      var _this4 = this;
	
	      this._transforms.forEach(function (transform) {
	        for (var key in transform) {
	          var value = transform[key];
	          if (value instanceof Animated) {
	            value.__addChild(_this4);
	          }
	        }
	      });
	    }
	  }, {
	    key: '__detach',
	    value: function __detach() {
	      var _this5 = this;
	
	      this._transforms.forEach(function (transform) {
	        for (var key in transform) {
	          var value = transform[key];
	          if (value instanceof Animated) {
	            value.__removeChild(_this5);
	          }
	        }
	      });
	    }
	  }]);
	
	  return AnimatedTransform;
	})(AnimatedWithChildren);
	
	var AnimatedStyle = (function (_AnimatedWithChildren5) {
	  _inherits(AnimatedStyle, _AnimatedWithChildren5);
	
	  function AnimatedStyle(style) {
	    _classCallCheck(this, AnimatedStyle);
	
	    _get(Object.getPrototypeOf(AnimatedStyle.prototype), 'constructor', this).call(this);
	    style = (0, _ReactFlattenStyle2['default'])(style) || {};
	    if (style.transform) {
	      style = _extends({}, style, {
	        transform: new AnimatedTransform(style.transform)
	      });
	    }
	    this._style = style;
	  }
	
	  _createClass(AnimatedStyle, [{
	    key: '__getValue',
	    value: function __getValue() {
	      var style = {};
	      for (var key in this._style) {
	        var value = this._style[key];
	        if (value instanceof Animated) {
	          style[key] = value.__getValue();
	        } else {
	          style[key] = value;
	        }
	      }
	      return style;
	    }
	  }, {
	    key: '__getAnimatedValue',
	    value: function __getAnimatedValue() {
	      var style = {};
	      for (var key in this._style) {
	        var value = this._style[key];
	        if (value instanceof Animated) {
	          style[key] = value.__getAnimatedValue();
	        }
	      }
	      return style;
	    }
	  }, {
	    key: '__attach',
	    value: function __attach() {
	      for (var key in this._style) {
	        var value = this._style[key];
	        if (value instanceof Animated) {
	          value.__addChild(this);
	        }
	      }
	    }
	  }, {
	    key: '__detach',
	    value: function __detach() {
	      for (var key in this._style) {
	        var value = this._style[key];
	        if (value instanceof Animated) {
	          value.__removeChild(this);
	        }
	      }
	    }
	  }]);
	
	  return AnimatedStyle;
	})(AnimatedWithChildren);
	
	var AnimatedProps = (function (_Animated2) {
	  _inherits(AnimatedProps, _Animated2);
	
	  function AnimatedProps(props, callback) {
	    _classCallCheck(this, AnimatedProps);
	
	    _get(Object.getPrototypeOf(AnimatedProps.prototype), 'constructor', this).call(this);
	    if (props.style) {
	      props = _extends({}, props, {
	        style: new AnimatedStyle(props.style)
	      });
	    }
	    this._props = props;
	    this._callback = callback;
	    this.__attach();
	  }
	
	  _createClass(AnimatedProps, [{
	    key: '__getValue',
	    value: function __getValue() {
	      var props = {};
	      for (var key in this._props) {
	        var value = this._props[key];
	        if (value instanceof Animated) {
	          props[key] = value.__getValue();
	        } else {
	          props[key] = value;
	        }
	      }
	      return props;
	    }
	  }, {
	    key: '__getAnimatedValue',
	    value: function __getAnimatedValue() {
	      var props = {};
	      for (var key in this._props) {
	        var value = this._props[key];
	        if (value instanceof Animated) {
	          props[key] = value.__getAnimatedValue();
	        }
	      }
	      return props;
	    }
	  }, {
	    key: '__attach',
	    value: function __attach() {
	      for (var key in this._props) {
	        var value = this._props[key];
	        if (value instanceof Animated) {
	          value.__addChild(this);
	        }
	      }
	    }
	  }, {
	    key: '__detach',
	    value: function __detach() {
	      for (var key in this._props) {
	        var value = this._props[key];
	        if (value instanceof Animated) {
	          value.__removeChild(this);
	        }
	      }
	    }
	  }, {
	    key: 'update',
	    value: function update() {
	      this._callback();
	    }
	  }]);
	
	  return AnimatedProps;
	})(Animated);
	
	function createAnimatedComponent(Component) {
	  var refName = 'node';
	
	  var AnimatedComponent = (function (_React$Component) {
	    _inherits(AnimatedComponent, _React$Component);
	
	    function AnimatedComponent() {
	      _classCallCheck(this, AnimatedComponent);
	
	      _get(Object.getPrototypeOf(AnimatedComponent.prototype), 'constructor', this).apply(this, arguments);
	    }
	
	    // NOTE: added for type check
	
	    _createClass(AnimatedComponent, [{
	      key: 'componentWillUnmount',
	      value: function componentWillUnmount() {
	        this._propsAnimated && this._propsAnimated.__detach();
	      }
	    }, {
	      key: 'setNativeProps',
	      value: function setNativeProps(props) {
	        this.refs[refName].setNativeProps(props);
	      }
	    }, {
	      key: 'componentWillMount',
	      value: function componentWillMount() {
	        this.attachProps(this.props);
	      }
	    }, {
	      key: 'attachProps',
	      value: function attachProps(nextProps) {
	        var _this6 = this;
	
	        var oldPropsAnimated = this._propsAnimated;
	
	        // The system is best designed when setNativeProps is implemented. It is
	        // able to avoid re-rendering and directly set the attributes that
	        // changed. However, setNativeProps can only be implemented on leaf
	        // native components. If you want to animate a composite component, you
	        // need to re-render it. In this case, we have a fallback that uses
	        // forceUpdate.
	        var callback = function callback() {
	          if (_this6.refs[refName].setNativeProps) {
	            var value = _this6._propsAnimated.__getAnimatedValue();
	            _this6.refs[refName].setNativeProps(value);
	          } else {
	            _this6.forceUpdate();
	          }
	        };
	
	        this._propsAnimated = new AnimatedProps(nextProps, callback);
	
	        // When you call detach, it removes the element from the parent list
	        // of children. If it goes to 0, then the parent also detaches itself
	        // and so on.
	        // An optimization is to attach the new elements and THEN detach the old
	        // ones instead of detaching and THEN attaching.
	        // This way the intermediate state isn't to go to 0 and trigger
	        // this expensive recursive detaching to then re-attach everything on
	        // the very next operation.
	        oldPropsAnimated && oldPropsAnimated.__detach();
	      }
	    }, {
	      key: 'componentWillReceiveProps',
	      value: function componentWillReceiveProps(nextProps) {
	        this.attachProps(nextProps);
	      }
	    }, {
	      key: 'render',
	      value: function render() {
	        return _react2['default'].createElement(Component, _extends({}, this._propsAnimated.__getValue(), {
	          ref: refName
	        }));
	      }
	    }]);
	
	    return AnimatedComponent;
	  })(_react2['default'].Component);
	
	  AnimatedComponent.displayName = 'AnimatedComponent';
	
	  AnimatedComponent.propTypes = {
	    style: function style(props, propName, componentName) {
	      // for (var key in ViewStylePropTypes) {
	      //   if (!Component.propTypes[key] && props[key] !== undefined) {
	      //     console.error(
	      //       'You are setting the style `{ ' + key + ': ... }` as a prop. You ' +
	      //       'should nest it in a style object. ' +
	      //       'E.g. `{ style: { ' + key + ': ... } }`'
	      //     );
	      //   }
	      // }
	    }
	  };
	
	  return AnimatedComponent;
	}
	
	var AnimatedTracking = (function (_Animated3) {
	  _inherits(AnimatedTracking, _Animated3);
	
	  function AnimatedTracking(value, parent, animationClass, animationConfig, callback) {
	    _classCallCheck(this, AnimatedTracking);
	
	    _get(Object.getPrototypeOf(AnimatedTracking.prototype), 'constructor', this).call(this);
	    this._value = value;
	    this._parent = parent;
	    this._animationClass = animationClass;
	    this._animationConfig = animationConfig;
	    this._callback = callback;
	    this.__attach();
	  }
	
	  _createClass(AnimatedTracking, [{
	    key: '__getValue',
	    value: function __getValue() {
	      return this._parent.__getValue();
	    }
	  }, {
	    key: '__attach',
	    value: function __attach() {
	      this._parent.__addChild(this);
	    }
	  }, {
	    key: '__detach',
	    value: function __detach() {
	      this._parent.__removeChild(this);
	    }
	  }, {
	    key: 'update',
	    value: function update() {
	      this._value.animate(new this._animationClass(_extends({}, this._animationConfig, {
	        toValue: this._animationConfig.toValue.__getValue()
	      })), this._callback);
	    }
	  }]);
	
	  return AnimatedTracking;
	})(Animated);
	
	var maybeVectorAnim = function maybeVectorAnim(value, config, anim) {
	  if (value instanceof AnimatedValueXY) {
	    var configX = _extends({}, config);
	    var configY = _extends({}, config);
	    for (var key in config) {
	      var _config$key = config[key];
	      var x = _config$key.x;
	      var y = _config$key.y;
	
	      if (x !== undefined && y !== undefined) {
	        configX[key] = x;
	        configY[key] = y;
	      }
	    }
	    var aX = anim(value.x, configX);
	    var aY = anim(value.y, configY);
	    // We use `stopTogether: false` here because otherwise tracking will break
	    // because the second animation will get stopped before it can update.
	    return parallel([aX, aY], { stopTogether: false });
	  }
	  return null;
	};
	
	var spring = function spring(value, config) {
	  return maybeVectorAnim(value, config, spring) || {
	    start: function start(callback) {
	      var singleValue = value;
	      var singleConfig = config;
	      singleValue.stopTracking();
	      if (config.toValue instanceof Animated) {
	        singleValue.track(new AnimatedTracking(singleValue, config.toValue, SpringAnimation, singleConfig, callback));
	      } else {
	        singleValue.animate(new SpringAnimation(singleConfig), callback);
	      }
	    },
	
	    stop: function stop() {
	      value.stopAnimation();
	    }
	  };
	};
	
	var timing = function timing(value, config) {
	  return maybeVectorAnim(value, config, timing) || {
	    start: function start(callback) {
	      var singleValue = value;
	      var singleConfig = config;
	      singleValue.stopTracking();
	      if (config.toValue instanceof Animated) {
	        singleValue.track(new AnimatedTracking(singleValue, config.toValue, TimingAnimation, singleConfig, callback));
	      } else {
	        singleValue.animate(new TimingAnimation(singleConfig), callback);
	      }
	    },
	
	    stop: function stop() {
	      value.stopAnimation();
	    }
	  };
	};
	
	var decay = function decay(value, config) {
	  return maybeVectorAnim(value, config, decay) || {
	    start: function start(callback) {
	      var singleValue = value;
	      var singleConfig = config;
	      singleValue.stopTracking();
	      singleValue.animate(new DecayAnimation(singleConfig), callback);
	    },
	
	    stop: function stop() {
	      value.stopAnimation();
	    }
	  };
	};
	
	var sequence = function sequence(animations) {
	  var current = 0;
	  return {
	    start: function start(callback) {
	      var onComplete = function onComplete(result) {
	        if (!result.finished) {
	          callback && callback(result);
	          return;
	        }
	
	        current++;
	
	        if (current === animations.length) {
	          callback && callback(result);
	          return;
	        }
	
	        animations[current].start(onComplete);
	      };
	
	      if (animations.length === 0) {
	        callback && callback({ finished: true });
	      } else {
	        animations[current].start(onComplete);
	      }
	    },
	
	    stop: function stop() {
	      if (current < animations.length) {
	        animations[current].stop();
	      }
	    }
	  };
	};
	
	// If one is stopped, stop all.  default: true
	
	var parallel = function parallel(animations, config) {
	  var doneCount = 0;
	  // Make sure we only call stop() at most once for each animation
	  var hasEnded = {};
	  var stopTogether = !(config && config.stopTogether === false);
	
	  var result = {
	    start: function start(callback) {
	      if (doneCount === animations.length) {
	        callback && callback({ finished: true });
	        return;
	      }
	
	      animations.forEach(function (animation, idx) {
	        var cb = function cb(endResult) {
	          hasEnded[idx] = true;
	          doneCount++;
	          if (doneCount === animations.length) {
	            doneCount = 0;
	            callback && callback(endResult);
	            return;
	          }
	
	          if (!endResult.finished && stopTogether) {
	            result.stop();
	          }
	        };
	
	        if (!animation) {
	          cb({ finished: true });
	        } else {
	          animation.start(cb);
	        }
	      });
	    },
	
	    stop: function stop() {
	      animations.forEach(function (animation, idx) {
	        !hasEnded[idx] && animation.stop();
	        hasEnded[idx] = true;
	      });
	    }
	  };
	
	  return result;
	};
	
	var delay = function delay(time) {
	  // Would be nice to make a specialized implementation
	  return timing(new AnimatedValue(0), { toValue: 0, delay: time, duration: 0 });
	};
	
	var stagger = function stagger(time, animations) {
	  return parallel(animations.map(function (animation, i) {
	    return sequence([delay(time * i), animation]);
	  }));
	};
	
	var event = function event(argMapping, config) {
	  return function () {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var traverse = function traverse(recMapping, recEvt, key) {
	      if (typeof recEvt === 'number') {
	        (0, _fbjsLibInvariant2['default'])(recMapping instanceof AnimatedValue, 'Bad mapping of type ' + typeof recMapping + ' for key ' + key + ', event value must map to AnimatedValue');
	        recMapping.setValue(recEvt);
	        return;
	      }
	      (0, _fbjsLibInvariant2['default'])(typeof recMapping === 'object', 'Bad mapping of type ' + typeof recMapping + ' for key ' + key);
	      (0, _fbjsLibInvariant2['default'])(typeof recEvt === 'object', 'Bad event of type ' + typeof recEvt + ' for key ' + key);
	      for (var key in recMapping) {
	        traverse(recMapping[key], recEvt[key], key);
	      }
	    };
	    argMapping.forEach(function (mapping, idx) {
	      traverse(mapping, args[idx], 'arg' + idx);
	    });
	    if (config && config.listener) {
	      config.listener.apply(null, args);
	    }
	  };
	};
	
	/**
	 * Animations are an important part of modern UX, and the `Animated`
	 * library is designed to make them fluid, powerful, and easy to build and
	 * maintain.
	 *
	 * The simplest workflow is to create an `Animated.Value`, hook it up to one or
	 * more style attributes of an animated component, and then drive updates either
	 * via animations, such as `Animated.timing`, or by hooking into gestures like
	 * panning or scolling via `Animated.event`.  `Animated.Value` can also bind to
	 * props other than style, and can be interpolated as well.  Here is a basic
	 * example of a container view that will fade in when it's mounted:
	 *
	 *```javascript
	 *  class FadeInView extends React.Component {
	 *    constructor(props) {
	 *      super(props);
	 *      this.state = {
	 *        fadeAnim: new Animated.Value(0), // init opacity 0
	 *      };
	 *    }
	 *    componentDidMount() {
	 *      Animated.timing(          // Uses easing functions
	 *        this.state.fadeAnim,    // The value to drive
	 *        {toValue: 1},           // Configuration
	 *      ).start();                // Don't forget start!
	 *    }
	 *    render() {
	 *      return (
	 *        <Animated.View          // Special animatable View
	 *          style={{opacity: this.state.fadeAnim}}> // Binds
	 *          {this.props.children}
	 *        </Animated.View>
	 *      );
	 *    }
	 *  }
	 *```
	 *
	 * Note that only animatable components can be animated.  `View`, `Text`, and
	 * `Image` are already provided, and you can create custom ones with
	 * `createAnimatedComponent`.  These special components do the magic of binding
	 * the animated values to the properties, and do targetted native updates to
	 * avoid the cost of the react render and reconciliation process on every frame.
	 * They also handle cleanup on unmount so they are safe by default.
	 *
	 * Animations are heavily configurable.  Custom and pre-defined easing
	 * functions, delays, durations, decay factors, spring constants, and more can
	 * all be tweaked depending on the type of animation.
	 *
	 * A single `Animated.Value` can drive any number of properties, and each
	 * property can be run through an interpolation first.  An interpolation maps
	 * input ranges to output ranges, typically using a linear interpolation but
	 * also supports easing functions.  By default, it will extrapolate the curve
	 * beyond the ranges given, but you can also have it clamp the output value.
	 *
	 * For example, you may want to think about your `Animated.Value` as going from
	 * 0 to 1, but animate the position from 150px to 0px and the opacity from 0 to
	 * 1. This can easily be done by modifying `style` in the example above like so:
	 *
	 *```javascript
	 *  style={{
	 *    opacity: this.state.fadeAnim, // Binds directly
	 *    transform: [{
	 *      translateY: this.state.fadeAnim.interpolate({
	 *        inputRange: [0, 1],
	 *        outputRange: [150, 0]  // 0 : 150, 0.5 : 75, 1 : 0
	 *      }),
	 *    }],
	 *  }}>
	 *```
	 *
	 * Animations can also be combined in complex ways using composition functions
	 * such as `sequence` and `parallel`, and can also be chained together simply
	 * by setting the `toValue` of one animation to be another `Animated.Value`.
	 *
	 * `Animated.ValueXY` is handy for 2D animations, like panning, and there are
	 * other helpful additions like `setOffset` and `getLayout` to aid with typical
	 * interaction patterns, like drag-and-drop.
	 *
	 * You can see more example usage in `AnimationExample.js`, the Gratuitous
	 * Animation App, and [Animations documentation guide](http://facebook.github.io/react-native/docs/animations.html).
	 *
	 * Note that `Animated` is designed to be fully serializable so that animations
	 * can be run in a high performace way, independent of the normal JavaScript
	 * event loop. This does influence the API, so keep that in mind when it seems a
	 * little trickier to do something compared to a fully synchronous system.
	 * Checkout `Animated.Value.addListener` as a way to work around some of these
	 * limitations, but use it sparingly since it might have performance
	 * implications in the future.
	 */
	module.exports = {
	  /**
	   * Standard value class for driving animations.  Typically initialized with
	   * `new Animated.Value(0);`
	   */
	  Value: AnimatedValue,
	  /**
	   * 2D value class for driving 2D animations, such as pan gestures.
	   */
	  ValueXY: AnimatedValueXY,
	
	  /**
	   * Animates a value from an initial velocity to zero based on a decay
	   * coefficient.
	   */
	  decay: decay,
	  /**
	   * Animates a value along a timed easing curve.  The `Easing` module has tons
	   * of pre-defined curves, or you can use your own function.
	   */
	  timing: timing,
	  /**
	   * Spring animation based on Rebound and Origami.  Tracks velocity state to
	   * create fluid motions as the `toValue` updates, and can be chained together.
	   */
	  spring: spring,
	
	  /**
	   * Starts an animation after the given delay.
	   */
	  delay: delay,
	  /**
	   * Starts an array of animations in order, waiting for each to complete
	   * before starting the next.  If the current running animation is stopped, no
	   * following animations will be started.
	   */
	  sequence: sequence,
	  /**
	   * Starts an array of animations all at the same time.  By default, if one
	   * of the animations is stopped, they will all be stopped.  You can override
	   * this with the `stopTogether` flag.
	   */
	  parallel: parallel,
	  /**
	   * Array of animations may run in parallel (overlap), but are started in
	   * sequence with successive delays.  Nice for doing trailing effects.
	   */
	  stagger: stagger,
	
	  /**
	   *  Takes an array of mappings and extracts values from each arg accordingly,
	   *  then calls `setValue` on the mapped outputs.  e.g.
	   *
	   *```javascript
	   *  onScroll={this.AnimatedEvent(
	   *    [{nativeEvent: {contentOffset: {x: this._scrollX}}}]
	   *    {listener},          // Optional async listener
	   *  )
	   *  ...
	   *  onPanResponderMove: this.AnimatedEvent([
	   *    null,                // raw event arg ignored
	   *    {dx: this._panX},    // gestureState arg
	   *  ]),
	   *```
	   */
	  event: event,
	
	  /**
	   * Make any React component Animatable.  Used to create `Animated.View`, etc.
	   */
	  createAnimatedComponent: createAnimatedComponent,
	
	  __PropsOnlyForTests: AnimatedProps
	};

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * @providesModule ReactEasing
	 */
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _vendorEasing = __webpack_require__(176);
	
	var _vendorEasing2 = _interopRequireDefault(_vendorEasing);

	exports['default'] = _vendorEasing2['default'];
	module.exports = exports['default'];

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	'use strict';
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _bezier = __webpack_require__(177);
	
	/**
	 * This class implements common easing functions. The math is pretty obscure,
	 * but this cool website has nice visual illustrations of what they represent:
	 * http://xaedes.de/dev/transitions/
	 */
	
	var Easing = (function () {
	  function Easing() {
	    _classCallCheck(this, Easing);
	  }
	
	  _createClass(Easing, null, [{
	    key: 'step0',
	    value: function step0(n) {
	      return n > 0 ? 1 : 0;
	    }
	  }, {
	    key: 'step1',
	    value: function step1(n) {
	      return n >= 1 ? 1 : 0;
	    }
	  }, {
	    key: 'linear',
	    value: function linear(t) {
	      return t;
	    }
	  }, {
	    key: 'ease',
	    value: function ease(t) {
	      return _ease(t);
	    }
	  }, {
	    key: 'quad',
	    value: function quad(t) {
	      return t * t;
	    }
	  }, {
	    key: 'cubic',
	    value: function cubic(t) {
	      return t * t * t;
	    }
	  }, {
	    key: 'poly',
	    value: function poly(n) {
	      return function (t) {
	        return Math.pow(t, n);
	      };
	    }
	  }, {
	    key: 'sin',
	    value: function sin(t) {
	      return 1 - Math.cos(t * Math.PI / 2);
	    }
	  }, {
	    key: 'circle',
	    value: function circle(t) {
	      return 1 - Math.sqrt(1 - t * t);
	    }
	  }, {
	    key: 'exp',
	    value: function exp(t) {
	      return Math.pow(2, 10 * (t - 1));
	    }
	  }, {
	    key: 'elastic',
	    value: function elastic(a, p) {
	      var tau = Math.PI * 2;
	      // flow isn't smart enough to figure out that s is always assigned to a
	      // number before being used in the returned function
	      var s;
	      if (arguments.length < 2) {
	        p = 0.45;
	      }
	      if (arguments.length) {
	        s = p / tau * Math.asin(1 / a);
	      } else {
	        a = 1;
	        s = p / 4;
	      }
	      return function (t) {
	        return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * tau / p);
	      };
	    }
	  }, {
	    key: 'back',
	    value: function back(s) {
	      if (s === undefined) {
	        s = 1.70158;
	      }
	      return function (t) {
	        return t * t * ((s + 1) * t - s);
	      };
	    }
	  }, {
	    key: 'bounce',
	    value: function bounce(t) {
	      if (t < 1 / 2.75) {
	        return 7.5625 * t * t;
	      }
	
	      if (t < 2 / 2.75) {
	        t -= 1.5 / 2.75;
	        return 7.5625 * t * t + 0.75;
	      }
	
	      if (t < 2.5 / 2.75) {
	        t -= 2.25 / 2.75;
	        return 7.5625 * t * t + 0.9375;
	      }
	
	      t -= 2.625 / 2.75;
	      return 7.5625 * t * t + 0.984375;
	    }
	  }, {
	    key: 'bezier',
	    value: function bezier(x1, y1, x2, y2, epsilon) {
	      if (epsilon === undefined) {
	        // epsilon determines the precision of the solved values
	        // a good approximation is:
	        var duration = 500; // duration of animation in milliseconds.
	        epsilon = 1000 / 60 / duration / 4;
	      }
	
	      return _bezier(x1, y1, x2, y2, epsilon);
	    }
	  }, {
	    key: 'in',
	    value: function _in(easing) {
	      return easing;
	    }
	  }, {
	    key: 'out',
	    value: function out(easing) {
	      return function (t) {
	        return 1 - easing(1 - t);
	      };
	    }
	  }, {
	    key: 'inOut',
	    value: function inOut(easing) {
	      return function (t) {
	        if (t < 0.5) {
	          return easing(t * 2) / 2;
	        }
	        return 1 - easing((1 - t) * 2) / 2;
	      };
	    }
	  }]);
	
	  return Easing;
	})();
	
	var _ease = Easing.bezier(0.42, 0, 1, 1);
	
	module.exports = Easing;

/***/ },
/* 177 */
/***/ function(module, exports) {

	/**
	 * https://github.com/arian/cubic-bezier
	 *
	 * MIT License
	 *
	 * Copyright (c) 2013 Arian Stolwijk
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * "Software"), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 *
	 * @nolint
	 */
	'use strict';
	
	module.exports = function (x1, y1, x2, y2, epsilon) {
	
	  var curveX = function curveX(t) {
	    var v = 1 - t;
	    return 3 * v * v * t * x1 + 3 * v * t * t * x2 + t * t * t;
	  };
	
	  var curveY = function curveY(t) {
	    var v = 1 - t;
	    return 3 * v * v * t * y1 + 3 * v * t * t * y2 + t * t * t;
	  };
	
	  var derivativeCurveX = function derivativeCurveX(t) {
	    var v = 1 - t;
	    return 3 * (2 * (t - 1) * t + v * v) * x1 + 3 * (-t * t * t + 2 * v * t) * x2;
	  };
	
	  return function (t) {
	
	    var x = t,
	        t0,
	        t1,
	        t2,
	        x2,
	        d2,
	        i;
	
	    // First try a few iterations of Newton's method -- normally very fast.
	    for (t2 = x, i = 0; i < 8; i++) {
	      x2 = curveX(t2) - x;
	      if (Math.abs(x2) < epsilon) return curveY(t2);
	      d2 = derivativeCurveX(t2);
	      if (Math.abs(d2) < 1e-6) break;
	      t2 = t2 - x2 / d2;
	    }
	
	    t0 = 0, t1 = 1, t2 = x;
	
	    if (t2 < t0) return curveY(t0);
	    if (t2 > t1) return curveY(t1);
	
	    // Fallback to the bisection method for reliability.
	    while (t0 < t1) {
	      x2 = curveX(t2);
	      if (Math.abs(x2 - x) < epsilon) return curveY(t2);
	      if (x > x2) t0 = t2;else t1 = t2;
	      t2 = (t1 - t0) * .5 + t0;
	    }
	
	    // Failure
	    return curveY(t2);
	  };
	};

/***/ },
/* 178 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * @providesModule ReactInteractionManager
	 */
	'use strict';
	
	module.exports = {
	  createInteractionHandle: function createInteractionHandle() {},
	  clearInteractionHandle: function clearInteractionHandle() {},
	  runAfterInteractions: function runAfterInteractions(cb) {
	    cb();
	  }
	};

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * 
	 */
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _tinycolor2 = __webpack_require__(180);
	
	var _tinycolor22 = _interopRequireDefault(_tinycolor2);
	
	// TODO(#7644673): fix this hack once github jest actually checks invariants
	var invariant = function invariant(condition, message) {
	  if (!condition) {
	    var error = new Error(message);
	    error.framesToPop = 1; // $FlowIssue
	    throw error;
	  }
	};
	
	var linear = function linear(t) {
	  return t;
	};
	
	/**
	 * Very handy helper to map input ranges to output ranges with an easing
	 * function and custom behavior outside of the ranges.
	 */
	
	var Interpolation = (function () {
	  function Interpolation() {
	    _classCallCheck(this, Interpolation);
	  }
	
	  _createClass(Interpolation, null, [{
	    key: 'create',
	    value: function create(config) {
	
	      if (config.outputRange && typeof config.outputRange[0] === 'string') {
	        return createInterpolationFromStringOutputRange(config);
	      }
	
	      var outputRange = config.outputRange;
	      checkInfiniteRange('outputRange', outputRange);
	
	      var inputRange = config.inputRange;
	      checkInfiniteRange('inputRange', inputRange);
	      checkValidInputRange(inputRange);
	
	      invariant(inputRange.length === outputRange.length, 'inputRange (' + inputRange.length + ') and outputRange (' + outputRange.length + ') must have the same length');
	
	      var easing = config.easing || linear;
	
	      var extrapolateLeft = 'extend';
	      if (config.extrapolateLeft !== undefined) {
	        extrapolateLeft = config.extrapolateLeft;
	      } else if (config.extrapolate !== undefined) {
	        extrapolateLeft = config.extrapolate;
	      }
	
	      var extrapolateRight = 'extend';
	      if (config.extrapolateRight !== undefined) {
	        extrapolateRight = config.extrapolateRight;
	      } else if (config.extrapolate !== undefined) {
	        extrapolateRight = config.extrapolate;
	      }
	
	      return function (input) {
	        invariant(typeof input === 'number', 'Cannot interpolation an input which is not a number');
	
	        var range = findRange(input, inputRange);
	        return interpolate(input, inputRange[range], inputRange[range + 1], outputRange[range], outputRange[range + 1], easing, extrapolateLeft, extrapolateRight);
	      };
	    }
	  }]);
	
	  return Interpolation;
	})();
	
	function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight) {
	  var result = input;
	
	  // Extrapolate
	  if (result < inputMin) {
	    if (extrapolateLeft === 'identity') {
	      return result;
	    } else if (extrapolateLeft === 'clamp') {
	      result = inputMin;
	    } else if (extrapolateLeft === 'extend') {
	      // noop
	    }
	  }
	
	  if (result > inputMax) {
	    if (extrapolateRight === 'identity') {
	      return result;
	    } else if (extrapolateRight === 'clamp') {
	      result = inputMax;
	    } else if (extrapolateRight === 'extend') {
	      // noop
	    }
	  }
	
	  if (outputMin === outputMax) {
	    return outputMin;
	  }
	
	  if (inputMin === inputMax) {
	    if (input <= inputMin) {
	      return outputMin;
	    }
	    return outputMax;
	  }
	
	  // Input Range
	  if (inputMin === -Infinity) {
	    result = -result;
	  } else if (inputMax === Infinity) {
	    result = result - inputMin;
	  } else {
	    result = (result - inputMin) / (inputMax - inputMin);
	  }
	
	  // Easing
	  result = easing(result);
	
	  // Output Range
	  if (outputMin === -Infinity) {
	    result = -result;
	  } else if (outputMax === Infinity) {
	    result = result + outputMin;
	  } else {
	    result = result * (outputMax - outputMin) + outputMin;
	  }
	
	  return result;
	}
	
	function colorToRgba(input) {
	  var color = (0, _tinycolor22['default'])(input);
	  if (color.isValid()) {
	    var _color$toRgb = color.toRgb();
	
	    var r = _color$toRgb.r;
	    var g = _color$toRgb.g;
	    var b = _color$toRgb.b;
	    var a = _color$toRgb.a;
	
	    return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + (a === undefined ? 1 : a) + ')';
	  } else {
	    return input;
	  }
	}
	
	var stringShapeRegex = /[0-9\.-]+/g;
	
	/**
	 * Supports string shapes by extracting numbers so new values can be computed,
	 * and recombines those values into new strings of the same shape.  Supports
	 * things like:
	 *
	 *   rgba(123, 42, 99, 0.36) // colors
	 *   -45deg                  // values with units
	 */
	function createInterpolationFromStringOutputRange(config) {
	  var outputRange = config.outputRange;
	  invariant(outputRange.length >= 2, 'Bad output range');
	  outputRange = outputRange.map(colorToRgba);
	  checkPattern(outputRange);
	
	  // ['rgba(0, 100, 200, 0)', 'rgba(50, 150, 250, 0.5)']
	  // ->
	  // [
	  //   [0, 50],
	  //   [100, 150],
	  //   [200, 250],
	  //   [0, 0.5],
	  // ]
	  var outputRanges = outputRange[0].match(stringShapeRegex).map(function () {
	    return [];
	  });
	  outputRange.forEach(function (value) {
	    value.match(stringShapeRegex).forEach(function (number, i) {
	      outputRanges[i].push(+number);
	    });
	  });
	
	  var interpolations = outputRange[0].match(stringShapeRegex).map(function (value, i) {
	    return Interpolation.create(_extends({}, config, {
	      outputRange: outputRanges[i]
	    }));
	  });
	
	  return function (input) {
	    var i = 0;
	    // 'rgba(0, 100, 200, 0)'
	    // ->
	    // 'rgba(${interpolations[0](input)}, ${interpolations[1](input)}, ...'
	    return outputRange[0].replace(stringShapeRegex, function () {
	      return String(interpolations[i++](input));
	    });
	  };
	}
	
	function checkPattern(arr) {
	  var pattern = arr[0].replace(stringShapeRegex, '');
	  for (var i = 1; i < arr.length; ++i) {
	    invariant(pattern === arr[i].replace(stringShapeRegex, ''), 'invalid pattern ' + arr[0] + ' and ' + arr[i]);
	  }
	}
	
	function findRange(input, inputRange) {
	  for (var i = 1; i < inputRange.length - 1; ++i) {
	    if (inputRange[i] >= input) {
	      break;
	    }
	  }
	  return i - 1;
	}
	
	function checkValidInputRange(arr) {
	  invariant(arr.length >= 2, 'inputRange must have at least 2 elements');
	  for (var i = 1; i < arr.length; ++i) {
	    invariant(arr[i] >= arr[i - 1],
	    /* $FlowFixMe(>=0.13.0) - In the addition expression below this comment,
	     * one or both of the operands may be something that doesn't cleanly
	     * convert to a string, like undefined, null, and object, etc. If you really
	     * mean this implicit string conversion, you can do something like
	     * String(myThing)
	     */
	    'inputRange must be monotonically increasing ' + arr);
	  }
	}
	
	function checkInfiniteRange(name, arr) {
	  invariant(arr.length >= 2, name + ' must have at least 2 elements');
	  invariant(arr.length !== 2 || arr[0] !== -Infinity || arr[1] !== Infinity,
	  /* $FlowFixMe(>=0.13.0) - In the addition expression below this comment,
	   * one or both of the operands may be something that doesn't cleanly convert
	   * to a string, like undefined, null, and object, etc. If you really mean
	   * this implicit string conversion, you can do something like
	   * String(myThing)
	   */
	  name + 'cannot be ]-infinity;+infinity[ ' + arr);
	}
	
	module.exports = Interpolation;

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;// TinyColor v1.1.2
	// https://github.com/bgrins/TinyColor
	// Brian Grinstead, MIT License
	
	(function() {
	
	var trimLeft = /^[\s,#]+/,
	    trimRight = /\s+$/,
	    tinyCounter = 0,
	    math = Math,
	    mathRound = math.round,
	    mathMin = math.min,
	    mathMax = math.max,
	    mathRandom = math.random;
	
	function tinycolor (color, opts) {
	
	    color = (color) ? color : '';
	    opts = opts || { };
	
	    // If input is already a tinycolor, return itself
	    if (color instanceof tinycolor) {
	       return color;
	    }
	    // If we are called as a function, call using new instead
	    if (!(this instanceof tinycolor)) {
	        return new tinycolor(color, opts);
	    }
	
	    var rgb = inputToRGB(color);
	    this._originalInput = color,
	    this._r = rgb.r,
	    this._g = rgb.g,
	    this._b = rgb.b,
	    this._a = rgb.a,
	    this._roundA = mathRound(100*this._a) / 100,
	    this._format = opts.format || rgb.format;
	    this._gradientType = opts.gradientType;
	
	    // Don't let the range of [0,255] come back in [0,1].
	    // Potentially lose a little bit of precision here, but will fix issues where
	    // .5 gets interpreted as half of the total, instead of half of 1
	    // If it was supposed to be 128, this was already taken care of by `inputToRgb`
	    if (this._r < 1) { this._r = mathRound(this._r); }
	    if (this._g < 1) { this._g = mathRound(this._g); }
	    if (this._b < 1) { this._b = mathRound(this._b); }
	
	    this._ok = rgb.ok;
	    this._tc_id = tinyCounter++;
	}
	
	tinycolor.prototype = {
	    isDark: function() {
	        return this.getBrightness() < 128;
	    },
	    isLight: function() {
	        return !this.isDark();
	    },
	    isValid: function() {
	        return this._ok;
	    },
	    getOriginalInput: function() {
	      return this._originalInput;
	    },
	    getFormat: function() {
	        return this._format;
	    },
	    getAlpha: function() {
	        return this._a;
	    },
	    getBrightness: function() {
	        //http://www.w3.org/TR/AERT#color-contrast
	        var rgb = this.toRgb();
	        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
	    },
	    getLuminance: function() {
	        //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
	        var rgb = this.toRgb();
	        var RsRGB, GsRGB, BsRGB, R, G, B;
	        RsRGB = rgb.r/255;
	        GsRGB = rgb.g/255;
	        BsRGB = rgb.b/255;
	
	        if (RsRGB <= 0.03928) {R = RsRGB / 12.92;} else {R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4);}
	        if (GsRGB <= 0.03928) {G = GsRGB / 12.92;} else {G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4);}
	        if (BsRGB <= 0.03928) {B = BsRGB / 12.92;} else {B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4);}
	        return (0.2126 * R) + (0.7152 * G) + (0.0722 * B);
	    },
	    setAlpha: function(value) {
	        this._a = boundAlpha(value);
	        this._roundA = mathRound(100*this._a) / 100;
	        return this;
	    },
	    toHsv: function() {
	        var hsv = rgbToHsv(this._r, this._g, this._b);
	        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
	    },
	    toHsvString: function() {
	        var hsv = rgbToHsv(this._r, this._g, this._b);
	        var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
	        return (this._a == 1) ?
	          "hsv("  + h + ", " + s + "%, " + v + "%)" :
	          "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
	    },
	    toHsl: function() {
	        var hsl = rgbToHsl(this._r, this._g, this._b);
	        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
	    },
	    toHslString: function() {
	        var hsl = rgbToHsl(this._r, this._g, this._b);
	        var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
	        return (this._a == 1) ?
	          "hsl("  + h + ", " + s + "%, " + l + "%)" :
	          "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
	    },
	    toHex: function(allow3Char) {
	        return rgbToHex(this._r, this._g, this._b, allow3Char);
	    },
	    toHexString: function(allow3Char) {
	        return '#' + this.toHex(allow3Char);
	    },
	    toHex8: function() {
	        return rgbaToHex(this._r, this._g, this._b, this._a);
	    },
	    toHex8String: function() {
	        return '#' + this.toHex8();
	    },
	    toRgb: function() {
	        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
	    },
	    toRgbString: function() {
	        return (this._a == 1) ?
	          "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
	          "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
	    },
	    toPercentageRgb: function() {
	        return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
	    },
	    toPercentageRgbString: function() {
	        return (this._a == 1) ?
	          "rgb("  + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
	          "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
	    },
	    toName: function() {
	        if (this._a === 0) {
	            return "transparent";
	        }
	
	        if (this._a < 1) {
	            return false;
	        }
	
	        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
	    },
	    toFilter: function(secondColor) {
	        var hex8String = '#' + rgbaToHex(this._r, this._g, this._b, this._a);
	        var secondHex8String = hex8String;
	        var gradientType = this._gradientType ? "GradientType = 1, " : "";
	
	        if (secondColor) {
	            var s = tinycolor(secondColor);
	            secondHex8String = s.toHex8String();
	        }
	
	        return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
	    },
	    toString: function(format) {
	        var formatSet = !!format;
	        format = format || this._format;
	
	        var formattedString = false;
	        var hasAlpha = this._a < 1 && this._a >= 0;
	        var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "name");
	
	        if (needsAlphaFormat) {
	            // Special case for "transparent", all other non-alpha formats
	            // will return rgba when there is transparency.
	            if (format === "name" && this._a === 0) {
	                return this.toName();
	            }
	            return this.toRgbString();
	        }
	        if (format === "rgb") {
	            formattedString = this.toRgbString();
	        }
	        if (format === "prgb") {
	            formattedString = this.toPercentageRgbString();
	        }
	        if (format === "hex" || format === "hex6") {
	            formattedString = this.toHexString();
	        }
	        if (format === "hex3") {
	            formattedString = this.toHexString(true);
	        }
	        if (format === "hex8") {
	            formattedString = this.toHex8String();
	        }
	        if (format === "name") {
	            formattedString = this.toName();
	        }
	        if (format === "hsl") {
	            formattedString = this.toHslString();
	        }
	        if (format === "hsv") {
	            formattedString = this.toHsvString();
	        }
	
	        return formattedString || this.toHexString();
	    },
	
	    _applyModification: function(fn, args) {
	        var color = fn.apply(null, [this].concat([].slice.call(args)));
	        this._r = color._r;
	        this._g = color._g;
	        this._b = color._b;
	        this.setAlpha(color._a);
	        return this;
	    },
	    lighten: function() {
	        return this._applyModification(lighten, arguments);
	    },
	    brighten: function() {
	        return this._applyModification(brighten, arguments);
	    },
	    darken: function() {
	        return this._applyModification(darken, arguments);
	    },
	    desaturate: function() {
	        return this._applyModification(desaturate, arguments);
	    },
	    saturate: function() {
	        return this._applyModification(saturate, arguments);
	    },
	    greyscale: function() {
	        return this._applyModification(greyscale, arguments);
	    },
	    spin: function() {
	        return this._applyModification(spin, arguments);
	    },
	
	    _applyCombination: function(fn, args) {
	        return fn.apply(null, [this].concat([].slice.call(args)));
	    },
	    analogous: function() {
	        return this._applyCombination(analogous, arguments);
	    },
	    complement: function() {
	        return this._applyCombination(complement, arguments);
	    },
	    monochromatic: function() {
	        return this._applyCombination(monochromatic, arguments);
	    },
	    splitcomplement: function() {
	        return this._applyCombination(splitcomplement, arguments);
	    },
	    triad: function() {
	        return this._applyCombination(triad, arguments);
	    },
	    tetrad: function() {
	        return this._applyCombination(tetrad, arguments);
	    }
	};
	
	// If input is an object, force 1 into "1.0" to handle ratios properly
	// String input requires "1.0" as input, so 1 will be treated as 1
	tinycolor.fromRatio = function(color, opts) {
	    if (typeof color == "object") {
	        var newColor = {};
	        for (var i in color) {
	            if (color.hasOwnProperty(i)) {
	                if (i === "a") {
	                    newColor[i] = color[i];
	                }
	                else {
	                    newColor[i] = convertToPercentage(color[i]);
	                }
	            }
	        }
	        color = newColor;
	    }
	
	    return tinycolor(color, opts);
	};
	
	// Given a string or object, convert that input to RGB
	// Possible string inputs:
	//
	//     "red"
	//     "#f00" or "f00"
	//     "#ff0000" or "ff0000"
	//     "#ff000000" or "ff000000"
	//     "rgb 255 0 0" or "rgb (255, 0, 0)"
	//     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
	//     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
	//     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
	//     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
	//     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
	//     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
	//
	function inputToRGB(color) {
	
	    var rgb = { r: 0, g: 0, b: 0 };
	    var a = 1;
	    var ok = false;
	    var format = false;
	
	    if (typeof color == "string") {
	        color = stringInputToObject(color);
	    }
	
	    if (typeof color == "object") {
	        if (color.hasOwnProperty("r") && color.hasOwnProperty("g") && color.hasOwnProperty("b")) {
	            rgb = rgbToRgb(color.r, color.g, color.b);
	            ok = true;
	            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
	        }
	        else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("v")) {
	            color.s = convertToPercentage(color.s);
	            color.v = convertToPercentage(color.v);
	            rgb = hsvToRgb(color.h, color.s, color.v);
	            ok = true;
	            format = "hsv";
	        }
	        else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("l")) {
	            color.s = convertToPercentage(color.s);
	            color.l = convertToPercentage(color.l);
	            rgb = hslToRgb(color.h, color.s, color.l);
	            ok = true;
	            format = "hsl";
	        }
	
	        if (color.hasOwnProperty("a")) {
	            a = color.a;
	        }
	    }
	
	    a = boundAlpha(a);
	
	    return {
	        ok: ok,
	        format: color.format || format,
	        r: mathMin(255, mathMax(rgb.r, 0)),
	        g: mathMin(255, mathMax(rgb.g, 0)),
	        b: mathMin(255, mathMax(rgb.b, 0)),
	        a: a
	    };
	}
	
	
	// Conversion Functions
	// --------------------
	
	// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
	// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>
	
	// `rgbToRgb`
	// Handle bounds / percentage checking to conform to CSS color spec
	// <http://www.w3.org/TR/css3-color/>
	// *Assumes:* r, g, b in [0, 255] or [0, 1]
	// *Returns:* { r, g, b } in [0, 255]
	function rgbToRgb(r, g, b){
	    return {
	        r: bound01(r, 255) * 255,
	        g: bound01(g, 255) * 255,
	        b: bound01(b, 255) * 255
	    };
	}
	
	// `rgbToHsl`
	// Converts an RGB color value to HSL.
	// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
	// *Returns:* { h, s, l } in [0,1]
	function rgbToHsl(r, g, b) {
	
	    r = bound01(r, 255);
	    g = bound01(g, 255);
	    b = bound01(b, 255);
	
	    var max = mathMax(r, g, b), min = mathMin(r, g, b);
	    var h, s, l = (max + min) / 2;
	
	    if(max == min) {
	        h = s = 0; // achromatic
	    }
	    else {
	        var d = max - min;
	        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
	        switch(max) {
	            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
	            case g: h = (b - r) / d + 2; break;
	            case b: h = (r - g) / d + 4; break;
	        }
	
	        h /= 6;
	    }
	
	    return { h: h, s: s, l: l };
	}
	
	// `hslToRgb`
	// Converts an HSL color value to RGB.
	// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
	// *Returns:* { r, g, b } in the set [0, 255]
	function hslToRgb(h, s, l) {
	    var r, g, b;
	
	    h = bound01(h, 360);
	    s = bound01(s, 100);
	    l = bound01(l, 100);
	
	    function hue2rgb(p, q, t) {
	        if(t < 0) t += 1;
	        if(t > 1) t -= 1;
	        if(t < 1/6) return p + (q - p) * 6 * t;
	        if(t < 1/2) return q;
	        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
	        return p;
	    }
	
	    if(s === 0) {
	        r = g = b = l; // achromatic
	    }
	    else {
	        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	        var p = 2 * l - q;
	        r = hue2rgb(p, q, h + 1/3);
	        g = hue2rgb(p, q, h);
	        b = hue2rgb(p, q, h - 1/3);
	    }
	
	    return { r: r * 255, g: g * 255, b: b * 255 };
	}
	
	// `rgbToHsv`
	// Converts an RGB color value to HSV
	// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
	// *Returns:* { h, s, v } in [0,1]
	function rgbToHsv(r, g, b) {
	
	    r = bound01(r, 255);
	    g = bound01(g, 255);
	    b = bound01(b, 255);
	
	    var max = mathMax(r, g, b), min = mathMin(r, g, b);
	    var h, s, v = max;
	
	    var d = max - min;
	    s = max === 0 ? 0 : d / max;
	
	    if(max == min) {
	        h = 0; // achromatic
	    }
	    else {
	        switch(max) {
	            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
	            case g: h = (b - r) / d + 2; break;
	            case b: h = (r - g) / d + 4; break;
	        }
	        h /= 6;
	    }
	    return { h: h, s: s, v: v };
	}
	
	// `hsvToRgb`
	// Converts an HSV color value to RGB.
	// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
	// *Returns:* { r, g, b } in the set [0, 255]
	 function hsvToRgb(h, s, v) {
	
	    h = bound01(h, 360) * 6;
	    s = bound01(s, 100);
	    v = bound01(v, 100);
	
	    var i = math.floor(h),
	        f = h - i,
	        p = v * (1 - s),
	        q = v * (1 - f * s),
	        t = v * (1 - (1 - f) * s),
	        mod = i % 6,
	        r = [v, q, p, p, t, v][mod],
	        g = [t, v, v, q, p, p][mod],
	        b = [p, p, t, v, v, q][mod];
	
	    return { r: r * 255, g: g * 255, b: b * 255 };
	}
	
	// `rgbToHex`
	// Converts an RGB color to hex
	// Assumes r, g, and b are contained in the set [0, 255]
	// Returns a 3 or 6 character hex
	function rgbToHex(r, g, b, allow3Char) {
	
	    var hex = [
	        pad2(mathRound(r).toString(16)),
	        pad2(mathRound(g).toString(16)),
	        pad2(mathRound(b).toString(16))
	    ];
	
	    // Return a 3 character hex if possible
	    if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
	        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
	    }
	
	    return hex.join("");
	}
	    // `rgbaToHex`
	    // Converts an RGBA color plus alpha transparency to hex
	    // Assumes r, g, b and a are contained in the set [0, 255]
	    // Returns an 8 character hex
	    function rgbaToHex(r, g, b, a) {
	
	        var hex = [
	            pad2(convertDecimalToHex(a)),
	            pad2(mathRound(r).toString(16)),
	            pad2(mathRound(g).toString(16)),
	            pad2(mathRound(b).toString(16))
	        ];
	
	        return hex.join("");
	    }
	
	// `equals`
	// Can be called with any tinycolor input
	tinycolor.equals = function (color1, color2) {
	    if (!color1 || !color2) { return false; }
	    return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
	};
	tinycolor.random = function() {
	    return tinycolor.fromRatio({
	        r: mathRandom(),
	        g: mathRandom(),
	        b: mathRandom()
	    });
	};
	
	
	// Modification Functions
	// ----------------------
	// Thanks to less.js for some of the basics here
	// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>
	
	function desaturate(color, amount) {
	    amount = (amount === 0) ? 0 : (amount || 10);
	    var hsl = tinycolor(color).toHsl();
	    hsl.s -= amount / 100;
	    hsl.s = clamp01(hsl.s);
	    return tinycolor(hsl);
	}
	
	function saturate(color, amount) {
	    amount = (amount === 0) ? 0 : (amount || 10);
	    var hsl = tinycolor(color).toHsl();
	    hsl.s += amount / 100;
	    hsl.s = clamp01(hsl.s);
	    return tinycolor(hsl);
	}
	
	function greyscale(color) {
	    return tinycolor(color).desaturate(100);
	}
	
	function lighten (color, amount) {
	    amount = (amount === 0) ? 0 : (amount || 10);
	    var hsl = tinycolor(color).toHsl();
	    hsl.l += amount / 100;
	    hsl.l = clamp01(hsl.l);
	    return tinycolor(hsl);
	}
	
	function brighten(color, amount) {
	    amount = (amount === 0) ? 0 : (amount || 10);
	    var rgb = tinycolor(color).toRgb();
	    rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
	    rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
	    rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
	    return tinycolor(rgb);
	}
	
	function darken (color, amount) {
	    amount = (amount === 0) ? 0 : (amount || 10);
	    var hsl = tinycolor(color).toHsl();
	    hsl.l -= amount / 100;
	    hsl.l = clamp01(hsl.l);
	    return tinycolor(hsl);
	}
	
	// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
	// Values outside of this range will be wrapped into this range.
	function spin(color, amount) {
	    var hsl = tinycolor(color).toHsl();
	    var hue = (mathRound(hsl.h) + amount) % 360;
	    hsl.h = hue < 0 ? 360 + hue : hue;
	    return tinycolor(hsl);
	}
	
	// Combination Functions
	// ---------------------
	// Thanks to jQuery xColor for some of the ideas behind these
	// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>
	
	function complement(color) {
	    var hsl = tinycolor(color).toHsl();
	    hsl.h = (hsl.h + 180) % 360;
	    return tinycolor(hsl);
	}
	
	function triad(color) {
	    var hsl = tinycolor(color).toHsl();
	    var h = hsl.h;
	    return [
	        tinycolor(color),
	        tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
	        tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
	    ];
	}
	
	function tetrad(color) {
	    var hsl = tinycolor(color).toHsl();
	    var h = hsl.h;
	    return [
	        tinycolor(color),
	        tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
	        tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
	        tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
	    ];
	}
	
	function splitcomplement(color) {
	    var hsl = tinycolor(color).toHsl();
	    var h = hsl.h;
	    return [
	        tinycolor(color),
	        tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
	        tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
	    ];
	}
	
	function analogous(color, results, slices) {
	    results = results || 6;
	    slices = slices || 30;
	
	    var hsl = tinycolor(color).toHsl();
	    var part = 360 / slices;
	    var ret = [tinycolor(color)];
	
	    for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
	        hsl.h = (hsl.h + part) % 360;
	        ret.push(tinycolor(hsl));
	    }
	    return ret;
	}
	
	function monochromatic(color, results) {
	    results = results || 6;
	    var hsv = tinycolor(color).toHsv();
	    var h = hsv.h, s = hsv.s, v = hsv.v;
	    var ret = [];
	    var modification = 1 / results;
	
	    while (results--) {
	        ret.push(tinycolor({ h: h, s: s, v: v}));
	        v = (v + modification) % 1;
	    }
	
	    return ret;
	}
	
	// Utility Functions
	// ---------------------
	
	tinycolor.mix = function(color1, color2, amount) {
	    amount = (amount === 0) ? 0 : (amount || 50);
	
	    var rgb1 = tinycolor(color1).toRgb();
	    var rgb2 = tinycolor(color2).toRgb();
	
	    var p = amount / 100;
	    var w = p * 2 - 1;
	    var a = rgb2.a - rgb1.a;
	
	    var w1;
	
	    if (w * a == -1) {
	        w1 = w;
	    } else {
	        w1 = (w + a) / (1 + w * a);
	    }
	
	    w1 = (w1 + 1) / 2;
	
	    var w2 = 1 - w1;
	
	    var rgba = {
	        r: rgb2.r * w1 + rgb1.r * w2,
	        g: rgb2.g * w1 + rgb1.g * w2,
	        b: rgb2.b * w1 + rgb1.b * w2,
	        a: rgb2.a * p  + rgb1.a * (1 - p)
	    };
	
	    return tinycolor(rgba);
	};
	
	
	// Readability Functions
	// ---------------------
	// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)
	
	// `contrast`
	// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
	tinycolor.readability = function(color1, color2) {
	    var c1 = tinycolor(color1);
	    var c2 = tinycolor(color2);
	    return (Math.max(c1.getLuminance(),c2.getLuminance())+0.05) / (Math.min(c1.getLuminance(),c2.getLuminance())+0.05);
	};
	
	// `isReadable`
	// Ensure that foreground and background color combinations meet WCAG2 guidelines.
	// The third argument is an optional Object.
	//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
	//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
	// If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.
	
	// *Example*
	//    tinycolor.isReadable("#000", "#111") => false
	//    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
	
	tinycolor.isReadable = function(color1, color2, wcag2) {
	    var readability = tinycolor.readability(color1, color2);
	    var wcag2Parms, out;
	
	    out = false;
	
	    wcag2Parms = validateWCAG2Parms(wcag2);
	    switch (wcag2Parms.level + wcag2Parms.size) {
	        case "AAsmall":
	        case "AAAlarge":
	            out = readability >= 4.5;
	            break;
	        case "AAlarge":
	            out = readability >= 3;
	            break;
	        case "AAAsmall":
	            out = readability >= 7;
	            break;
	    }
	    return out;
	
	};
	
	// `mostReadable`
	// Given a base color and a list of possible foreground or background
	// colors for that base, returns the most readable color.
	// Optionally returns Black or White if the most readable color is unreadable.
	// *Example*
	//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
	//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
	//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
	//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
	
	
	tinycolor.mostReadable = function(baseColor, colorList, args) {
	    var bestColor = null;
	    var bestScore = 0;
	    var readability;
	    var includeFallbackColors, level, size ;
	    args = args || {};
	    includeFallbackColors = args.includeFallbackColors ;
	    level = args.level;
	    size = args.size;
	
	    for (var i= 0; i < colorList.length ; i++) {
	        readability = tinycolor.readability(baseColor, colorList[i]);
	        if (readability > bestScore) {
	            bestScore = readability;
	            bestColor = tinycolor(colorList[i]);
	        }
	    }
	
	    if (tinycolor.isReadable(baseColor, bestColor, {"level":level,"size":size}) || !includeFallbackColors) {
	        return bestColor;
	    }
	    else {
	        args.includeFallbackColors=false;
	        return tinycolor.mostReadable(baseColor,["#fff", "#000"],args);
	    }
	};
	
	
	// Big List of Colors
	// ------------------
	// <http://www.w3.org/TR/css3-color/#svg-color>
	var names = tinycolor.names = {
	    aliceblue: "f0f8ff",
	    antiquewhite: "faebd7",
	    aqua: "0ff",
	    aquamarine: "7fffd4",
	    azure: "f0ffff",
	    beige: "f5f5dc",
	    bisque: "ffe4c4",
	    black: "000",
	    blanchedalmond: "ffebcd",
	    blue: "00f",
	    blueviolet: "8a2be2",
	    brown: "a52a2a",
	    burlywood: "deb887",
	    burntsienna: "ea7e5d",
	    cadetblue: "5f9ea0",
	    chartreuse: "7fff00",
	    chocolate: "d2691e",
	    coral: "ff7f50",
	    cornflowerblue: "6495ed",
	    cornsilk: "fff8dc",
	    crimson: "dc143c",
	    cyan: "0ff",
	    darkblue: "00008b",
	    darkcyan: "008b8b",
	    darkgoldenrod: "b8860b",
	    darkgray: "a9a9a9",
	    darkgreen: "006400",
	    darkgrey: "a9a9a9",
	    darkkhaki: "bdb76b",
	    darkmagenta: "8b008b",
	    darkolivegreen: "556b2f",
	    darkorange: "ff8c00",
	    darkorchid: "9932cc",
	    darkred: "8b0000",
	    darksalmon: "e9967a",
	    darkseagreen: "8fbc8f",
	    darkslateblue: "483d8b",
	    darkslategray: "2f4f4f",
	    darkslategrey: "2f4f4f",
	    darkturquoise: "00ced1",
	    darkviolet: "9400d3",
	    deeppink: "ff1493",
	    deepskyblue: "00bfff",
	    dimgray: "696969",
	    dimgrey: "696969",
	    dodgerblue: "1e90ff",
	    firebrick: "b22222",
	    floralwhite: "fffaf0",
	    forestgreen: "228b22",
	    fuchsia: "f0f",
	    gainsboro: "dcdcdc",
	    ghostwhite: "f8f8ff",
	    gold: "ffd700",
	    goldenrod: "daa520",
	    gray: "808080",
	    green: "008000",
	    greenyellow: "adff2f",
	    grey: "808080",
	    honeydew: "f0fff0",
	    hotpink: "ff69b4",
	    indianred: "cd5c5c",
	    indigo: "4b0082",
	    ivory: "fffff0",
	    khaki: "f0e68c",
	    lavender: "e6e6fa",
	    lavenderblush: "fff0f5",
	    lawngreen: "7cfc00",
	    lemonchiffon: "fffacd",
	    lightblue: "add8e6",
	    lightcoral: "f08080",
	    lightcyan: "e0ffff",
	    lightgoldenrodyellow: "fafad2",
	    lightgray: "d3d3d3",
	    lightgreen: "90ee90",
	    lightgrey: "d3d3d3",
	    lightpink: "ffb6c1",
	    lightsalmon: "ffa07a",
	    lightseagreen: "20b2aa",
	    lightskyblue: "87cefa",
	    lightslategray: "789",
	    lightslategrey: "789",
	    lightsteelblue: "b0c4de",
	    lightyellow: "ffffe0",
	    lime: "0f0",
	    limegreen: "32cd32",
	    linen: "faf0e6",
	    magenta: "f0f",
	    maroon: "800000",
	    mediumaquamarine: "66cdaa",
	    mediumblue: "0000cd",
	    mediumorchid: "ba55d3",
	    mediumpurple: "9370db",
	    mediumseagreen: "3cb371",
	    mediumslateblue: "7b68ee",
	    mediumspringgreen: "00fa9a",
	    mediumturquoise: "48d1cc",
	    mediumvioletred: "c71585",
	    midnightblue: "191970",
	    mintcream: "f5fffa",
	    mistyrose: "ffe4e1",
	    moccasin: "ffe4b5",
	    navajowhite: "ffdead",
	    navy: "000080",
	    oldlace: "fdf5e6",
	    olive: "808000",
	    olivedrab: "6b8e23",
	    orange: "ffa500",
	    orangered: "ff4500",
	    orchid: "da70d6",
	    palegoldenrod: "eee8aa",
	    palegreen: "98fb98",
	    paleturquoise: "afeeee",
	    palevioletred: "db7093",
	    papayawhip: "ffefd5",
	    peachpuff: "ffdab9",
	    peru: "cd853f",
	    pink: "ffc0cb",
	    plum: "dda0dd",
	    powderblue: "b0e0e6",
	    purple: "800080",
	    rebeccapurple: "663399",
	    red: "f00",
	    rosybrown: "bc8f8f",
	    royalblue: "4169e1",
	    saddlebrown: "8b4513",
	    salmon: "fa8072",
	    sandybrown: "f4a460",
	    seagreen: "2e8b57",
	    seashell: "fff5ee",
	    sienna: "a0522d",
	    silver: "c0c0c0",
	    skyblue: "87ceeb",
	    slateblue: "6a5acd",
	    slategray: "708090",
	    slategrey: "708090",
	    snow: "fffafa",
	    springgreen: "00ff7f",
	    steelblue: "4682b4",
	    tan: "d2b48c",
	    teal: "008080",
	    thistle: "d8bfd8",
	    tomato: "ff6347",
	    turquoise: "40e0d0",
	    violet: "ee82ee",
	    wheat: "f5deb3",
	    white: "fff",
	    whitesmoke: "f5f5f5",
	    yellow: "ff0",
	    yellowgreen: "9acd32"
	};
	
	// Make it easy to access colors via `hexNames[hex]`
	var hexNames = tinycolor.hexNames = flip(names);
	
	
	// Utilities
	// ---------
	
	// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
	function flip(o) {
	    var flipped = { };
	    for (var i in o) {
	        if (o.hasOwnProperty(i)) {
	            flipped[o[i]] = i;
	        }
	    }
	    return flipped;
	}
	
	// Return a valid alpha value [0,1] with all invalid values being set to 1
	function boundAlpha(a) {
	    a = parseFloat(a);
	
	    if (isNaN(a) || a < 0 || a > 1) {
	        a = 1;
	    }
	
	    return a;
	}
	
	// Take input from [0, n] and return it as [0, 1]
	function bound01(n, max) {
	    if (isOnePointZero(n)) { n = "100%"; }
	
	    var processPercent = isPercentage(n);
	    n = mathMin(max, mathMax(0, parseFloat(n)));
	
	    // Automatically convert percentage into number
	    if (processPercent) {
	        n = parseInt(n * max, 10) / 100;
	    }
	
	    // Handle floating point rounding errors
	    if ((math.abs(n - max) < 0.000001)) {
	        return 1;
	    }
	
	    // Convert into [0, 1] range if it isn't already
	    return (n % max) / parseFloat(max);
	}
	
	// Force a number between 0 and 1
	function clamp01(val) {
	    return mathMin(1, mathMax(0, val));
	}
	
	// Parse a base-16 hex value into a base-10 integer
	function parseIntFromHex(val) {
	    return parseInt(val, 16);
	}
	
	// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
	// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
	function isOnePointZero(n) {
	    return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
	}
	
	// Check to see if string passed in is a percentage
	function isPercentage(n) {
	    return typeof n === "string" && n.indexOf('%') != -1;
	}
	
	// Force a hex value to have 2 characters
	function pad2(c) {
	    return c.length == 1 ? '0' + c : '' + c;
	}
	
	// Replace a decimal with it's percentage value
	function convertToPercentage(n) {
	    if (n <= 1) {
	        n = (n * 100) + "%";
	    }
	
	    return n;
	}
	
	// Converts a decimal to a hex value
	function convertDecimalToHex(d) {
	    return Math.round(parseFloat(d) * 255).toString(16);
	}
	// Converts a hex value to a decimal
	function convertHexToDecimal(h) {
	    return (parseIntFromHex(h) / 255);
	}
	
	var matchers = (function() {
	
	    // <http://www.w3.org/TR/css3-values/#integers>
	    var CSS_INTEGER = "[-\\+]?\\d+%?";
	
	    // <http://www.w3.org/TR/css3-values/#number-value>
	    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
	
	    // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
	    var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
	
	    // Actual matching.
	    // Parentheses and commas are optional, but not required.
	    // Whitespace can take the place of commas or opening paren
	    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
	    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
	
	    return {
	        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
	        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
	        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
	        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
	        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
	        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
	        hex3: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
	        hex6: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
	        hex8: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
	    };
	})();
	
	// `stringInputToObject`
	// Permissive string parsing.  Take in a number of formats, and output an object
	// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
	function stringInputToObject(color) {
	
	    color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
	    var named = false;
	    if (names[color]) {
	        color = names[color];
	        named = true;
	    }
	    else if (color == 'transparent') {
	        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
	    }
	
	    // Try to match string input using regular expressions.
	    // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
	    // Just return an object and let the conversion functions handle that.
	    // This way the result will be the same whether the tinycolor is initialized with string or object.
	    var match;
	    if ((match = matchers.rgb.exec(color))) {
	        return { r: match[1], g: match[2], b: match[3] };
	    }
	    if ((match = matchers.rgba.exec(color))) {
	        return { r: match[1], g: match[2], b: match[3], a: match[4] };
	    }
	    if ((match = matchers.hsl.exec(color))) {
	        return { h: match[1], s: match[2], l: match[3] };
	    }
	    if ((match = matchers.hsla.exec(color))) {
	        return { h: match[1], s: match[2], l: match[3], a: match[4] };
	    }
	    if ((match = matchers.hsv.exec(color))) {
	        return { h: match[1], s: match[2], v: match[3] };
	    }
	    if ((match = matchers.hsva.exec(color))) {
	        return { h: match[1], s: match[2], v: match[3], a: match[4] };
	    }
	    if ((match = matchers.hex8.exec(color))) {
	        return {
	            a: convertHexToDecimal(match[1]),
	            r: parseIntFromHex(match[2]),
	            g: parseIntFromHex(match[3]),
	            b: parseIntFromHex(match[4]),
	            format: named ? "name" : "hex8"
	        };
	    }
	    if ((match = matchers.hex6.exec(color))) {
	        return {
	            r: parseIntFromHex(match[1]),
	            g: parseIntFromHex(match[2]),
	            b: parseIntFromHex(match[3]),
	            format: named ? "name" : "hex"
	        };
	    }
	    if ((match = matchers.hex3.exec(color))) {
	        return {
	            r: parseIntFromHex(match[1] + '' + match[1]),
	            g: parseIntFromHex(match[2] + '' + match[2]),
	            b: parseIntFromHex(match[3] + '' + match[3]),
	            format: named ? "name" : "hex"
	        };
	    }
	
	    return false;
	}
	
	function validateWCAG2Parms(parms) {
	    // return valid WCAG2 parms for isReadable.
	    // If input parms are invalid, return {"level":"AA", "size":"small"}
	    var level, size;
	    parms = parms || {"level":"AA", "size":"small"};
	    level = (parms.level || "AA").toUpperCase();
	    size = (parms.size || "small").toLowerCase();
	    if (level !== "AA" && level !== "AAA") {
	        level = "AA";
	    }
	    if (size !== "small" && size !== "large") {
	        size = "small";
	    }
	    return {"level":level, "size":size};
	}
	// Node: Export function
	if (typeof module !== "undefined" && module.exports) {
	    module.exports = tinycolor;
	}
	// AMD/requirejs: Define the module
	else if (true) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {return tinycolor;}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	// Browser: Expose to window
	else {
	    window.tinycolor = tinycolor;
	}
	
	})();


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(182);
	__webpack_require__(183);
	__webpack_require__(205);
	__webpack_require__(212);
	__webpack_require__(228);
	module.exports = __webpack_require__(191).Set;

/***/ },
/* 182 */
/***/ function(module, exports) {



/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(184)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(187)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	// true  -> String#at
	// false -> String#codePointAt
	var toInteger = __webpack_require__(185)
	  , defined   = __webpack_require__(186);
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l
	      || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	        ? TO_STRING ? s.charAt(i) : a
	        : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 185 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 186 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY         = __webpack_require__(188)
	  , $def            = __webpack_require__(189)
	  , $redef          = __webpack_require__(192)
	  , hide            = __webpack_require__(193)
	  , has             = __webpack_require__(198)
	  , SYMBOL_ITERATOR = __webpack_require__(199)('iterator')
	  , Iterators       = __webpack_require__(202)
	  , BUGGY           = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR     = '@@iterator'
	  , KEYS            = 'keys'
	  , VALUES          = 'values';
	var returnThis = function(){ return this; };
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCE){
	  __webpack_require__(203)(Constructor, NAME, next);
	  var createMethod = function(kind){
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG      = NAME + ' Iterator'
	    , proto    = Base.prototype
	    , _native  = proto[SYMBOL_ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , _default = _native || createMethod(DEFAULT)
	    , methods, key;
	  // Fix native
	  if(_native){
	    var IteratorPrototype = __webpack_require__(194).getProto(_default.call(new Base));
	    // Set @@toStringTag to native iterators
	    __webpack_require__(204)(IteratorPrototype, TAG, true);
	    // FF fix
	    if(!LIBRARY && has(proto, FF_ITERATOR))hide(IteratorPrototype, SYMBOL_ITERATOR, returnThis);
	  }
	  // Define iterator
	  if(!LIBRARY || FORCE)hide(proto, SYMBOL_ITERATOR, _default);
	  // Plug for library
	  Iterators[NAME] = _default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEFAULT == VALUES ? _default : createMethod(VALUES),
	      keys:    IS_SET            ? _default : createMethod(KEYS),
	      entries: DEFAULT != VALUES ? _default : createMethod('entries')
	    };
	    if(FORCE)for(key in methods){
	      if(!(key in proto))$redef(proto, key, methods[key]);
	    } else $def($def.P + $def.F * BUGGY, NAME, methods);
	  }
	};

/***/ },
/* 188 */
/***/ function(module, exports) {

	module.exports = true;

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(190)
	  , core      = __webpack_require__(191)
	  , PROTOTYPE = 'prototype';
	var ctx = function(fn, that){
	  return function(){
	    return fn.apply(that, arguments);
	  };
	};
	var $def = function(type, name, source){
	  var key, own, out, exp
	    , isGlobal = type & $def.G
	    , isProto  = type & $def.P
	    , target   = isGlobal ? global : type & $def.S
	        ? global[name] : (global[name] || {})[PROTOTYPE]
	    , exports  = isGlobal ? core : core[name] || (core[name] = {});
	  if(isGlobal)source = name;
	  for(key in source){
	    // contains in native
	    own = !(type & $def.F) && target && key in target;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    if(isGlobal && typeof target[key] != 'function')exp = source[key];
	    // bind timers to global for call from export context
	    else if(type & $def.B && own)exp = ctx(out, global);
	    // wrap global constructors for prevent change them in library
	    else if(type & $def.W && target[key] == out)!function(C){
	      exp = function(param){
	        return this instanceof C ? new C(param) : C(param);
	      };
	      exp[PROTOTYPE] = C[PROTOTYPE];
	    }(out);
	    else exp = isProto && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export
	    exports[key] = exp;
	    if(isProto)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
	  }
	};
	// type bitmap
	$def.F = 1;  // forced
	$def.G = 2;  // global
	$def.S = 4;  // static
	$def.P = 8;  // proto
	$def.B = 16; // bind
	$def.W = 32; // wrap
	module.exports = $def;

/***/ },
/* 190 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 191 */
/***/ function(module, exports) {

	var core = module.exports = {version: '1.2.3'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(193);

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	var $          = __webpack_require__(194)
	  , createDesc = __webpack_require__(195);
	module.exports = __webpack_require__(196) ? function(object, key, value){
	  return $.setDesc(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 194 */
/***/ function(module, exports) {

	var $Object = Object;
	module.exports = {
	  create:     $Object.create,
	  getProto:   $Object.getPrototypeOf,
	  isEnum:     {}.propertyIsEnumerable,
	  getDesc:    $Object.getOwnPropertyDescriptor,
	  setDesc:    $Object.defineProperty,
	  setDescs:   $Object.defineProperties,
	  getKeys:    $Object.keys,
	  getNames:   $Object.getOwnPropertyNames,
	  getSymbols: $Object.getOwnPropertySymbols,
	  each:       [].forEach
	};

/***/ },
/* 195 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(197)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 197 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 198 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	var store  = __webpack_require__(200)('wks')
	  , Symbol = __webpack_require__(190).Symbol;
	module.exports = function(name){
	  return store[name] || (store[name] =
	    Symbol && Symbol[name] || (Symbol || __webpack_require__(201))('Symbol.' + name));
	};

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(190)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 201 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 202 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $ = __webpack_require__(194)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(193)(IteratorPrototype, __webpack_require__(199)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = $.create(IteratorPrototype, {next: __webpack_require__(195)(1,next)});
	  __webpack_require__(204)(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(194).setDesc
	  , has = __webpack_require__(198)
	  , TAG = __webpack_require__(199)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(206);
	var Iterators = __webpack_require__(202);
	Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var setUnscope = __webpack_require__(207)
	  , step       = __webpack_require__(208)
	  , Iterators  = __webpack_require__(202)
	  , toIObject  = __webpack_require__(209);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	__webpack_require__(187)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	setUnscope('keys');
	setUnscope('values');
	setUnscope('entries');

/***/ },
/* 207 */
/***/ function(module, exports) {

	module.exports = function(){ /* empty */ };

/***/ },
/* 208 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(210)
	  , defined = __webpack_require__(186);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(211);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 211 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(213);
	
	// 23.2 Set Objects
	__webpack_require__(227)('Set', function(get){
	  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value){
	    return strong.def(this, value = value === 0 ? 0 : value, value);
	  }
	}, strong);

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $            = __webpack_require__(194)
	  , hide         = __webpack_require__(193)
	  , ctx          = __webpack_require__(214)
	  , species      = __webpack_require__(216)
	  , strictNew    = __webpack_require__(217)
	  , defined      = __webpack_require__(186)
	  , forOf        = __webpack_require__(218)
	  , step         = __webpack_require__(208)
	  , ID           = __webpack_require__(201)('id')
	  , $has         = __webpack_require__(198)
	  , isObject     = __webpack_require__(221)
	  , isExtensible = Object.isExtensible || isObject
	  , SUPPORT_DESC = __webpack_require__(196)
	  , SIZE         = SUPPORT_DESC ? '_s' : 'size'
	  , id           = 0;
	
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!$has(it, ID)){
	    // can't set id to frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add id
	    if(!create)return 'E';
	    // add missing object id
	    hide(it, ID, ++id);
	  // return object id with prefix
	  } return 'O' + it[ID];
	};
	
	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      strictNew(that, C, NAME);
	      that._i = $.create(null); // index
	      that._f = undefined;      // first entry
	      that._l = undefined;      // last entry
	      that[SIZE] = 0;           // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    __webpack_require__(226)(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(SUPPORT_DESC)$.setDesc(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    __webpack_require__(187)(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
	
	    // add [@@species], 23.1.2.2, 23.2.2.2
	    species(C);
	    species(__webpack_require__(191)[NAME]); // for wrapper
	  }
	};

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(215);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 215 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $       = __webpack_require__(194)
	  , SPECIES = __webpack_require__(199)('species');
	module.exports = function(C){
	  if(__webpack_require__(196) && !(SPECIES in C))$.setDesc(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 217 */
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name){
	  if(!(it instanceof Constructor))throw TypeError(name + ": use the 'new' operator!");
	  return it;
	};

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(214)
	  , call        = __webpack_require__(219)
	  , isArrayIter = __webpack_require__(222)
	  , anObject    = __webpack_require__(220)
	  , toLength    = __webpack_require__(223)
	  , getIterFn   = __webpack_require__(224);
	module.exports = function(iterable, entries, fn, that){
	  var iterFn = getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    call(iterator, f, step.value, entries);
	  }
	};

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(220);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(221);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 221 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators = __webpack_require__(202)
	  , ITERATOR  = __webpack_require__(199)('iterator');
	module.exports = function(it){
	  return (Iterators.Array || Array.prototype[ITERATOR]) === it;
	};

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(185)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(225)
	  , ITERATOR  = __webpack_require__(199)('iterator')
	  , Iterators = __webpack_require__(202);
	module.exports = __webpack_require__(191).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(211)
	  , TAG = __webpack_require__(199)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	var $redef = __webpack_require__(192);
	module.exports = function(target, src){
	  for(var key in src)$redef(target, key, src[key]);
	  return target;
	};

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $          = __webpack_require__(194)
	  , $def       = __webpack_require__(189)
	  , hide       = __webpack_require__(193)
	  , forOf      = __webpack_require__(218)
	  , strictNew  = __webpack_require__(217);
	
	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = __webpack_require__(190)[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  if(!__webpack_require__(196) || typeof C != 'function'
	    || !(IS_WEAK || proto.forEach && !__webpack_require__(197)(function(){ new C().entries().next(); }))
	  ){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    __webpack_require__(226)(C.prototype, methods);
	  } else {
	    C = wrapper(function(target, iterable){
	      strictNew(target, C, NAME);
	      target._c = new Base;
	      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
	    });
	    $.each.call('add,clear,delete,forEach,get,has,set,keys,values,entries'.split(','),function(KEY){
	      var chain = KEY == 'add' || KEY == 'set';
	      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
	        var result = this._c[KEY](a === 0 ? 0 : a, b);
	        return chain ? this : result;
	      });
	    });
	    if('size' in proto)$.setDesc(C.prototype, 'size', {
	      get: function(){
	        return this._c.size;
	      }
	    });
	  }
	
	  __webpack_require__(204)(C, NAME);
	
	  O[NAME] = C;
	  $def($def.G + $def.W + $def.F, O);
	
	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);
	
	  return C;
	};

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $def  = __webpack_require__(189);
	
	$def($def.P, 'Set', {toJSON: __webpack_require__(229)('Set')});

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var forOf   = __webpack_require__(218)
	  , classof = __webpack_require__(225);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    var arr = [];
	    forOf(this, false, arr.push, arr);
	    return arr;
	  };
	};

/***/ },
/* 230 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * 
	 */
	
	'use strict';
	
	function tensionFromOrigamiValue(oValue) {
	  return (oValue - 30) * 3.62 + 194;
	}
	
	function frictionFromOrigamiValue(oValue) {
	  return (oValue - 8) * 3 + 25;
	}
	
	function fromOrigamiTensionAndFriction(tension, friction) {
	  return {
	    tension: tensionFromOrigamiValue(tension),
	    friction: frictionFromOrigamiValue(friction)
	  };
	}
	
	function fromBouncinessAndSpeed(bounciness, speed) {
	  function normalize(value, startValue, endValue) {
	    return (value - startValue) / (endValue - startValue);
	  }
	
	  function projectNormal(n, start, end) {
	    return start + n * (end - start);
	  }
	
	  function linearInterpolation(t, start, end) {
	    return t * end + (1 - t) * start;
	  }
	
	  function quadraticOutInterpolation(t, start, end) {
	    return linearInterpolation(2 * t - t * t, start, end);
	  }
	
	  function b3Friction1(x) {
	    return 0.0007 * Math.pow(x, 3) - 0.031 * Math.pow(x, 2) + 0.64 * x + 1.28;
	  }
	
	  function b3Friction2(x) {
	    return 0.000044 * Math.pow(x, 3) - 0.006 * Math.pow(x, 2) + 0.36 * x + 2;
	  }
	
	  function b3Friction3(x) {
	    return 0.00000045 * Math.pow(x, 3) - 0.000332 * Math.pow(x, 2) + 0.1078 * x + 5.84;
	  }
	
	  function b3Nobounce(tension) {
	    if (tension <= 18) {
	      return b3Friction1(tension);
	    } else if (tension > 18 && tension <= 44) {
	      return b3Friction2(tension);
	    } else {
	      return b3Friction3(tension);
	    }
	  }
	
	  var b = normalize(bounciness / 1.7, 0, 20);
	  b = projectNormal(b, 0, 0.8);
	  var s = normalize(speed / 1.7, 0, 20);
	  var bouncyTension = projectNormal(s, 0.5, 200);
	  var bouncyFriction = quadraticOutInterpolation(b, b3Nobounce(bouncyTension), 0.01);
	
	  return {
	    tension: tensionFromOrigamiValue(bouncyTension),
	    friction: frictionFromOrigamiValue(bouncyFriction)
	  };
	}
	
	module.exports = {
	  fromOrigamiTensionAndFriction: fromOrigamiTensionAndFriction,
	  fromBouncinessAndSpeed: fromBouncinessAndSpeed
	};

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule invariant
	 */
	
	"use strict";
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var invariant = function (condition, format, a, b, c, d, e, f) {
	  if (false) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error('Invariant Violation: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};
	
	module.exports = invariant;

/***/ },
/* 232 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 */
	'use strict';
	
	var emptyFunction = function emptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	};
	
	var lastTime = 0;
	
	var requestAnimationFrame = function requestAnimationFrame(callback) {
	  var currTime = Date.now();
	  var timeDelay = Math.max(0, 16 - (currTime - lastTime));
	  lastTime = currTime + timeDelay;
	  return global.setTimeout(function () {
	    callback(Date.now());
	  }, timeDelay);
	};
	
	// Works around a rare bug in Safari 6 where the first request is never invoked.
	requestAnimationFrame(emptyFunction);
	
	module.exports = requestAnimationFrame;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * @providesModule ReactImage
	 */
	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _ReactView = __webpack_require__(164);
	
	var _ReactView2 = _interopRequireDefault(_ReactView);
	
	var _ReactLayoutMixin = __webpack_require__(165);
	
	var _ImageResizeMode = __webpack_require__(234);
	
	var _ImageResizeMode2 = _interopRequireDefault(_ImageResizeMode);
	
	var Image = _react2['default'].createClass({
	  displayName: 'Image',
	
	  statics: {
	    resizeMode: _ImageResizeMode2['default']
	  },
	
	  mixins: [_ReactLayoutMixin.Mixin],
	
	  contextTypes: {
	    isInAParentText: _react2['default'].PropTypes.bool
	  },
	  render: function render() {
	
	    var props = _extends({}, this.props);
	    props.src = typeof props.source === 'string' ? props.source : props.source.uri;
	
	    // TODO: lazyload image when not in viewport
	
	    var resizeMode = this.props.resizeMode;
	
	    // Background image element, resizeMode is strtch is equal default img style
	    if ((this.props.children || resizeMode && resizeMode !== 'stretch') && !this.context.isInAParentText) {
	      var containerStyles = props.style ? props.style : {};
	      containerStyles.backgroundImage = 'url("' + props.src + '")';
	      containerStyles.backgroundSize = resizeMode || 'cover';
	      containerStyles.backgroundRepeat = 'no-repeat';
	      containerStyles.backgroundPosition = '50%';
	
	      return _react2['default'].createElement(
	        _ReactView2['default'],
	        { style: containerStyles, 'data-src': props.src },
	        this.props.children
	      );
	    } else {
	      return _react2['default'].createElement('img', props);
	    }
	  }
	});
	
	module.exports = Image;

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * 
	 */
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _fbjsLibKeyMirror = __webpack_require__(235);
	
	var _fbjsLibKeyMirror2 = _interopRequireDefault(_fbjsLibKeyMirror);
	
	/**
	 * ImageResizeMode - Enum for different image resizing modes, set via
	 * `resizeMode` style property on `<Image>` components.
	 */
	var ImageResizeMode = (0, _fbjsLibKeyMirror2['default'])({
	  /**
	   * contain - The image will be resized such that it will be completely
	   * visible, contained within the frame of the View.
	   */
	  contain: null,
	  /**
	   * cover - The image will be resized such that the entire area of the view
	   * is covered by the image, potentially clipping parts of the image.
	   */
	  cover: null,
	  /**
	   * stretch - The image will be stretched to fill the entire frame of the
	   * view without clipping. This may change the aspect ratio of the image,
	   * distoring it.
	   */
	  stretch: null
	});
	
	module.exports = ImageResizeMode;

/***/ },
/* 235 */
[390, 231],
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015, Facebook, Inc.  All rights reserved.
	 *
	 * @providesModule ReactText
	 */
	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _ReactTouchable = __webpack_require__(237);
	
	var _ReactLayoutMixin = __webpack_require__(165);
	
	/**
	 * A React component for displaying text which supports nesting,
	 * styling, and touch handling.  In the following example, the nested title and
	 * body text will inherit the `fontFamily` from `styles.baseText`, but the title
	 * provides its own additional styles.  The title and body will stack on top of
	 * each other on account of the literal newlines:
	 *
	 * ```
	 * renderText: function() {
	 *   return (
	 *     <Text style={styles.baseText}>
	 *       <Text style={styles.titleText} onPress={this.onPressTitle}>
	 *         {this.state.titleText + '\n\n'}
	 *       </Text>
	 *       <Text numberOfLines={5}>
	 *         {this.state.bodyText}
	 *       </Text>
	 *     </Text>
	 *   );
	 * },
	 * ...
	 * var styles = StyleSheet.create({
	 *   baseText: {
	 *     fontFamily: 'Cochin',
	 *   },
	 *   titleText: {
	 *     fontSize: 20,
	 *     fontWeight: 'bold',
	 *   },
	 * };
	 * ```
	 */
	
	var Text = _react2['default'].createClass({
	  displayName: 'Text',
	
	  mixins: [_ReactLayoutMixin.Mixin, _ReactTouchable.Mixin],
	
	  propTypes: {
	    /**
	     * Used to truncate the text with an elipsis after computing the text
	     * layout, including line wrapping, such that the total number of lines
	     * does not exceed this number.
	     */
	    numberOfLines: _react2['default'].PropTypes.number,
	    /**
	     * Invoked on mount and layout changes with
	     *
	     *   `{nativeEvent: {layout: {x, y, width, height}}}`
	     */
	    onLayout: _react2['default'].PropTypes.func,
	    /**
	     * This function is called on press.
	     */
	    onPress: _react2['default'].PropTypes.func,
	    /**
	     * When true, no visual change is made when text is pressed down. By
	     * default, a gray oval highlights the text on press down.
	     * @platform ios
	     */
	    suppressHighlighting: _react2['default'].PropTypes.bool,
	    /**
	     * Used to locate this view in end-to-end tests.
	     */
	    testID: _react2['default'].PropTypes.string,
	    /**
	     * Specifies should fonts scale to respect Text Size accessibility setting on iOS.
	     */
	    allowFontScaling: _react2['default'].PropTypes.bool
	  },
	
	  getInitialState: function getInitialState() {
	    return _extends({}, this.touchableGetInitialState(), {
	      isHighlighted: false
	    });
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      allowFontScaling: true
	    };
	  },
	
	  // componentDidMount: function() {
	  //   console.log('mount')
	  // },
	  //
	  // componentDidUpdate: function() {
	  //   console.log('update')
	  // },
	
	  onStartShouldSetResponder: function onStartShouldSetResponder() {
	    var shouldSetFromProps = this.props.onStartShouldSetResponder && this.props.onStartShouldSetResponder();
	    return shouldSetFromProps || !!this.props.onPress;
	  },
	
	  /*
	   * Returns true to allow responder termination
	   */
	  handleResponderTerminationRequest: function handleResponderTerminationRequest() {
	    // Allow touchable or props.onResponderTerminationRequest to deny
	    // the request
	    var allowTermination = this.touchableHandleResponderTerminationRequest();
	    if (allowTermination && this.props.onResponderTerminationRequest) {
	      allowTermination = this.props.onResponderTerminationRequest();
	    }
	    return allowTermination;
	  },
	
	  handleResponderGrant: function handleResponderGrant(e, dispatchID) {
	    this.touchableHandleResponderGrant(e, dispatchID);
	    this.props.onResponderGrant && this.props.onResponderGrant.apply(this, arguments);
	  },
	
	  handleResponderMove: function handleResponderMove(e) {
	    this.touchableHandleResponderMove(e);
	    this.props.onResponderMove && this.props.onResponderMove.apply(this, arguments);
	  },
	
	  handleResponderRelease: function handleResponderRelease(e) {
	    this.touchableHandleResponderRelease(e);
	    this.props.onResponderRelease && this.props.onResponderRelease.apply(this, arguments);
	  },
	
	  handleResponderTerminate: function handleResponderTerminate(e) {
	    this.touchableHandleResponderTerminate(e);
	    this.props.onResponderTerminate && this.props.onResponderTerminate.apply(this, arguments);
	  },
	
	  touchableHandleActivePressIn: function touchableHandleActivePressIn() {
	    if (this.props.suppressHighlighting || !this.props.onPress) {
	      return;
	    }
	    this.setState({
	      isHighlighted: true
	    });
	  },
	
	  touchableHandleActivePressOut: function touchableHandleActivePressOut() {
	    if (this.props.suppressHighlighting || !this.props.onPress) {
	      return;
	    }
	    this.setState({
	      isHighlighted: false
	    });
	  },
	
	  touchableHandlePress: function touchableHandlePress() {
	    this.props.onPress && this.props.onPress();
	  },
	
	  touchableGetPressRectOffset: function touchableGetPressRectOffset() {
	    return PRESS_RECT_OFFSET;
	  },
	
	  getChildContext: function getChildContext() {
	    return { isInAParentText: true };
	  },
	
	  contextTypes: {
	    isInAParentText: _react2['default'].PropTypes.bool
	  },
	
	  childContextTypes: {
	    isInAParentText: _react2['default'].PropTypes.bool
	  },
	
	  render: function render() {
	    var props = _extends({}, this.props);
	    // Text is accessible by default
	    if (props.accessible !== false) {
	      props.accessible = true;
	    }
	    props.isHighlighted = this.state.isHighlighted;
	    props.onStartShouldSetResponder = this.onStartShouldSetResponder;
	    props.onResponderTerminationRequest = this.handleResponderTerminationRequest;
	    props.onResponderGrant = this.handleResponderGrant;
	    props.onResponderMove = this.handleResponderMove;
	    props.onResponderRelease = this.handleResponderRelease;
	    props.onResponderTerminate = this.handleResponderTerminate;
	
	    var numberOfLines = props.numberOfLines;
	    var style = props.style;
	
	    style = _extends({}, props.style);
	
	    if (typeof style.lineHeight == 'number') {
	      style.lineHeight += 'px';
	    }
	
	    // Default lineHeight is 1.2 x fontSize
	    var lineHeight = style.lineHeight || (style.fontSize || 16) * 1.2; // FIXME:  not sure 16px is the default line height
	    if (typeof lineHeight == 'number') {
	      lineHeight += 'px';
	    }
	    style.lineHeight = lineHeight;
	
	    if (style.textDecorationLine) {
	      style.textDecoration = style.textDecorationLine;
	    }
	
	    if (!props.children) {
	      // TODO set a linebreak
	    }
	
	    return _react2['default'].createElement('span', _extends({}, props, {
	      style: _extends({
	        display: this.context.isInAParentText ? 'inline' : 'inline-block',
	        margin: 0,
	        padding: 0,
	        wordWrap: 'break-word',
	        fontFamily: 'Calibri, Helvetica Neue, STHeiTi, sans-serif'
	      }, style, numberOfLines && {
	        overflow: 'hidden',
	        textOverflow: 'ellipsis',
	        wordWrap: 'break-word',
	        display: '-webkit-box',
	        WebkitLineClamp: numberOfLines,
	        WebkitBoxOrient: 'vertical',
	        maxHeight: parseFloat(lineHeight) * numberOfLines
	      }) }));
	  }
	});
	
	var PRESS_RECT_OFFSET = { top: 20, left: 20, right: 20, bottom: 30 };
	
	module.exports = Text;

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015, Facebook, Inc.  All rights reserved.
	 *
	 * @providesModule ReactTouchable
	 */
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _TouchEventUtils = __webpack_require__(238);
	
	var _TouchEventUtils2 = _interopRequireDefault(_TouchEventUtils);
	
	var _keyMirror = __webpack_require__(239);
	
	var _keyMirror2 = _interopRequireDefault(_keyMirror);
	
	/**
	 * `Touchable`: Taps done right.
	 *
	 * You hook your `ResponderEventPlugin` events into `Touchable`. `Touchable`
	 * will measure time/geometry and tells you when to give feedback to the user.
	 *
	 * ====================== Touchable Tutorial ===============================
	 * The `Touchable` mixin helps you handle the "press" interaction. It analyzes
	 * the geometry of elements, and observes when another responder (scroll view
	 * etc) has stolen the touch lock. It notifies your component when it should
	 * give feedback to the user. (bouncing/highlighting/unhighlighting).
	 *
	 * - When a touch was activated (typically you highlight)
	 * - When a touch was deactivated (typically you unhighlight)
	 * - When a touch was "pressed" - a touch ended while still within the geometry
	 *   of the element, and no other element (like scroller) has "stolen" touch
	 *   lock ("responder") (Typically you bounce the element).
	 *
	 * A good tap interaction isn't as simple as you might think. There should be a
	 * slight delay before showing a highlight when starting a touch. If a
	 * subsequent touch move exceeds the boundary of the elemement, it should
	 * unhighlight, but if that same touch is brought back within the boundary, it
	 * should rehighlight again. A touch can move in and out of that boundary
	 * several times, each time toggling highlighting, but a "press" is only
	 * triggered if that touch ends while within the element's boundary and no
	 * scroller (or anything else) has stolen the lock on touches.
	 *
	 * To create a new type of component that handles interaction using the
	 * `Touchable` mixin, do the following:
	 *
	 * - Initialize the `Touchable` state.
	 *
	 *   getInitialState: function() {
	 *     return merge(this.touchableGetInitialState(), yourComponentState);
	 *   }
	 *
	 * - Choose the rendered component who's touches should start the interactive
	 *   sequence. On that rendered node, forward all `Touchable` responder
	 *   handlers. You can choose any rendered node you like. Choose a node who's
	 *   hit target you'd like to instigate the interaction sequence:
	 *
	 *   // In render function:
	 *   return (
	 *     <div
	 *       onStartShouldSetResponder={this.touchableHandleStartShouldSetResponder}
	 *       onResponderTerminationRequest={this.touchableHandleResponderTerminationRequest}
	 *       onResponderGrant={this.touchableHandleResponderGrant}
	 *       onResponderMove={this.touchableHandleResponderMove}
	 *       onResponderRelease={this.touchableHandleResponderRelease}
	 *       onResponderTerminate={this.touchableHandleResponderTerminate}>
	 *       <div>
	 *         Even though the hit detection/interactions are triggered by the
	 *         wrapping (typically larger) node, we usually end up implementing
	 *         custom logic that highlights this inner one.
	 *       </div>
	 *     </div>
	 *   );
	 *
	 * - You may set up your own handlers for each of these events, so long as you
	 *   also invoke the `touchable*` handlers inside of your custom handler.
	 *
	 * - Implement the handlers on your component class in order to provide
	 *   feedback to the user. See documentation for each of these class methods
	 *   that you should implement.
	 *
	 *   touchableHandlePress: function() {
	 *      this.performBounceAnimation();  // or whatever you want to do.
	 *   },
	 *   touchableHandleActivePressIn: function() {
	 *     this.beginHighlighting(...);  // Whatever you like to convey activation
	 *   },
	 *   touchableHandleActivePressOut: function() {
	 *     this.endHighlighting(...);  // Whatever you like to convey deactivation
	 *   },
	 *
	 * - There are more advanced methods you can implement (see documentation below):
	 *   touchableGetHighlightDelayMS: function() {
	 *     return 20;
	 *   }
	 *   // In practice, *always* use a predeclared constant (conserve memory).
	 *   touchableGetPressRectOffset: function() {
	 *     return {top: 20, left: 20, right: 20, bottom: 100};
	 *   }
	 */
	
	/**
	 * Touchable states.
	 */
	var States = (0, _keyMirror2['default'])({
	  NOT_RESPONDER: null, // Not the responder
	  RESPONDER_INACTIVE_PRESS_IN: null, // Responder, inactive, in the `PressRect`
	  RESPONDER_INACTIVE_PRESS_OUT: null, // Responder, inactive, out of `PressRect`
	  RESPONDER_ACTIVE_PRESS_IN: null, // Responder, active, in the `PressRect`
	  RESPONDER_ACTIVE_PRESS_OUT: null, // Responder, active, out of `PressRect`
	  RESPONDER_ACTIVE_LONG_PRESS_IN: null, // Responder, active, in the `PressRect`, after long press threshold
	  RESPONDER_ACTIVE_LONG_PRESS_OUT: null, // Responder, active, out of `PressRect`, after long press threshold
	  ERROR: null
	});
	
	/**
	 * Quick lookup map for states that are considered to be "active"
	 */
	var IsActive = {
	  RESPONDER_ACTIVE_PRESS_OUT: true,
	  RESPONDER_ACTIVE_PRESS_IN: true
	};
	
	/**
	 * Quick lookup for states that are considered to be "pressing" and are
	 * therefore eligible to result in a "selection" if the press stops.
	 */
	var IsPressingIn = {
	  RESPONDER_INACTIVE_PRESS_IN: true,
	  RESPONDER_ACTIVE_PRESS_IN: true,
	  RESPONDER_ACTIVE_LONG_PRESS_IN: true
	};
	
	var IsLongPressingIn = {
	  RESPONDER_ACTIVE_LONG_PRESS_IN: true
	};
	
	/**
	 * Inputs to the state machine.
	 */
	var Signals = (0, _keyMirror2['default'])({
	  DELAY: null,
	  RESPONDER_GRANT: null,
	  RESPONDER_RELEASE: null,
	  RESPONDER_TERMINATED: null,
	  ENTER_PRESS_RECT: null,
	  LEAVE_PRESS_RECT: null,
	  LONG_PRESS_DETECTED: null
	});
	/**
	 * Mapping from States x Signals => States
	 */
	var Transitions = {
	  NOT_RESPONDER: {
	    DELAY: States.ERROR,
	    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,
	    RESPONDER_RELEASE: States.ERROR,
	    RESPONDER_TERMINATED: States.ERROR,
	    ENTER_PRESS_RECT: States.ERROR,
	    LEAVE_PRESS_RECT: States.ERROR,
	    LONG_PRESS_DETECTED: States.ERROR
	  },
	  RESPONDER_INACTIVE_PRESS_IN: {
	    DELAY: States.RESPONDER_ACTIVE_PRESS_IN,
	    RESPONDER_GRANT: States.ERROR,
	    RESPONDER_RELEASE: States.NOT_RESPONDER,
	    RESPONDER_TERMINATED: States.NOT_RESPONDER,
	    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,
	    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,
	    LONG_PRESS_DETECTED: States.ERROR
	  },
	  RESPONDER_INACTIVE_PRESS_OUT: {
	    DELAY: States.RESPONDER_ACTIVE_PRESS_OUT,
	    RESPONDER_GRANT: States.ERROR,
	    RESPONDER_RELEASE: States.NOT_RESPONDER,
	    RESPONDER_TERMINATED: States.NOT_RESPONDER,
	    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,
	    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,
	    LONG_PRESS_DETECTED: States.ERROR
	  },
	  RESPONDER_ACTIVE_PRESS_IN: {
	    DELAY: States.ERROR,
	    RESPONDER_GRANT: States.ERROR,
	    RESPONDER_RELEASE: States.NOT_RESPONDER,
	    RESPONDER_TERMINATED: States.NOT_RESPONDER,
	    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,
	    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,
	    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN
	  },
	  RESPONDER_ACTIVE_PRESS_OUT: {
	    DELAY: States.ERROR,
	    RESPONDER_GRANT: States.ERROR,
	    RESPONDER_RELEASE: States.NOT_RESPONDER,
	    RESPONDER_TERMINATED: States.NOT_RESPONDER,
	    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,
	    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,
	    LONG_PRESS_DETECTED: States.ERROR
	  },
	  RESPONDER_ACTIVE_LONG_PRESS_IN: {
	    DELAY: States.ERROR,
	    RESPONDER_GRANT: States.ERROR,
	    RESPONDER_RELEASE: States.NOT_RESPONDER,
	    RESPONDER_TERMINATED: States.NOT_RESPONDER,
	    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,
	    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,
	    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN
	  },
	  RESPONDER_ACTIVE_LONG_PRESS_OUT: {
	    DELAY: States.ERROR,
	    RESPONDER_GRANT: States.ERROR,
	    RESPONDER_RELEASE: States.NOT_RESPONDER,
	    RESPONDER_TERMINATED: States.NOT_RESPONDER,
	    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,
	    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,
	    LONG_PRESS_DETECTED: States.ERROR
	  },
	  error: {
	    DELAY: States.NOT_RESPONDER,
	    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,
	    RESPONDER_RELEASE: States.NOT_RESPONDER,
	    RESPONDER_TERMINATED: States.NOT_RESPONDER,
	    ENTER_PRESS_RECT: States.NOT_RESPONDER,
	    LEAVE_PRESS_RECT: States.NOT_RESPONDER,
	    LONG_PRESS_DETECTED: States.NOT_RESPONDER
	  }
	};
	
	// ==== Typical Constants for integrating into UI components ====
	// var HIT_EXPAND_PX = 20;
	// var HIT_VERT_OFFSET_PX = 10;
	var HIGHLIGHT_DELAY_MS = 130;
	
	var PRESS_EXPAND_PX = 20;
	
	var LONG_PRESS_THRESHOLD = 500;
	
	var LONG_PRESS_DELAY_MS = LONG_PRESS_THRESHOLD - HIGHLIGHT_DELAY_MS;
	
	var LONG_PRESS_ALLOWED_MOVEMENT = 10;
	
	// Default amount "active" region protrudes beyond box
	
	/**
	 * By convention, methods prefixed with underscores are meant to be @private,
	 * and not @protected. Mixers shouldn't access them - not even to provide them
	 * as callback handlers.
	 *
	 *
	 * ========== Geometry =========
	 * `Touchable` only assumes that there exists a `HitRect` node. The `PressRect`
	 * is an abstract box that is extended beyond the `HitRect`.
	 *
	 *  +--------------------------+
	 *  |                          | - "Start" events in `HitRect` cause `HitRect`
	 *  |  +--------------------+  |   to become the responder.
	 *  |  |  +--------------+  |  | - `HitRect` is typically expanded around
	 *  |  |  |              |  |  |   the `VisualRect`, but shifted downward.
	 *  |  |  |  VisualRect  |  |  | - After pressing down, after some delay,
	 *  |  |  |              |  |  |   and before letting up, the Visual React
	 *  |  |  +--------------+  |  |   will become "active". This makes it eligible
	 *  |  |     HitRect        |  |   for being highlighted (so long as the
	 *  |  +--------------------+  |   press remains in the `PressRect`).
	 *  |        PressRect     o   |
	 *  +----------------------|---+
	 *           Out Region    |
	 *                         +-----+ This gap between the `HitRect` and
	 *                                 `PressRect` allows a touch to move far away
	 *                                 from the original hit rect, and remain
	 *                                 highlighted, and eligible for a "Press".
	 *                                 Customize this via
	 *                                 `touchableGetPressRectOffset()`.
	 *
	 *
	 *
	 * ======= State Machine =======
	 *
	 * +-------------+ <---+ RESPONDER_RELEASE
	 * |NOT_RESPONDER|
	 * +-------------+ <---+ RESPONDER_TERMINATED
	 *     +
	 *     | RESPONDER_GRANT (HitRect)
	 *     v
	 * +---------------------------+  DELAY   +-------------------------+  T + DELAY     +------------------------------+
	 * |RESPONDER_INACTIVE_PRESS_IN|+-------->|RESPONDER_ACTIVE_PRESS_IN| +------------> |RESPONDER_ACTIVE_LONG_PRESS_IN|
	 * +---------------------------+          +-------------------------+                +------------------------------+
	 *     +            ^                         +           ^                                 +           ^
	 *     |LEAVE_      |ENTER_                   |LEAVE_     |ENTER_                           |LEAVE_     |ENTER_
	 *     |PRESS_RECT  |PRESS_RECT               |PRESS_RECT |PRESS_RECT                       |PRESS_RECT |PRESS_RECT
	 *     |            |                         |           |                                 |           |
	 *     v            +                         v           +                                 v           +
	 * +----------------------------+  DELAY  +--------------------------+               +-------------------------------+
	 * |RESPONDER_INACTIVE_PRESS_OUT|+------->|RESPONDER_ACTIVE_PRESS_OUT|               |RESPONDER_ACTIVE_LONG_PRESS_OUT|
	 * +----------------------------+         +--------------------------+               +-------------------------------+
	 *
	 * T + DELAY => LONG_PRESS_DELAY_MS + DELAY
	 *
	 * Not drawn are the side effects of each transition. The most important side
	 * effect is the `touchableHandlePress` abstract method invocation that occurs
	 * when a responder is released while in either of the "Press" states.
	 *
	 * The other important side effects are the highlight abstract method
	 * invocations (internal callbacks) to be implemented by the mixer.
	 *
	 *
	 * @lends Touchable.prototype
	 */
	var TouchableMixin = {
	  /**
	   * It's prefer that mixins determine state in this way, having the class
	   * explicitly mix the state in the one and only `getInitialState` method.
	   *
	   * @return {object} State object to be placed inside of
	   * `this.state.touchable`.
	   */
	  touchableGetInitialState: function touchableGetInitialState() {
	    return {
	      touchable: {
	        touchState: undefined,
	        responderID: null
	      }
	    };
	  },
	
	  // ==== Hooks to Gesture Responder system ====
	  /**
	   * Must return true if embedded in a native platform scroll view.
	   */
	  touchableHandleResponderTerminationRequest: function touchableHandleResponderTerminationRequest() {
	    return !this.props.rejectResponderTermination;
	  },
	
	  /**
	   * Must return true to start the process of `Touchable`.
	   */
	  touchableHandleStartShouldSetResponder: function touchableHandleStartShouldSetResponder() {
	    return true;
	  },
	
	  /**
	   * Return true to cancel press on long press.
	   */
	  touchableLongPressCancelsPress: function touchableLongPressCancelsPress() {
	    return true;
	  },
	
	  /**
	   * Place as callback for a DOM element's `onResponderGrant` event.
	   * @param {SyntheticEvent} e Synthetic event from event system.
	   * @param {string} dispatchID ID of node that e was dispatched to.
	   *
	   */
	  touchableHandleResponderGrant: function touchableHandleResponderGrant(e, dispatchID) {
	    // Since e is used in a callback invoked on another event loop
	    // (as in setTimeout etc), we need to call e.persist() on the
	    // event to make sure it doesn't get reused in the event object pool.
	    e.persist();
	
	    this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);
	    this.pressOutDelayTimeout = null;
	
	    this.state.touchable.touchState = States.NOT_RESPONDER;
	    this.state.touchable.responderID = dispatchID;
	    this._receiveSignal(Signals.RESPONDER_GRANT, e);
	    var delayMS = this.touchableGetHighlightDelayMS !== undefined ? Math.max(this.touchableGetHighlightDelayMS(), 0) : HIGHLIGHT_DELAY_MS;
	    delayMS = isNaN(delayMS) ? HIGHLIGHT_DELAY_MS : delayMS;
	    if (delayMS !== 0) {
	      this.touchableDelayTimeout = setTimeout(this._handleDelay.bind(this, e), delayMS);
	    } else {
	      this._handleDelay(e);
	    }
	
	    var longDelayMS = this.touchableGetLongPressDelayMS !== undefined ? Math.max(this.touchableGetLongPressDelayMS(), 10) : LONG_PRESS_DELAY_MS;
	    longDelayMS = isNaN(longDelayMS) ? LONG_PRESS_DELAY_MS : longDelayMS;
	    this.longPressDelayTimeout = setTimeout(this._handleLongDelay.bind(this, e), longDelayMS + delayMS);
	  },
	
	  /**
	   * Place as callback for a DOM element's `onResponderRelease` event.
	   */
	  touchableHandleResponderRelease: function touchableHandleResponderRelease(e) {
	    this._receiveSignal(Signals.RESPONDER_RELEASE, e);
	  },
	
	  /**
	   * Place as callback for a DOM element's `onResponderTerminate` event.
	   */
	  touchableHandleResponderTerminate: function touchableHandleResponderTerminate(e) {
	    this._receiveSignal(Signals.RESPONDER_TERMINATED, e);
	  },
	
	  /**
	   * Place as callback for a DOM element's `onResponderMove` event.
	   */
	  touchableHandleResponderMove: function touchableHandleResponderMove(e) {
	    // Not enough time elapsed yet, wait for highlight -
	    // this is just a perf optimization.
	    if (this.state.touchable.touchState === States.RESPONDER_INACTIVE_PRESS_IN) {
	      return;
	    }
	
	    // Measurement may not have returned yet.
	    if (!this.state.touchable.positionOnActivate) {
	      return;
	    }
	
	    var positionOnActivate = this.state.touchable.positionOnActivate;
	    var dimensionsOnActivate = this.state.touchable.dimensionsOnActivate;
	    var pressRectOffset = this.touchableGetPressRectOffset ? this.touchableGetPressRectOffset() : null;
	    var pressExpandLeft = pressRectOffset.left != null ? pressRectOffset.left : PRESS_EXPAND_PX;
	    var pressExpandTop = pressRectOffset.top != null ? pressRectOffset.top : PRESS_EXPAND_PX;
	    var pressExpandRight = pressRectOffset.right != null ? pressRectOffset.right : PRESS_EXPAND_PX;
	    var pressExpandBottom = pressRectOffset.bottom != null ? pressRectOffset.bottom : PRESS_EXPAND_PX;
	
	    var touch = _TouchEventUtils2['default'].extractSingleTouch(e.nativeEvent);
	    var pageX = touch && touch.pageX;
	    var pageY = touch && touch.pageY;
	
	    if (this.pressInLocation) {
	      var movedDistance = this._getDistanceBetweenPoints(pageX, pageY, this.pressInLocation.pageX, this.pressInLocation.pageY);
	      if (movedDistance > LONG_PRESS_ALLOWED_MOVEMENT) {
	        this._cancelLongPressDelayTimeout();
	      }
	    }
	
	    var isTouchWithinActive = pageX > positionOnActivate.left - pressExpandLeft && pageY > positionOnActivate.top - pressExpandTop && pageX < positionOnActivate.left + dimensionsOnActivate.width + pressExpandRight && pageY < positionOnActivate.top + dimensionsOnActivate.height + pressExpandBottom;
	    if (isTouchWithinActive) {
	      this._receiveSignal(Signals.ENTER_PRESS_RECT, e);
	    } else {
	      this._cancelLongPressDelayTimeout();
	      this._receiveSignal(Signals.LEAVE_PRESS_RECT, e);
	    }
	  },
	
	  // ==== Abstract Application Callbacks ====
	
	  /**
	   * Invoked when the item should be highlighted. Mixers should implement this
	   * to visually distinguish the `VisualRect` so that the user knows that
	   * releasing a touch will result in a "selection" (analog to click).
	   *
	   * @abstract
	   * touchableHandleActivePressIn: function,
	   */
	
	  /**
	   * Invoked when the item is "active" (in that it is still eligible to become
	   * a "select") but the touch has left the `PressRect`. Usually the mixer will
	   * want to unhighlight the `VisualRect`. If the user (while pressing) moves
	   * back into the `PressRect` `touchableHandleActivePressIn` will be invoked
	   * again and the mixer should probably highlight the `VisualRect` again. This
	   * event will not fire on an `touchEnd/mouseUp` event, only move events while
	   * the user is depressing the mouse/touch.
	   *
	   * @abstract
	   * touchableHandleActivePressOut: function
	   */
	
	  /**
	   * Invoked when the item is "selected" - meaning the interaction ended by
	   * letting up while the item was either in the state
	   * `RESPONDER_ACTIVE_PRESS_IN` or `RESPONDER_INACTIVE_PRESS_IN`.
	   *
	   * @abstract
	   * touchableHandlePress: function
	   */
	
	  /**
	   * Invoked when the item is long pressed - meaning the interaction ended by
	   * letting up while the item was in `RESPONDER_ACTIVE_LONG_PRESS_IN`. If
	   * `touchableHandleLongPress` is *not* provided, `touchableHandlePress` will
	   * be called as it normally is. If `touchableHandleLongPress` is provided, by
	   * default any `touchableHandlePress` callback will not be invoked. To
	   * override this default behavior, override `touchableLongPressCancelsPress`
	   * to return false. As a result, `touchableHandlePress` will be called when
	   * lifting up, even if `touchableHandleLongPress` has also been called.
	   *
	   * @abstract
	   * touchableHandleLongPress: function
	   */
	
	  /**
	   * Returns the number of millis to wait before triggering a highlight.
	   *
	   * @abstract
	   * touchableGetHighlightDelayMS: function
	   */
	
	  /**
	   * Returns the amount to extend the `HitRect` into the `PressRect`. Positive
	   * numbers mean the size expands outwards.
	   *
	   * @abstract
	   * touchableGetPressRectOffset: function
	   */
	
	  // ==== Internal Logic ====
	
	  /**
	   * Measures the `HitRect` node on activation. The Bounding rectangle is with
	   * respect to viewport - not page, so adding the `pageXOffset/pageYOffset`
	   * should result in points that are in the same coordinate system as an
	   * event's `globalX/globalY` data values.
	   *
	   * - Consider caching this for the lifetime of the component, or possibly
	   *   being able to share this cache between any `ScrollMap` view.
	   *
	   * @sideeffects
	   * @private
	   */
	  _remeasureMetricsOnActivation: function _remeasureMetricsOnActivation(e) {
	    // queryLayoutByID(
	    //   this.state.touchable.responderID,
	    //   null,
	    //   this._handleQueryLayout
	    // );
	    var target = e.nativeEvent.target;
	    this._handleQueryLayout(target.clientLeft, target.clientTop, target.clientWidth, target.clientHeight, target.offsetLeft, target.offsetTop);
	  },
	
	  _handleQueryLayout: function _handleQueryLayout(l, t, w, h, globalX, globalY) {
	    if (this.state.touchable.positionOnActivate) {
	      this.state.touchable.positionOnActivate = null;
	    }
	
	    if (this.state.touchable.dimensionsOnActivate) {
	      this.state.touchable.dimensionsOnActivate = null;
	    }
	
	    this.state.touchable.positionOnActivate = {
	      left: globalX,
	      top: globalY
	    };
	    this.state.touchable.dimensionsOnActivate = {
	      width: w,
	      height: h
	    };
	  },
	
	  _handleDelay: function _handleDelay(e) {
	    this.touchableDelayTimeout = null;
	    this._receiveSignal(Signals.DELAY, e);
	  },
	
	  _handleLongDelay: function _handleLongDelay(e) {
	    this.longPressDelayTimeout = null;
	    this._receiveSignal(Signals.LONG_PRESS_DETECTED, e);
	  },
	
	  /**
	   * Receives a state machine signal, performs side effects of the transition
	   * and stores the new state. Validates the transition as well.
	   *
	   * @param {Signals} signal State machine signal.
	   * @throws Error if invalid state transition or unrecognized signal.
	   * @sideeffects
	   */
	  _receiveSignal: function _receiveSignal(signal, e) {
	    var curState = this.state.touchable.touchState;
	    if (!(Transitions[curState] && Transitions[curState][signal])) {
	      throw new Error('Unrecognized signal `' + signal + '` or state `' + curState + '` for Touchable responder `' + this.state.touchable.responderID + '`');
	    }
	    var nextState = Transitions[curState][signal];
	    if (nextState === States.ERROR) {
	      throw new Error('Touchable cannot transition from `' + curState + '` to `' + signal + '` for responder `' + this.state.touchable.responderID + '`');
	    }
	    if (curState !== nextState) {
	      this._performSideEffectsForTransition(curState, nextState, signal, e);
	      this.state.touchable.touchState = nextState;
	    }
	  },
	
	  _cancelLongPressDelayTimeout: function _cancelLongPressDelayTimeout() {
	    this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);
	    this.longPressDelayTimeout = null;
	  },
	
	  _isHighlight: function _isHighlight(state) {
	    return state === States.RESPONDER_ACTIVE_PRESS_IN || state === States.RESPONDER_ACTIVE_LONG_PRESS_IN;
	  },
	
	  _savePressInLocation: function _savePressInLocation(e) {
	    var touch = _TouchEventUtils2['default'].extractSingleTouch(e.nativeEvent);
	    var pageX = touch && touch.pageX;
	    var pageY = touch && touch.pageY;
	    this.pressInLocation = {
	      pageX: pageX,
	      pageY: pageY
	    };
	  },
	
	  _getDistanceBetweenPoints: function _getDistanceBetweenPoints(aX, aY, bX, bY) {
	    var deltaX = aX - bX;
	    var deltaY = aY - bY;
	    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
	  },
	
	  /**
	   * Will perform a transition between touchable states, and identify any
	   * highlighting or unhighlighting that must be performed for this particular
	   * transition.
	   *
	   * @param {States} curState Current Touchable state.
	   * @param {States} nextState Next Touchable state.
	   * @param {Signal} signal Signal that triggered the transition.
	   * @param {Event} e Native event.
	   * @sideeffects
	   */
	  _performSideEffectsForTransition: function _performSideEffectsForTransition(curState, nextState, signal, e) {
	    var curIsHighlight = this._isHighlight(curState);
	    var newIsHighlight = this._isHighlight(nextState);
	
	    var isFinalSignal = signal === Signals.RESPONDER_TERMINATED || signal === Signals.RESPONDER_RELEASE;
	
	    if (isFinalSignal) {
	      this._cancelLongPressDelayTimeout();
	    }
	
	    if (!IsActive[curState] && IsActive[nextState]) {
	      this._remeasureMetricsOnActivation(e);
	    }
	
	    if (IsPressingIn[curState] && signal === Signals.LONG_PRESS_DETECTED) {
	      this.touchableHandleLongPress && this.touchableHandleLongPress(e);
	    }
	
	    if (newIsHighlight && !curIsHighlight) {
	      this._savePressInLocation(e);
	      this.touchableHandleActivePressIn && this.touchableHandleActivePressIn(e);
	    } else if (!newIsHighlight && curIsHighlight && this.touchableHandleActivePressOut) {
	      if (this.touchableGetPressOutDelayMS && this.touchableGetPressOutDelayMS()) {
	        this.pressOutDelayTimeout = this.setTimeout(function () {
	          this.touchableHandleActivePressOut(e);
	        }, this.touchableGetPressOutDelayMS());
	      } else {
	        this.touchableHandleActivePressOut(e);
	      }
	    }
	
	    if (IsPressingIn[curState] && signal === Signals.RESPONDER_RELEASE) {
	      var hasLongPressHandler = !!this.props.onLongPress;
	      var pressIsLongButStillCallOnPress = IsLongPressingIn[curState] && ( // We *are* long pressing..
	      !hasLongPressHandler || // But either has no long handler
	      !this.touchableLongPressCancelsPress()) // or we're told to ignore it.
	      ;
	
	      var shouldInvokePress = !IsLongPressingIn[curState] || pressIsLongButStillCallOnPress;
	      if (shouldInvokePress && this.touchableHandlePress) {
	        this.touchableHandlePress(e);
	      }
	    }
	
	    this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);
	    this.touchableDelayTimeout = null;
	  }
	
	};
	
	var Touchable = {
	  Mixin: TouchableMixin
	};
	
	module.exports = Touchable;

/***/ },
/* 238 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule TouchEventUtils
	 */
	
	'use strict';
	
	var TouchEventUtils = {
	  /**
	   * Utility function for common case of extracting out the primary touch from a
	   * touch event.
	   * - `touchEnd` events usually do not have the `touches` property.
	   *   http://stackoverflow.com/questions/3666929/
	   *   mobile-sarai-touchend-event-not-firing-when-last-touch-is-removed
	   *
	   * @param {Event} nativeEvent Native event that may or may not be a touch.
	   * @return {TouchesObject?} an object with pageX and pageY or null.
	   */
	  extractSingleTouch: function extractSingleTouch(nativeEvent) {
	    var touches = nativeEvent.touches;
	    var changedTouches = nativeEvent.changedTouches;
	    var hasTouches = touches && touches.length > 0;
	    var hasChangedTouches = changedTouches && changedTouches.length > 0;
	
	    return !hasTouches && hasChangedTouches ? changedTouches[0] : hasTouches ? touches[0] : nativeEvent;
	  }
	};
	
	module.exports = TouchEventUtils;

/***/ },
/* 239 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule keyMirror
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Constructs an enumeration with keys equal to their value.
	 *
	 * For example:
	 *
	 *   var COLORS = keyMirror({blue: null, red: null});
	 *   var myColor = COLORS.blue;
	 *   var isColorValid = !!COLORS[myColor];
	 *
	 * The last line could not be performed if the values of the generated enum were
	 * not equal to their keys.
	 *
	 *   Input:  {key1: val1, key2: val2}
	 *   Output: {key1: key1, key2: key2}
	 *
	 * @param {object} obj
	 * @return {object}
	 */
	var keyMirror = function keyMirror(obj) {
	  var ret = {};
	  var key;
	
	  for (key in obj) {
	    if (!obj.hasOwnProperty(key)) {
	      continue;
	    }
	    ret[key] = key;
	  }
	  return ret;
	};
	
	module.exports = keyMirror;

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015, Facebook, Inc.  All rights reserved.
	 *
	 * @providesModule ReactPanResponder
	 */
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	__webpack_require__(241);
	
	var _TouchHistoryMath = __webpack_require__(246);
	
	var _TouchHistoryMath2 = _interopRequireDefault(_TouchHistoryMath);
	
	var currentCentroidXOfTouchesChangedAfter = _TouchHistoryMath2['default'].currentCentroidXOfTouchesChangedAfter;
	var currentCentroidYOfTouchesChangedAfter = _TouchHistoryMath2['default'].currentCentroidYOfTouchesChangedAfter;
	var previousCentroidXOfTouchesChangedAfter = _TouchHistoryMath2['default'].previousCentroidXOfTouchesChangedAfter;
	var previousCentroidYOfTouchesChangedAfter = _TouchHistoryMath2['default'].previousCentroidYOfTouchesChangedAfter;
	var currentCentroidX = _TouchHistoryMath2['default'].currentCentroidX;
	var currentCentroidY = _TouchHistoryMath2['default'].currentCentroidY;
	
	/**
	 * `PanResponder` reconciles several touches into a single gesture. It makes
	 * single-touch gestures resilient to extra touches, and can be used to
	 * recognize simple multi-touch gestures.
	 *
	 * It provides a predictable wrapper of the responder handlers provided by the
	 * [gesture responder system](/react-native/docs/gesture-responder-system.html).
	 * For each handler, it provides a new `gestureState` object alongside the
	 * normal event.
	 *
	 * A `gestureState` object has the following:
	 *
	 *  - `stateID` - ID of the gestureState- persisted as long as there at least
	 *     one touch on screen
	 *  - `moveX` - the latest screen coordinates of the recently-moved touch
	 *  - `moveY` - the latest screen coordinates of the recently-moved touch
	 *  - `x0` - the screen coordinates of the responder grant
	 *  - `y0` - the screen coordinates of the responder grant
	 *  - `dx` - accumulated distance of the gesture since the touch started
	 *  - `dy` - accumulated distance of the gesture since the touch started
	 *  - `vx` - current velocity of the gesture
	 *  - `vy` - current velocity of the gesture
	 *  - `numberActiveTouches` - Number of touches currently on screeen
	 *
	 * ### Basic Usage
	 *
	 * ```
	 *   componentWillMount: function() {
	 *     this._panResponder = PanResponder.create({
	 *       // Ask to be the responder:
	 *       onStartShouldSetPanResponder: (evt, gestureState) => true,
	 *       onStartShouldSetPanResponderCapture: (evt, gestureState) => true,
	 *       onMoveShouldSetPanResponder: (evt, gestureState) => true,
	 *       onMoveShouldSetPanResponderCapture: (evt, gestureState) => true,
	 *
	 *       onPanResponderGrant: (evt, gestureState) => {
	 *         // The guesture has started. Show visual feedback so the user knows
	 *         // what is happening!
	 *
	 *         // gestureState.{x,y}0 will be set to zero now
	 *       },
	 *       onPanResponderMove: (evt, gestureState) => {
	 *         // The most recent move distance is gestureState.move{X,Y}
	 *
	 *         // The accumulated gesture distance since becoming responder is
	 *         // gestureState.d{x,y}
	 *       },
	 *       onPanResponderTerminationRequest: (evt, gestureState) => true,
	 *       onPanResponderRelease: (evt, gestureState) => {
	 *         // The user has released all touches while this view is the
	 *         // responder. This typically means a gesture has succeeded
	 *       },
	 *       onPanResponderTerminate: (evt, gestureState) => {
	 *         // Another component has become the responder, so this gesture
	 *         // should be cancelled
	 *       },
	 *       onShouldBlockNativeResponder: (evt, gestureState) => {
	 *         // Returns whether this component should block native components from becoming the JS
	 *         // responder. Returns true by default. Is currently only supported on android.
	 *         return true;
	 *       },
	 *     });
	 *   },
	 *
	 *   render: function() {
	 *     return (
	 *       <View {...this._panResponder.panHandlers} />
	 *     );
	 *   },
	 *
	 * ```
	 *
	 * ### Working Example
	 *
	 * To see it in action, try the
	 * [PanResponder example in UIExplorer](https://github.com/facebook/react-native/blob/master/Examples/UIExplorer/ResponderExample.js)
	 */
	
	var PanResponder = {
	
	  /**
	   *
	   * A graphical explanation of the touch data flow:
	   *
	   * +----------------------------+             +--------------------------------+
	   * | ResponderTouchHistoryStore |             |TouchHistoryMath                |
	   * +----------------------------+             +----------+---------------------+
	   * |Global store of touchHistory|             |Allocation-less math util       |
	   * |including activeness, start |             |on touch history (centroids     |
	   * |position, prev/cur position.|             |and multitouch movement etc)    |
	   * |                            |             |                                |
	   * +----^-----------------------+             +----^---------------------------+
	   *      |                                          |
	   *      | (records relevant history                |
	   *      |  of touches relevant for                 |
	   *      |  implementing higher level               |
	   *      |  gestures)                               |
	   *      |                                          |
	   * +----+-----------------------+             +----|---------------------------+
	   * | ResponderEventPlugin       |             |    |   Your App/Component      |
	   * +----------------------------+             +----|---------------------------+
	   * |Negotiates which view gets  | Low level   |    |             High level    |
	   * |onResponderMove events.     | events w/   |  +-+-------+     events w/     |
	   * |Also records history into   | touchHistory|  |   Pan   |     multitouch +  |
	   * |ResponderTouchHistoryStore. +---------------->Responder+-----> accumulative|
	   * +----------------------------+ attached to |  |         |     distance and  |
	   *                                 each event |  +---------+     velocity.     |
	   *                                            |                                |
	   *                                            |                                |
	   *                                            +--------------------------------+
	   *
	   *
	   *
	   * Gesture that calculates cumulative movement over time in a way that just
	   * "does the right thing" for multiple touches. The "right thing" is very
	   * nuanced. When moving two touches in opposite directions, the cumulative
	   * distance is zero in each dimension. When two touches move in parallel five
	   * pixels in the same direction, the cumulative distance is five, not ten. If
	   * two touches start, one moves five in a direction, then stops and the other
	   * touch moves fives in the same direction, the cumulative distance is ten.
	   *
	   * This logic requires a kind of processing of time "clusters" of touch events
	   * so that two touch moves that essentially occur in parallel but move every
	   * other frame respectively, are considered part of the same movement.
	   *
	   * Explanation of some of the non-obvious fields:
	   *
	   * - moveX/moveY: If no move event has been observed, then `(moveX, moveY)` is
	   *   invalid. If a move event has been observed, `(moveX, moveY)` is the
	   *   centroid of the most recently moved "cluster" of active touches.
	   *   (Currently all move have the same timeStamp, but later we should add some
	   *   threshold for what is considered to be "moving"). If a palm is
	   *   accidentally counted as a touch, but a finger is moving greatly, the palm
	   *   will move slightly, but we only want to count the single moving touch.
	   * - x0/y0: Centroid location (non-cumulative) at the time of becoming
	   *   responder.
	   * - dx/dy: Cumulative touch distance - not the same thing as sum of each touch
	   *   distance. Accounts for touch moves that are clustered together in time,
	   *   moving the same direction. Only valid when currently responder (otherwise,
	   *   it only represents the drag distance below the threshold).
	   * - vx/vy: Velocity.
	   */
	
	  _initializeGestureState: function _initializeGestureState(gestureState) {
	    gestureState.moveX = 0;
	    gestureState.moveY = 0;
	    gestureState.x0 = 0;
	    gestureState.y0 = 0;
	    gestureState.dx = 0;
	    gestureState.dy = 0;
	    gestureState.vx = 0;
	    gestureState.vy = 0;
	    gestureState.numberActiveTouches = 0;
	    // All `gestureState` accounts for timeStamps up until:
	    gestureState._accountsForMovesUpTo = 0;
	  },
	
	  /**
	   * This is nuanced and is necessary. It is incorrect to continuously take all
	   * active *and* recently moved touches, find the centroid, and track how that
	   * result changes over time. Instead, we must take all recently moved
	   * touches, and calculate how the centroid has changed just for those
	   * recently moved touches, and append that change to an accumulator. This is
	   * to (at least) handle the case where the user is moving three fingers, and
	   * then one of the fingers stops but the other two continue.
	   *
	   * This is very different than taking all of the recently moved touches and
	   * storing their centroid as `dx/dy`. For correctness, we must *accumulate
	   * changes* in the centroid of recently moved touches.
	   *
	   * There is also some nuance with how we handle multiple moved touches in a
	   * single event. With the way `ReactNativeEventEmitter` dispatches touches as
	   * individual events, multiple touches generate two 'move' events, each of
	   * them triggering `onResponderMove`. But with the way `PanResponder` works,
	   * all of the gesture inference is performed on the first dispatch, since it
	   * looks at all of the touches (even the ones for which there hasn't been a
	   * native dispatch yet). Therefore, `PanResponder` does not call
	   * `onResponderMove` passed the first dispatch. This diverges from the
	   * typical responder callback pattern (without using `PanResponder`), but
	   * avoids more dispatches than necessary.
	   */
	  _updateGestureStateOnMove: function _updateGestureStateOnMove(gestureState, touchHistory) {
	    gestureState.numberActiveTouches = touchHistory.numberActiveTouches;
	    gestureState.moveX = currentCentroidXOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo);
	    gestureState.moveY = currentCentroidYOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo);
	    var movedAfter = gestureState._accountsForMovesUpTo;
	    var prevX = previousCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);
	    var x = currentCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);
	    var prevY = previousCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);
	    var y = currentCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);
	    var nextDX = gestureState.dx + (x - prevX);
	    var nextDY = gestureState.dy + (y - prevY);
	
	    // TODO: This must be filtered intelligently.
	    var dt = touchHistory.mostRecentTimeStamp - gestureState._accountsForMovesUpTo;
	    gestureState.vx = (nextDX - gestureState.dx) / dt;
	    gestureState.vy = (nextDY - gestureState.dy) / dt;
	
	    gestureState.dx = nextDX;
	    gestureState.dy = nextDY;
	    gestureState._accountsForMovesUpTo = touchHistory.mostRecentTimeStamp;
	  },
	
	  /**
	   * @param {object} config Enhanced versions of all of the responder callbacks
	   * that provide not only the typical `ResponderSyntheticEvent`, but also the
	   * `PanResponder` gesture state.  Simply replace the word `Responder` with
	   * `PanResponder` in each of the typical `onResponder*` callbacks. For
	   * example, the `config` object would look like:
	   *
	   *  - `onMoveShouldSetPanResponder: (e, gestureState) => {...}`
	   *  - `onMoveShouldSetPanResponderCapture: (e, gestureState) => {...}`
	   *  - `onStartShouldSetPanResponder: (e, gestureState) => {...}`
	   *  - `onStartShouldSetPanResponderCapture: (e, gestureState) => {...}`
	   *  - `onPanResponderReject: (e, gestureState) => {...}`
	   *  - `onPanResponderGrant: (e, gestureState) => {...}`
	   *  - `onPanResponderStart: (e, gestureState) => {...}`
	   *  - `onPanResponderEnd: (e, gestureState) => {...}`
	   *  - `onPanResponderRelease: (e, gestureState) => {...}`
	   *  - `onPanResponderMove: (e, gestureState) => {...}`
	   *  - `onPanResponderTerminate: (e, gestureState) => {...}`
	   *  - `onPanResponderTerminationRequest: (e, gestureState) => {...}`
	   *  - 'onShouldBlockNativeResponder: (e, gestureState) => {...}'
	   *
	   *  In general, for events that have capture equivalents, we update the
	   *  gestureState once in the capture phase and can use it in the bubble phase
	   *  as well.
	   *
	   *  Be careful with onStartShould* callbacks. They only reflect updated
	   *  `gestureState` for start/end events that bubble/capture to the Node.
	   *  Once the node is the responder, you can rely on every start/end event
	   *  being processed by the gesture and `gestureState` being updated
	   *  accordingly. (numberActiveTouches) may not be totally accurate unless you
	   *  are the responder.
	   */
	  create: function create(config) {
	    var gestureState = {
	      // Useful for debugging
	      stateID: Math.random()
	    };
	    PanResponder._initializeGestureState(gestureState);
	    var panHandlers = {
	      onStartShouldSetResponder: function onStartShouldSetResponder(e) {
	        return config.onStartShouldSetPanResponder === undefined ? false : config.onStartShouldSetPanResponder(e, gestureState);
	      },
	      onMoveShouldSetResponder: function onMoveShouldSetResponder(e) {
	        return config.onMoveShouldSetPanResponder === undefined ? false : config.onMoveShouldSetPanResponder(e, gestureState);
	      },
	      onStartShouldSetResponderCapture: function onStartShouldSetResponderCapture(e) {
	        if (!e.nativeEvent.touches) {
	          return false;
	        }
	        // TODO: Actually, we should reinitialize the state any time
	        // touches.length increases from 0 active to > 0 active.
	        if (e.nativeEvent.touches.length === 1) {
	          PanResponder._initializeGestureState(gestureState);
	        }
	        gestureState.numberActiveTouches = e.touchHistory.numberActiveTouches;
	        return config.onStartShouldSetPanResponderCapture !== undefined ? config.onStartShouldSetPanResponderCapture(e, gestureState) : false;
	      },
	
	      onMoveShouldSetResponderCapture: function onMoveShouldSetResponderCapture(e) {
	        var touchHistory = e.touchHistory;
	        // Responder system incorrectly dispatches should* to current responder
	        // Filter out any touch moves past the first one - we would have
	        // already processed multi-touch geometry during the first event.
	        if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {
	          return false;
	        }
	        PanResponder._updateGestureStateOnMove(gestureState, touchHistory);
	        return config.onMoveShouldSetPanResponderCapture ? config.onMoveShouldSetPanResponderCapture(e, gestureState) : false;
	      },
	
	      onResponderGrant: function onResponderGrant(e) {
	        gestureState.x0 = currentCentroidX(e.touchHistory);
	        gestureState.y0 = currentCentroidY(e.touchHistory);
	        gestureState.dx = 0;
	        gestureState.dy = 0;
	        config.onPanResponderGrant && config.onPanResponderGrant(e, gestureState);
	        // TODO: t7467124 investigate if this can be removed
	        return config.onShouldBlockNativeResponder === undefined ? true : config.onShouldBlockNativeResponder();
	      },
	
	      onResponderReject: function onResponderReject(e) {
	        config.onPanResponderReject && config.onPanResponderReject(e, gestureState);
	      },
	
	      onResponderRelease: function onResponderRelease(e) {
	        config.onPanResponderRelease && config.onPanResponderRelease(e, gestureState);
	        PanResponder._initializeGestureState(gestureState);
	      },
	
	      onResponderStart: function onResponderStart(e) {
	        var touchHistory = e.touchHistory;
	        gestureState.numberActiveTouches = touchHistory.numberActiveTouches;
	        config.onPanResponderStart && config.onPanResponderStart(e, gestureState);
	      },
	
	      onResponderMove: function onResponderMove(e) {
	        var touchHistory = e.touchHistory;
	        // Guard against the dispatch of two touch moves when there are two
	        // simultaneously changed touches.
	        if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {
	          return;
	        }
	        // Filter out any touch moves past the first one - we would have
	        // already processed multi-touch geometry during the first event.
	        PanResponder._updateGestureStateOnMove(gestureState, touchHistory);
	        config.onPanResponderMove && config.onPanResponderMove(e, gestureState);
	      },
	
	      onResponderEnd: function onResponderEnd(e) {
	        var touchHistory = e.touchHistory;
	        gestureState.numberActiveTouches = touchHistory.numberActiveTouches;
	        config.onPanResponderEnd && config.onPanResponderEnd(e, gestureState);
	      },
	
	      onResponderTerminate: function onResponderTerminate(e) {
	        config.onPanResponderTerminate && config.onPanResponderTerminate(e, gestureState);
	        PanResponder._initializeGestureState(gestureState);
	      },
	
	      onResponderTerminationRequest: function onResponderTerminationRequest(e) {
	        return config.onPanResponderTerminationRequest === undefined ? true : config.onPanResponderTerminationRequest(e, gestureState);
	      }
	    };
	    return { panHandlers: panHandlers };
	  }
	};
	
	module.exports = PanResponder;

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 */
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _reactLibEventPluginRegistry = __webpack_require__(32);
	
	var _reactLibEventPluginRegistry2 = _interopRequireDefault(_reactLibEventPluginRegistry);
	
	var _reactLibResponderEventPlugin = __webpack_require__(242);
	
	var _reactLibResponderEventPlugin2 = _interopRequireDefault(_reactLibResponderEventPlugin);
	
	var _reactLibEventConstants = __webpack_require__(30);
	
	var _reactLibEventConstants2 = _interopRequireDefault(_reactLibEventConstants);
	
	var _reactLibResponderTouchHistoryStore = __webpack_require__(244);
	
	var _reactLibResponderTouchHistoryStore2 = _interopRequireDefault(_reactLibResponderTouchHistoryStore);
	
	var topLevelTypes = _reactLibEventConstants2['default'].topLevelTypes;
	var dependencies;
	
	if ('ontouchstart' in window) {
	  dependencies = [topLevelTypes.topTouchStart, topLevelTypes.topTouchCancel, topLevelTypes.topTouchEnd, topLevelTypes.topTouchMove];
	} else {
	  // TODO: support move event
	  dependencies = [topLevelTypes.topMouseDown, topLevelTypes.topMouseUp];
	}
	
	for (var eventType in _reactLibResponderEventPlugin2['default'].eventTypes) {
	  _reactLibResponderEventPlugin2['default'].eventTypes[eventType].dependencies = dependencies;
	}
	
	function toArray(collection) {
	  return collection && Array.prototype.slice.call(collection);
	}
	
	var argumentTimestamp = function argumentTimestamp(timestamp, touch) {
	  touch.timestamp = timestamp;
	};
	
	var originRecordTouchTrack = _reactLibResponderTouchHistoryStore2['default'].recordTouchTrack;
	_reactLibResponderTouchHistoryStore2['default'].recordTouchTrack = function (topLevelType, nativeEvent) {
	  var timestamp = nativeEvent.timestamp || nativeEvent.timeStamp;
	
	  if (nativeEvent.changedTouches) {
	    var changedTouches = toArray(nativeEvent.changedTouches);
	    changedTouches.forEach(argumentTimestamp.bind(null, timestamp));
	  }
	
	  originRecordTouchTrack.call(_reactLibResponderTouchHistoryStore2['default'], topLevelType, {
	    changedTouches: changedTouches || [],
	    touches: toArray(nativeEvent.touches) || []
	  });
	};
	
	_reactLibEventPluginRegistry2['default'].injectEventPluginsByName({
	  ResponderEventPlugin: _reactLibResponderEventPlugin2['default']
	});

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ResponderEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(30);
	var EventPluginUtils = __webpack_require__(33);
	var EventPropagators = __webpack_require__(73);
	var ReactInstanceHandles = __webpack_require__(45);
	var ResponderSyntheticEvent = __webpack_require__(243);
	var ResponderTouchHistoryStore = __webpack_require__(244);
	
	var accumulate = __webpack_require__(245);
	var invariant = __webpack_require__(13);
	var keyOf = __webpack_require__(79);
	
	var isStartish = EventPluginUtils.isStartish;
	var isMoveish = EventPluginUtils.isMoveish;
	var isEndish = EventPluginUtils.isEndish;
	var executeDirectDispatch = EventPluginUtils.executeDirectDispatch;
	var hasDispatches = EventPluginUtils.hasDispatches;
	var executeDispatchesInOrderStopAtTrue = EventPluginUtils.executeDispatchesInOrderStopAtTrue;
	
	/**
	 * ID of element that should respond to touch/move types of interactions, as
	 * indicated explicitly by relevant callbacks.
	 */
	var responderID = null;
	
	/**
	 * Count of current touches. A textInput should become responder iff the
	 * the selection changes while there is a touch on the screen.
	 */
	var trackedTouchCount = 0;
	
	/**
	 * Last reported number of active touches.
	 */
	var previousActiveTouches = 0;
	
	var changeResponder = function (nextResponderID, blockNativeResponder) {
	  var oldResponderID = responderID;
	  responderID = nextResponderID;
	  if (ResponderEventPlugin.GlobalResponderHandler !== null) {
	    ResponderEventPlugin.GlobalResponderHandler.onChange(oldResponderID, nextResponderID, blockNativeResponder);
	  }
	};
	
	var eventTypes = {
	  /**
	   * On a `touchStart`/`mouseDown`, is it desired that this element become the
	   * responder?
	   */
	  startShouldSetResponder: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onStartShouldSetResponder: null }),
	      captured: keyOf({ onStartShouldSetResponderCapture: null })
	    }
	  },
	
	  /**
	   * On a `scroll`, is it desired that this element become the responder? This
	   * is usually not needed, but should be used to retroactively infer that a
	   * `touchStart` had occured during momentum scroll. During a momentum scroll,
	   * a touch start will be immediately followed by a scroll event if the view is
	   * currently scrolling.
	   *
	   * TODO: This shouldn't bubble.
	   */
	  scrollShouldSetResponder: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onScrollShouldSetResponder: null }),
	      captured: keyOf({ onScrollShouldSetResponderCapture: null })
	    }
	  },
	
	  /**
	   * On text selection change, should this element become the responder? This
	   * is needed for text inputs or other views with native selection, so the
	   * JS view can claim the responder.
	   *
	   * TODO: This shouldn't bubble.
	   */
	  selectionChangeShouldSetResponder: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSelectionChangeShouldSetResponder: null }),
	      captured: keyOf({ onSelectionChangeShouldSetResponderCapture: null })
	    }
	  },
	
	  /**
	   * On a `touchMove`/`mouseMove`, is it desired that this element become the
	   * responder?
	   */
	  moveShouldSetResponder: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMoveShouldSetResponder: null }),
	      captured: keyOf({ onMoveShouldSetResponderCapture: null })
	    }
	  },
	
	  /**
	   * Direct responder events dispatched directly to responder. Do not bubble.
	   */
	  responderStart: { registrationName: keyOf({ onResponderStart: null }) },
	  responderMove: { registrationName: keyOf({ onResponderMove: null }) },
	  responderEnd: { registrationName: keyOf({ onResponderEnd: null }) },
	  responderRelease: { registrationName: keyOf({ onResponderRelease: null }) },
	  responderTerminationRequest: {
	    registrationName: keyOf({ onResponderTerminationRequest: null })
	  },
	  responderGrant: { registrationName: keyOf({ onResponderGrant: null }) },
	  responderReject: { registrationName: keyOf({ onResponderReject: null }) },
	  responderTerminate: { registrationName: keyOf({ onResponderTerminate: null }) }
	};
	
	/**
	 *
	 * Responder System:
	 * ----------------
	 *
	 * - A global, solitary "interaction lock" on a view.
	 * - If a node becomes the responder, it should convey visual feedback
	 *   immediately to indicate so, either by highlighting or moving accordingly.
	 * - To be the responder means, that touches are exclusively important to that
	 *   responder view, and no other view.
	 * - While touches are still occuring, the responder lock can be transfered to
	 *   a new view, but only to increasingly "higher" views (meaning ancestors of
	 *   the current responder).
	 *
	 * Responder being granted:
	 * ------------------------
	 *
	 * - Touch starts, moves, and scrolls can cause an ID to become the responder.
	 * - We capture/bubble `startShouldSetResponder`/`moveShouldSetResponder` to
	 *   the "appropriate place".
	 * - If nothing is currently the responder, the "appropriate place" is the
	 *   initiating event's `targetID`.
	 * - If something *is* already the responder, the "appropriate place" is the
	 *   first common ancestor of the event target and the current `responderID`.
	 * - Some negotiation happens: See the timing diagram below.
	 * - Scrolled views automatically become responder. The reasoning is that a
	 *   platform scroll view that isn't built on top of the responder system has
	 *   began scrolling, and the active responder must now be notified that the
	 *   interaction is no longer locked to it - the system has taken over.
	 *
	 * - Responder being released:
	 *   As soon as no more touches that *started* inside of descendents of the
	 *   *current* responderID, an `onResponderRelease` event is dispatched to the
	 *   current responder, and the responder lock is released.
	 *
	 * TODO:
	 * - on "end", a callback hook for `onResponderEndShouldRemainResponder` that
	 *   determines if the responder lock should remain.
	 * - If a view shouldn't "remain" the responder, any active touches should by
	 *   default be considered "dead" and do not influence future negotiations or
	 *   bubble paths. It should be as if those touches do not exist.
	 * -- For multitouch: Usually a translate-z will choose to "remain" responder
	 *  after one out of many touches ended. For translate-y, usually the view
	 *  doesn't wish to "remain" responder after one of many touches end.
	 * - Consider building this on top of a `stopPropagation` model similar to
	 *   `W3C` events.
	 * - Ensure that `onResponderTerminate` is called on touch cancels, whether or
	 *   not `onResponderTerminationRequest` returns `true` or `false`.
	 *
	 */
	
	/*                                             Negotiation Performed
	                                             +-----------------------+
	                                            /                         \
	Process low level events to    +     Current Responder      +   wantsResponderID
	determine who to perform negot-|   (if any exists at all)   |
	iation/transition              | Otherwise just pass through|
	-------------------------------+----------------------------+------------------+
	Bubble to find first ID        |                            |
	to return true:wantsResponderID|                            |
	                               |                            |
	     +-------------+           |                            |
	     | onTouchStart|           |                            |
	     +------+------+     none  |                            |
	            |            return|                            |
	+-----------v-------------+true| +------------------------+ |
	|onStartShouldSetResponder|----->|onResponderStart (cur)  |<-----------+
	+-----------+-------------+    | +------------------------+ |          |
	            |                  |                            | +--------+-------+
	            | returned true for|       false:REJECT +-------->|onResponderReject
	            | wantsResponderID |                    |       | +----------------+
	            | (now attempt     | +------------------+-----+ |
	            |  handoff)        | |   onResponder          | |
	            +------------------->|      TerminationRequest| |
	                               | +------------------+-----+ |
	                               |                    |       | +----------------+
	                               |         true:GRANT +-------->|onResponderGrant|
	                               |                            | +--------+-------+
	                               | +------------------------+ |          |
	                               | |   onResponderTerminate |<-----------+
	                               | +------------------+-----+ |
	                               |                    |       | +----------------+
	                               |                    +-------->|onResponderStart|
	                               |                            | +----------------+
	Bubble to find first ID        |                            |
	to return true:wantsResponderID|                            |
	                               |                            |
	     +-------------+           |                            |
	     | onTouchMove |           |                            |
	     +------+------+     none  |                            |
	            |            return|                            |
	+-----------v-------------+true| +------------------------+ |
	|onMoveShouldSetResponder |----->|onResponderMove (cur)   |<-----------+
	+-----------+-------------+    | +------------------------+ |          |
	            |                  |                            | +--------+-------+
	            | returned true for|       false:REJECT +-------->|onResponderRejec|
	            | wantsResponderID |                    |       | +----------------+
	            | (now attempt     | +------------------+-----+ |
	            |  handoff)        | |   onResponder          | |
	            +------------------->|      TerminationRequest| |
	                               | +------------------+-----+ |
	                               |                    |       | +----------------+
	                               |         true:GRANT +-------->|onResponderGrant|
	                               |                            | +--------+-------+
	                               | +------------------------+ |          |
	                               | |   onResponderTerminate |<-----------+
	                               | +------------------+-----+ |
	                               |                    |       | +----------------+
	                               |                    +-------->|onResponderMove |
	                               |                            | +----------------+
	                               |                            |
	                               |                            |
	      Some active touch started|                            |
	      inside current responder | +------------------------+ |
	      +------------------------->|      onResponderEnd    | |
	      |                        | +------------------------+ |
	  +---+---------+              |                            |
	  | onTouchEnd  |              |                            |
	  +---+---------+              |                            |
	      |                        | +------------------------+ |
	      +------------------------->|     onResponderEnd     | |
	      No active touches started| +-----------+------------+ |
	      inside current responder |             |              |
	                               |             v              |
	                               | +------------------------+ |
	                               | |    onResponderRelease  | |
	                               | +------------------------+ |
	                               |                            |
	                               +                            + */
	
	/**
	 * A note about event ordering in the `EventPluginHub`.
	 *
	 * Suppose plugins are injected in the following order:
	 *
	 * `[R, S, C]`
	 *
	 * To help illustrate the example, assume `S` is `SimpleEventPlugin` (for
	 * `onClick` etc) and `R` is `ResponderEventPlugin`.
	 *
	 * "Deferred-Dispatched Events":
	 *
	 * - The current event plugin system will traverse the list of injected plugins,
	 *   in order, and extract events by collecting the plugin's return value of
	 *   `extractEvents()`.
	 * - These events that are returned from `extractEvents` are "deferred
	 *   dispatched events".
	 * - When returned from `extractEvents`, deferred-dispatched events contain an
	 *   "accumulation" of deferred dispatches.
	 * - These deferred dispatches are accumulated/collected before they are
	 *   returned, but processed at a later time by the `EventPluginHub` (hence the
	 *   name deferred).
	 *
	 * In the process of returning their deferred-dispatched events, event plugins
	 * themselves can dispatch events on-demand without returning them from
	 * `extractEvents`. Plugins might want to do this, so that they can use event
	 * dispatching as a tool that helps them decide which events should be extracted
	 * in the first place.
	 *
	 * "On-Demand-Dispatched Events":
	 *
	 * - On-demand-dispatched events are not returned from `extractEvents`.
	 * - On-demand-dispatched events are dispatched during the process of returning
	 *   the deferred-dispatched events.
	 * - They should not have side effects.
	 * - They should be avoided, and/or eventually be replaced with another
	 *   abstraction that allows event plugins to perform multiple "rounds" of event
	 *   extraction.
	 *
	 * Therefore, the sequence of event dispatches becomes:
	 *
	 * - `R`s on-demand events (if any)   (dispatched by `R` on-demand)
	 * - `S`s on-demand events (if any)   (dispatched by `S` on-demand)
	 * - `C`s on-demand events (if any)   (dispatched by `C` on-demand)
	 * - `R`s extracted events (if any)   (dispatched by `EventPluginHub`)
	 * - `S`s extracted events (if any)   (dispatched by `EventPluginHub`)
	 * - `C`s extracted events (if any)   (dispatched by `EventPluginHub`)
	 *
	 * In the case of `ResponderEventPlugin`: If the `startShouldSetResponder`
	 * on-demand dispatch returns `true` (and some other details are satisfied) the
	 * `onResponderGrant` deferred dispatched event is returned from
	 * `extractEvents`. The sequence of dispatch executions in this case
	 * will appear as follows:
	 *
	 * - `startShouldSetResponder` (`ResponderEventPlugin` dispatches on-demand)
	 * - `touchStartCapture`       (`EventPluginHub` dispatches as usual)
	 * - `touchStart`              (`EventPluginHub` dispatches as usual)
	 * - `responderGrant/Reject`   (`EventPluginHub` dispatches as usual)
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {string} topLevelTargetID ID of deepest React rendered element.
	 * @param {object} nativeEvent Native browser event.
	 * @return {*} An accumulation of synthetic events.
	 */
	function setResponderAndExtractTransfer(topLevelType, topLevelTargetID, nativeEvent, nativeEventTarget) {
	  var shouldSetEventType = isStartish(topLevelType) ? eventTypes.startShouldSetResponder : isMoveish(topLevelType) ? eventTypes.moveShouldSetResponder : topLevelType === EventConstants.topLevelTypes.topSelectionChange ? eventTypes.selectionChangeShouldSetResponder : eventTypes.scrollShouldSetResponder;
	
	  // TODO: stop one short of the the current responder.
	  var bubbleShouldSetFrom = !responderID ? topLevelTargetID : ReactInstanceHandles.getFirstCommonAncestorID(responderID, topLevelTargetID);
	
	  // When capturing/bubbling the "shouldSet" event, we want to skip the target
	  // (deepest ID) if it happens to be the current responder. The reasoning:
	  // It's strange to get an `onMoveShouldSetResponder` when you're *already*
	  // the responder.
	  var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderID;
	  var shouldSetEvent = ResponderSyntheticEvent.getPooled(shouldSetEventType, bubbleShouldSetFrom, nativeEvent, nativeEventTarget);
	  shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
	  if (skipOverBubbleShouldSetFrom) {
	    EventPropagators.accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);
	  } else {
	    EventPropagators.accumulateTwoPhaseDispatches(shouldSetEvent);
	  }
	  var wantsResponderID = executeDispatchesInOrderStopAtTrue(shouldSetEvent);
	  if (!shouldSetEvent.isPersistent()) {
	    shouldSetEvent.constructor.release(shouldSetEvent);
	  }
	
	  if (!wantsResponderID || wantsResponderID === responderID) {
	    return null;
	  }
	  var extracted;
	  var grantEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderGrant, wantsResponderID, nativeEvent, nativeEventTarget);
	  grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
	
	  EventPropagators.accumulateDirectDispatches(grantEvent);
	  var blockNativeResponder = executeDirectDispatch(grantEvent) === true;
	  if (responderID) {
	
	    var terminationRequestEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminationRequest, responderID, nativeEvent, nativeEventTarget);
	    terminationRequestEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
	    EventPropagators.accumulateDirectDispatches(terminationRequestEvent);
	    var shouldSwitch = !hasDispatches(terminationRequestEvent) || executeDirectDispatch(terminationRequestEvent);
	    if (!terminationRequestEvent.isPersistent()) {
	      terminationRequestEvent.constructor.release(terminationRequestEvent);
	    }
	
	    if (shouldSwitch) {
	      var terminateType = eventTypes.responderTerminate;
	      var terminateEvent = ResponderSyntheticEvent.getPooled(terminateType, responderID, nativeEvent, nativeEventTarget);
	      terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
	      EventPropagators.accumulateDirectDispatches(terminateEvent);
	      extracted = accumulate(extracted, [grantEvent, terminateEvent]);
	      changeResponder(wantsResponderID, blockNativeResponder);
	    } else {
	      var rejectEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderReject, wantsResponderID, nativeEvent, nativeEventTarget);
	      rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
	      EventPropagators.accumulateDirectDispatches(rejectEvent);
	      extracted = accumulate(extracted, rejectEvent);
	    }
	  } else {
	    extracted = accumulate(extracted, grantEvent);
	    changeResponder(wantsResponderID, blockNativeResponder);
	  }
	  return extracted;
	}
	
	/**
	 * A transfer is a negotiation between a currently set responder and the next
	 * element to claim responder status. Any start event could trigger a transfer
	 * of responderID. Any move event could trigger a transfer.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @return {boolean} True if a transfer of responder could possibly occur.
	 */
	function canTriggerTransfer(topLevelType, topLevelTargetID, nativeEvent) {
	  return topLevelTargetID && (
	  // responderIgnoreScroll: We are trying to migrate away from specifically tracking native scroll
	  // events here and responderIgnoreScroll indicates we will send topTouchCancel to handle
	  // canceling touch events instead
	  topLevelType === EventConstants.topLevelTypes.topScroll && !nativeEvent.responderIgnoreScroll || trackedTouchCount > 0 && topLevelType === EventConstants.topLevelTypes.topSelectionChange || isStartish(topLevelType) || isMoveish(topLevelType));
	}
	
	/**
	 * Returns whether or not this touch end event makes it such that there are no
	 * longer any touches that started inside of the current `responderID`.
	 *
	 * @param {NativeEvent} nativeEvent Native touch end event.
	 * @return {boolean} Whether or not this touch end event ends the responder.
	 */
	function noResponderTouches(nativeEvent) {
	  var touches = nativeEvent.touches;
	  if (!touches || touches.length === 0) {
	    return true;
	  }
	  for (var i = 0; i < touches.length; i++) {
	    var activeTouch = touches[i];
	    var target = activeTouch.target;
	    if (target !== null && target !== undefined && target !== 0) {
	      // Is the original touch location inside of the current responder?
	      var isAncestor = ReactInstanceHandles.isAncestorIDOf(responderID, EventPluginUtils.getID(target));
	      if (isAncestor) {
	        return false;
	      }
	    }
	  }
	  return true;
	}
	
	var ResponderEventPlugin = {
	
	  getResponderID: function () {
	    return responderID;
	  },
	
	  eventTypes: eventTypes,
	
	  /**
	   * We must be resilient to `topLevelTargetID` being `undefined` on
	   * `touchMove`, or `touchEnd`. On certain platforms, this means that a native
	   * scroll has assumed control and the original touch targets are destroyed.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    if (isStartish(topLevelType)) {
	      trackedTouchCount += 1;
	    } else if (isEndish(topLevelType)) {
	      trackedTouchCount -= 1;
	      !(trackedTouchCount >= 0) ?  false ? invariant(false, 'Ended a touch event which was not counted in trackedTouchCount.') : invariant(false) : undefined;
	    }
	
	    ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent, nativeEventTarget);
	
	    var extracted = canTriggerTransfer(topLevelType, topLevelTargetID, nativeEvent) ? setResponderAndExtractTransfer(topLevelType, topLevelTargetID, nativeEvent, nativeEventTarget) : null;
	    // Responder may or may not have transfered on a new touch start/move.
	    // Regardless, whoever is the responder after any potential transfer, we
	    // direct all touch start/move/ends to them in the form of
	    // `onResponderMove/Start/End`. These will be called for *every* additional
	    // finger that move/start/end, dispatched directly to whoever is the
	    // current responder at that moment, until the responder is "released".
	    //
	    // These multiple individual change touch events are are always bookended
	    // by `onResponderGrant`, and one of
	    // (`onResponderRelease/onResponderTerminate`).
	    var isResponderTouchStart = responderID && isStartish(topLevelType);
	    var isResponderTouchMove = responderID && isMoveish(topLevelType);
	    var isResponderTouchEnd = responderID && isEndish(topLevelType);
	    var incrementalTouch = isResponderTouchStart ? eventTypes.responderStart : isResponderTouchMove ? eventTypes.responderMove : isResponderTouchEnd ? eventTypes.responderEnd : null;
	
	    if (incrementalTouch) {
	      var gesture = ResponderSyntheticEvent.getPooled(incrementalTouch, responderID, nativeEvent, nativeEventTarget);
	      gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;
	      EventPropagators.accumulateDirectDispatches(gesture);
	      extracted = accumulate(extracted, gesture);
	    }
	
	    var isResponderTerminate = responderID && topLevelType === EventConstants.topLevelTypes.topTouchCancel;
	    var isResponderRelease = responderID && !isResponderTerminate && isEndish(topLevelType) && noResponderTouches(nativeEvent);
	    var finalTouch = isResponderTerminate ? eventTypes.responderTerminate : isResponderRelease ? eventTypes.responderRelease : null;
	    if (finalTouch) {
	      var finalEvent = ResponderSyntheticEvent.getPooled(finalTouch, responderID, nativeEvent, nativeEventTarget);
	      finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
	      EventPropagators.accumulateDirectDispatches(finalEvent);
	      extracted = accumulate(extracted, finalEvent);
	      changeResponder(null);
	    }
	
	    var numberActiveTouches = ResponderTouchHistoryStore.touchHistory.numberActiveTouches;
	    if (ResponderEventPlugin.GlobalInteractionHandler && numberActiveTouches !== previousActiveTouches) {
	      ResponderEventPlugin.GlobalInteractionHandler.onChange(numberActiveTouches);
	    }
	    previousActiveTouches = numberActiveTouches;
	
	    return extracted;
	  },
	
	  GlobalResponderHandler: null,
	  GlobalInteractionHandler: null,
	
	  injection: {
	    /**
	     * @param {{onChange: (ReactID, ReactID) => void} GlobalResponderHandler
	     * Object that handles any change in responder. Use this to inject
	     * integration with an existing touch handling system etc.
	     */
	    injectGlobalResponderHandler: function (GlobalResponderHandler) {
	      ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;
	    },
	
	    /**
	     * @param {{onChange: (numberActiveTouches) => void} GlobalInteractionHandler
	     * Object that handles any change in the number of active touches.
	     */
	    injectGlobalInteractionHandler: function (GlobalInteractionHandler) {
	      ResponderEventPlugin.GlobalInteractionHandler = GlobalInteractionHandler;
	    }
	  }
	};
	
	module.exports = ResponderEventPlugin;

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ResponderSyntheticEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(77);
	
	/**
	 * `touchHistory` isn't actually on the native event, but putting it in the
	 * interface will ensure that it is cleaned up when pooled/destroyed. The
	 * `ResponderEventPlugin` will populate it appropriately.
	 */
	var ResponderEventInterface = {
	  touchHistory: function (nativeEvent) {
	    return null; // Actually doesn't even look at the native event.
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native event.
	 * @extends {SyntheticEvent}
	 */
	function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(ResponderSyntheticEvent, ResponderEventInterface);
	
	module.exports = ResponderSyntheticEvent;

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ResponderTouchHistoryStore
	 */
	
	'use strict';
	
	var EventPluginUtils = __webpack_require__(33);
	
	var invariant = __webpack_require__(13);
	
	var isMoveish = EventPluginUtils.isMoveish;
	var isStartish = EventPluginUtils.isStartish;
	var isEndish = EventPluginUtils.isEndish;
	
	var MAX_TOUCH_BANK = 20;
	
	/**
	 * Touch position/time tracking information by touchID. Typically, we'll only
	 * see IDs with a range of 1-20 (they are recycled when touches end and then
	 * start again). This data is commonly needed by many different interaction
	 * logic modules so precomputing it is very helpful to do once.
	 * Each touch object in `touchBank` is of the following form:
	 * { touchActive: boolean,
	 *   startTimeStamp: number,
	 *   startPageX: number,
	 *   startPageY: number,
	 *   currentPageX: number,
	 *   currentPageY: number,
	 *   currentTimeStamp: number
	 * }
	 */
	var touchHistory = {
	  touchBank: [],
	  numberActiveTouches: 0,
	  // If there is only one active touch, we remember its location. This prevents
	  // us having to loop through all of the touches all the time in the most
	  // common case.
	  indexOfSingleActiveTouch: -1,
	  mostRecentTimeStamp: 0
	};
	
	var timestampForTouch = function (touch) {
	  // The legacy internal implementation provides "timeStamp", which has been
	  // renamed to "timestamp". Let both work for now while we iron it out
	  // TODO (evv): rename timeStamp to timestamp in internal code
	  return touch.timeStamp || touch.timestamp;
	};
	
	/**
	 * TODO: Instead of making gestures recompute filtered velocity, we could
	 * include a built in velocity computation that can be reused globally.
	 * @param {Touch} touch Native touch object.
	 */
	var initializeTouchData = function (touch) {
	  return {
	    touchActive: true,
	    startTimeStamp: timestampForTouch(touch),
	    startPageX: touch.pageX,
	    startPageY: touch.pageY,
	    currentPageX: touch.pageX,
	    currentPageY: touch.pageY,
	    currentTimeStamp: timestampForTouch(touch),
	    previousPageX: touch.pageX,
	    previousPageY: touch.pageY,
	    previousTimeStamp: timestampForTouch(touch)
	  };
	};
	
	var reinitializeTouchTrack = function (touchTrack, touch) {
	  touchTrack.touchActive = true;
	  touchTrack.startTimeStamp = timestampForTouch(touch);
	  touchTrack.startPageX = touch.pageX;
	  touchTrack.startPageY = touch.pageY;
	  touchTrack.currentPageX = touch.pageX;
	  touchTrack.currentPageY = touch.pageY;
	  touchTrack.currentTimeStamp = timestampForTouch(touch);
	  touchTrack.previousPageX = touch.pageX;
	  touchTrack.previousPageY = touch.pageY;
	  touchTrack.previousTimeStamp = timestampForTouch(touch);
	};
	
	var validateTouch = function (touch) {
	  var identifier = touch.identifier;
	  !(identifier != null) ?  false ? invariant(false, 'Touch object is missing identifier') : invariant(false) : undefined;
	  if (identifier > MAX_TOUCH_BANK) {
	    console.warn('Touch identifier ' + identifier + ' is greater than maximum ' + 'supported ' + MAX_TOUCH_BANK + ' which causes performance issues ' + 'backfilling array locations for all of the indices.');
	  }
	};
	
	var recordStartTouchData = function (touch) {
	  var touchBank = touchHistory.touchBank;
	  var identifier = touch.identifier;
	  var touchTrack = touchBank[identifier];
	  if (false) {
	    validateTouch(touch);
	  }
	  if (touchTrack) {
	    reinitializeTouchTrack(touchTrack, touch);
	  } else {
	    touchBank[touch.identifier] = initializeTouchData(touch);
	  }
	  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
	};
	
	var recordMoveTouchData = function (touch) {
	  var touchBank = touchHistory.touchBank;
	  var touchTrack = touchBank[touch.identifier];
	  if (false) {
	    validateTouch(touch);
	    !touchTrack ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Touch data should have been recorded on start') : invariant(false) : undefined;
	  }
	  touchTrack.touchActive = true;
	  touchTrack.previousPageX = touchTrack.currentPageX;
	  touchTrack.previousPageY = touchTrack.currentPageY;
	  touchTrack.previousTimeStamp = touchTrack.currentTimeStamp;
	  touchTrack.currentPageX = touch.pageX;
	  touchTrack.currentPageY = touch.pageY;
	  touchTrack.currentTimeStamp = timestampForTouch(touch);
	  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
	};
	
	var recordEndTouchData = function (touch) {
	  var touchBank = touchHistory.touchBank;
	  var touchTrack = touchBank[touch.identifier];
	  if (false) {
	    validateTouch(touch);
	    !touchTrack ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Touch data should have been recorded on start') : invariant(false) : undefined;
	  }
	  touchTrack.previousPageX = touchTrack.currentPageX;
	  touchTrack.previousPageY = touchTrack.currentPageY;
	  touchTrack.previousTimeStamp = touchTrack.currentTimeStamp;
	  touchTrack.currentPageX = touch.pageX;
	  touchTrack.currentPageY = touch.pageY;
	  touchTrack.currentTimeStamp = timestampForTouch(touch);
	  touchTrack.touchActive = false;
	  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
	};
	
	var ResponderTouchHistoryStore = {
	  recordTouchTrack: function (topLevelType, nativeEvent) {
	    var touchBank = touchHistory.touchBank;
	    if (isMoveish(topLevelType)) {
	      nativeEvent.changedTouches.forEach(recordMoveTouchData);
	    } else if (isStartish(topLevelType)) {
	      nativeEvent.changedTouches.forEach(recordStartTouchData);
	      touchHistory.numberActiveTouches = nativeEvent.touches.length;
	      if (touchHistory.numberActiveTouches === 1) {
	        touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;
	      }
	    } else if (isEndish(topLevelType)) {
	      nativeEvent.changedTouches.forEach(recordEndTouchData);
	      touchHistory.numberActiveTouches = nativeEvent.touches.length;
	      if (touchHistory.numberActiveTouches === 1) {
	        for (var i = 0; i < touchBank.length; i++) {
	          var touchTrackToCheck = touchBank[i];
	          if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {
	            touchHistory.indexOfSingleActiveTouch = i;
	            break;
	          }
	        }
	        if (false) {
	          var activeTouchData = touchBank[touchHistory.indexOfSingleActiveTouch];
	          var foundActive = activeTouchData != null && !!activeTouchData.touchActive;
	          !foundActive ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot find single active touch') : invariant(false) : undefined;
	        }
	      }
	    }
	  },
	
	  touchHistory: touchHistory
	};
	
	module.exports = ResponderTouchHistoryStore;

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule accumulate
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(13);
	
	/**
	 * Accumulates items that must not be null or undefined.
	 *
	 * This is used to conserve memory by avoiding array allocations.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */
	function accumulate(current, next) {
	  !(next != null) ?  false ? invariant(false, 'accumulate(...): Accumulated items must be not be null or undefined.') : invariant(false) : undefined;
	  if (current == null) {
	    return next;
	  } else {
	    // Both are not empty. Warning: Never call x.concat(y) when you are not
	    // certain that x is an Array (x could be a string with concat method).
	    var currentIsArray = Array.isArray(current);
	    var nextIsArray = Array.isArray(next);
	    if (currentIsArray) {
	      return current.concat(next);
	    } else {
	      if (nextIsArray) {
	        return [current].concat(next);
	      } else {
	        return [current, next];
	      }
	    }
	  }
	}
	
	module.exports = accumulate;

/***/ },
/* 246 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 */
	'use strict';
	
	var TouchHistoryMath = {
	  /**
	   * This code is optimized and not intended to look beautiful. This allows
	   * computing of touch centroids that have moved after `touchesChangedAfter`
	   * timeStamp. You can compute the current centroid involving all touches
	   * moves after `touchesChangedAfter`, or you can compute the previous
	   * centroid of all touches that were moved after `touchesChangedAfter`.
	   *
	   * @param {TouchHistoryMath} touchHistory Standard Responder touch track
	   * data.
	   * @param {number} touchesChangedAfter timeStamp after which moved touches
	   * are considered "actively moving" - not just "active".
	   * @param {boolean} isXAxis Consider `x` dimension vs. `y` dimension.
	   * @param {boolean} ofCurrent Compute current centroid for actively moving
	   * touches vs. previous centroid of now actively moving touches.
	   * @return {number} value of centroid in specified dimension.
	   */
	  centroidDimension: function centroidDimension(touchHistory, touchesChangedAfter, isXAxis, ofCurrent) {
	    var touchBank = touchHistory.touchBank;
	    var total = 0;
	    var count = 0;
	
	    var oneTouchData = touchHistory.numberActiveTouches === 1 ? touchHistory.touchBank[touchHistory.indexOfSingleActiveTouch] : null;
	
	    if (oneTouchData !== null) {
	      if (oneTouchData.touchActive && oneTouchData.currentTimeStamp > touchesChangedAfter) {
	        total += ofCurrent && isXAxis ? oneTouchData.currentPageX : ofCurrent && !isXAxis ? oneTouchData.currentPageY : !ofCurrent && isXAxis ? oneTouchData.previousPageX : oneTouchData.previousPageY;
	        count = 1;
	      }
	    } else {
	      for (var i = 0; i < touchBank.length; i++) {
	        var touchTrack = touchBank[i];
	        if (touchTrack !== null && touchTrack !== undefined && touchTrack.touchActive && touchTrack.currentTimeStamp >= touchesChangedAfter) {
	          var toAdd; // Yuck, program temporarily in invalid state.
	          if (ofCurrent && isXAxis) {
	            toAdd = touchTrack.currentPageX;
	          } else if (ofCurrent && !isXAxis) {
	            toAdd = touchTrack.currentPageY;
	          } else if (!ofCurrent && isXAxis) {
	            toAdd = touchTrack.previousPageX;
	          } else {
	            toAdd = touchTrack.previousPageY;
	          }
	          total += toAdd;
	          count++;
	        }
	      }
	    }
	    return count > 0 ? total / count : TouchHistoryMath.noCentroid;
	  },
	
	  currentCentroidXOfTouchesChangedAfter: function currentCentroidXOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
	    return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, true, // isXAxis
	    true // ofCurrent
	    );
	  },
	
	  currentCentroidYOfTouchesChangedAfter: function currentCentroidYOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
	    return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false, // isXAxis
	    true // ofCurrent
	    );
	  },
	
	  previousCentroidXOfTouchesChangedAfter: function previousCentroidXOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
	    return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, true, // isXAxis
	    false // ofCurrent
	    );
	  },
	
	  previousCentroidYOfTouchesChangedAfter: function previousCentroidYOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
	    return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false, // isXAxis
	    false // ofCurrent
	    );
	  },
	
	  currentCentroidX: function currentCentroidX(touchHistory) {
	    return TouchHistoryMath.centroidDimension(touchHistory, 0, // touchesChangedAfter
	    true, // isXAxis
	    true // ofCurrent
	    );
	  },
	
	  currentCentroidY: function currentCentroidY(touchHistory) {
	    return TouchHistoryMath.centroidDimension(touchHistory, 0, // touchesChangedAfter
	    false, // isXAxis
	    true // ofCurrent
	    );
	  },
	
	  noCentroid: -1
	};
	
	module.exports = TouchHistoryMath;

/***/ },
/* 247 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * @providesModule ReactDimensions
	 */
	'use strict';
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var dimensions = {
	  // Not map to real window size, because that map to screen size in native env.
	  window: {
	    width: document.documentElement.clientWidth,
	    height: document.documentElement.clientHeight,
	    scale: window.devicePixelRatio || 1
	  },
	  modalFullscreenView: {
	    width: screen.width,
	    height: screen.height
	  }
	};
	
	var Dimensions = (function () {
	  function Dimensions() {
	    _classCallCheck(this, Dimensions);
	  }
	
	  _createClass(Dimensions, null, [{
	    key: 'get',
	
	    /**
	     * Initial dimensions are set before `runApplication` is called so they should
	     * be available before any other require's are run, but may be updated later.
	     *
	     * Note: Although dimensions are available immediately, they may change (e.g
	     * due to device rotation) so any rendering logic or styles that depend on
	     * these constants should try to call this function on every render, rather
	     * than caching the value (for example, using inline styles rather than
	     * setting a value in a `StyleSheet`).
	     *
	     * @param {string} dim Name of dimension as defined when calling `set`.
	     * @returns {Object?} Value for the dimension.
	     */
	    value: function get(dim) {
	      return dimensions[dim];
	    }
	  }]);
	
	  return Dimensions;
	})();
	
	module.exports = Dimensions;

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Axsy Software Ltd
	 *
	 * @providesModule ReactListView
	 */
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _ReactListViewDataSource = __webpack_require__(249);
	
	var _ReactListViewDataSource2 = _interopRequireDefault(_ReactListViewDataSource);
	
	var _WinJSDataSourceAdapter = __webpack_require__(253);
	
	var _WinJSDataSourceAdapter2 = _interopRequireDefault(_WinJSDataSourceAdapter);
	
	var _reactWinjs = __webpack_require__(254);
	
	var _reactWinjs2 = _interopRequireDefault(_reactWinjs);
	
	var ListView = (function (_React$Component) {
	  _inherits(ListView, _React$Component);
	
	  _createClass(ListView, [{
	    key: 'itemRenderer',
	
	    // winJS mappings
	    value: function itemRenderer(renderRow) {
	      return _reactWinjs2['default'].reactRenderer(function (item) {
	        return renderRow(item.data);
	      });
	      //
	    }
	
	    // Constructor
	  }], [{
	    key: 'DataSource',
	
	    // pass down the ability to instantiate new listView.DataSource(...)
	    value: function DataSource(params) {
	      return new _ReactListViewDataSource2['default'](params);
	    }
	  }]);
	
	  function ListView(props, context) {
	    _classCallCheck(this, ListView);
	
	    _get(Object.getPrototypeOf(ListView.prototype), 'constructor', this).call(this, props, context);
	    this.winjsbinding = new _WinJSDataSourceAdapter2['default'].datasource(this);
	  }
	
	  _createClass(ListView, [{
	    key: 'updateDataSource',
	    value: function updateDataSource(normalReactDataSource) {
	      if (this.dataSource != normalReactDataSource) {
	        this.dataSource = normalReactDataSource;
	        this.state = {
	          update: 1
	        };
	        this.winjsbinding.invalidateAll();
	        console.log("set for update");
	      }
	    }
	
	    // callbacks
	
	  }, {
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      console.log("componentDidMount");
	      var normalReactDataSource = this.props.dataSource;
	      this.updateDataSource(normalReactDataSource);
	    }
	  }, {
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(nextProps) {
	      console.log("componentWillReceiveProps");
	      this.updateDataSource(nextProps.dataSource);
	    }
	  }, {
	    key: 'shouldComponentUpdate',
	    value: function shouldComponentUpdate(nextProps, nextState) {
	      var update = false;
	      if (this.state.update) {
	        update = true;
	        this.state = {
	          update: 0
	        };
	      }
	      console.log("shouldComponentUpdate " + update);
	      return update;
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      console.log("render");
	      return _react2['default'].createElement(_reactWinjs2['default'].ListView, {
	        style: this.props.style,
	        className: 'win-container',
	        itemDataSource: this.winjsbinding,
	        itemTemplate: this.itemRenderer(this.props.renderRow),
	        layout: { type: WinJS.UI.ListLayout }
	      });
	    }
	  }]);
	
	  return ListView;
	})(_react2['default'].Component);
	
	exports['default'] = ListView;
	module.exports = exports['default'];

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015, Facebook, Inc.  All rights reserved.
	 *
	 * @providesModule ReactListViewDataSource
	 */
	'use strict';
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _fbjsLibInvariant = __webpack_require__(231);
	
	var _fbjsLibInvariant2 = _interopRequireDefault(_fbjsLibInvariant);
	
	var _fbjsLibIsEmpty = __webpack_require__(250);
	
	var _fbjsLibIsEmpty2 = _interopRequireDefault(_fbjsLibIsEmpty);
	
	var _fbjsLibWarning = __webpack_require__(251);
	
	var _fbjsLibWarning2 = _interopRequireDefault(_fbjsLibWarning);
	
	function defaultGetRowData(dataBlob, sectionID, rowID) {
	  return dataBlob[sectionID][rowID];
	}
	
	function defaultGetSectionHeaderData(dataBlob, sectionID) {
	  return dataBlob[sectionID];
	}
	
	/**
	 * Provides efficient data processing and access to the
	 * `ListView` component.  A `ListViewDataSource` is created with functions for
	 * extracting data from the input blob, and comparing elements (with default
	 * implementations for convenience).  The input blob can be as simple as an
	 * array of strings, or an object with rows nested inside section objects.
	 *
	 * To update the data in the datasource, use `cloneWithRows` (or
	 * `cloneWithRowsAndSections` if you care about sections).  The data in the
	 * data source is immutable, so you can't modify it directly.  The clone methods
	 * suck in the new data and compute a diff for each row so ListView knows
	 * whether to re-render it or not.
	 *
	 * In this example, a component receives data in chunks, handled by
	 * `_onDataArrived`, which concats the new data onto the old data and updates the
	 * data source.  We use `concat` to create a new array - mutating `this._data`,
	 * e.g. with `this._data.push(newRowData)`, would be an error. `_rowHasChanged`
	 * understands the shape of the row data and knows how to efficiently compare
	 * it.
	 *
	 * ```
	 * getInitialState: function() {
	 *   var ds = new ListViewDataSource({rowHasChanged: this._rowHasChanged});
	 *   return {ds};
	 * },
	 * _onDataArrived(newData) {
	 *   this._data = this._data.concat(newData);
	 *   this.setState({
	 *     ds: this.state.ds.cloneWithRows(this._data)
	 *   });
	 * }
	 * ```
	 */
	
	var ListViewDataSource = (function () {
	
	  /**
	   * You can provide custom extraction and `hasChanged` functions for section
	   * headers and rows.  If absent, data will be extracted with the
	   * `defaultGetRowData` and `defaultGetSectionHeaderData` functions.
	   *
	   * The default extractor expects data of one of the following forms:
	   *
	   *      { sectionID_1: { rowID_1: <rowData1>, ... }, ... }
	   *
	   *    or
	   *
	   *      { sectionID_1: [ <rowData1>, <rowData2>, ... ], ... }
	   *
	   *    or
	   *
	   *      [ [ <rowData1>, <rowData2>, ... ], ... ]
	   *
	   * The constructor takes in a params argument that can contain any of the
	   * following:
	   *
	   * - getRowData(dataBlob, sectionID, rowID);
	   * - getSectionHeaderData(dataBlob, sectionID);
	   * - rowHasChanged(prevRowData, nextRowData);
	   * - sectionHeaderHasChanged(prevSectionData, nextSectionData);
	   */
	
	  function ListViewDataSource(params) {
	    _classCallCheck(this, ListViewDataSource);
	
	    (0, _fbjsLibInvariant2['default'])(params && typeof params.rowHasChanged === 'function', 'Must provide a rowHasChanged function.');
	    this._rowHasChanged = params.rowHasChanged;
	    this._getRowData = params.getRowData || defaultGetRowData;
	    this._sectionHeaderHasChanged = params.sectionHeaderHasChanged;
	    this._getSectionHeaderData = params.getSectionHeaderData || defaultGetSectionHeaderData;
	
	    this._dataBlob = null;
	    this._dirtyRows = [];
	    this._dirtySections = [];
	    this._cachedRowCount = 0;
	
	    // These two private variables are accessed by outsiders because ListView
	    // uses them to iterate over the data in this class.
	    this.rowIdentities = [];
	    this.sectionIdentities = [];
	  }
	
	  /**
	   * Clones this `ListViewDataSource` with the specified `dataBlob` and
	   * `rowIdentities`. The `dataBlob` is just an aribitrary blob of data. At
	   * construction an extractor to get the interesting information was defined
	   * (or the default was used).
	   *
	   * The `rowIdentities` is is a 2D array of identifiers for rows.
	   * ie. [['a1', 'a2'], ['b1', 'b2', 'b3'], ...].  If not provided, it's
	   * assumed that the keys of the section data are the row identities.
	   *
	   * Note: This function does NOT clone the data in this data source. It simply
	   * passes the functions defined at construction to a new data source with
	   * the data specified. If you wish to maintain the existing data you must
	   * handle merging of old and new data separately and then pass that into
	   * this function as the `dataBlob`.
	   */
	
	  _createClass(ListViewDataSource, [{
	    key: 'cloneWithRows',
	    value: function cloneWithRows(dataBlob, rowIdentities) {
	      var rowIds = rowIdentities ? [rowIdentities] : null;
	      if (!this._sectionHeaderHasChanged) {
	        this._sectionHeaderHasChanged = function () {
	          return false;
	        };
	      }
	      return this.cloneWithRowsAndSections({ s1: dataBlob }, ['s1'], rowIds);
	    }
	
	    /**
	     * This performs the same function as the `cloneWithRows` function but here
	     * you also specify what your `sectionIdentities` are. If you don't care
	     * about sections you should safely be able to use `cloneWithRows`.
	     *
	     * `sectionIdentities` is an array of identifiers for  sections.
	     * ie. ['s1', 's2', ...].  If not provided, it's assumed that the
	     * keys of dataBlob are the section identities.
	     *
	     * Note: this returns a new object!
	     */
	  }, {
	    key: 'cloneWithRowsAndSections',
	    value: function cloneWithRowsAndSections(dataBlob, sectionIdentities, rowIdentities) {
	      (0, _fbjsLibInvariant2['default'])(typeof this._sectionHeaderHasChanged === 'function', 'Must provide a sectionHeaderHasChanged function with section data.');
	      var newSource = new ListViewDataSource({
	        getRowData: this._getRowData,
	        getSectionHeaderData: this._getSectionHeaderData,
	        rowHasChanged: this._rowHasChanged,
	        sectionHeaderHasChanged: this._sectionHeaderHasChanged
	      });
	      newSource._dataBlob = dataBlob;
	      if (sectionIdentities) {
	        newSource.sectionIdentities = sectionIdentities;
	      } else {
	        newSource.sectionIdentities = Object.keys(dataBlob);
	      }
	      if (rowIdentities) {
	        newSource.rowIdentities = rowIdentities;
	      } else {
	        newSource.rowIdentities = [];
	        newSource.sectionIdentities.forEach(function (sectionID) {
	          newSource.rowIdentities.push(Object.keys(dataBlob[sectionID]));
	        });
	      }
	      newSource._cachedRowCount = countRows(newSource.rowIdentities);
	
	      newSource._calculateDirtyArrays(this._dataBlob, this.sectionIdentities, this.rowIdentities);
	
	      return newSource;
	    }
	  }, {
	    key: 'getRowCount',
	    value: function getRowCount() {
	      return this._cachedRowCount;
	    }
	
	    /**
	     * Returns if the row is dirtied and needs to be rerendered
	     */
	  }, {
	    key: 'rowShouldUpdate',
	    value: function rowShouldUpdate(sectionIndex, rowIndex) {
	      var needsUpdate = this._dirtyRows[sectionIndex][rowIndex];
	      (0, _fbjsLibWarning2['default'])(needsUpdate !== undefined, 'missing dirtyBit for section, row: ' + sectionIndex + ', ' + rowIndex);
	      return needsUpdate;
	    }
	
	    /**
	     * Gets the data required to render the row.
	     */
	  }, {
	    key: 'getRowData',
	    value: function getRowData(sectionIndex, rowIndex) {
	      var sectionID = this.sectionIdentities[sectionIndex];
	      var rowID = this.rowIdentities[sectionIndex][rowIndex];
	      (0, _fbjsLibWarning2['default'])(sectionID !== undefined && rowID !== undefined, 'rendering invalid section, row: ' + sectionIndex + ', ' + rowIndex);
	      return this._getRowData(this._dataBlob, sectionID, rowID);
	    }
	
	    /**
	     * Gets the rowID at index provided if the dataSource arrays were flattened,
	     * or null of out of range indexes.
	     */
	  }, {
	    key: 'getRowIndexForFlatIndex',
	    value: function getRowIndexForFlatIndex(index) {
	      var accessIndex = index;
	      for (var ii = 0; ii < this.sectionIdentities.length; ii++) {
	        if (accessIndex >= this.rowIdentities[ii].length) {
	          accessIndex -= this.rowIdentities[ii].length;
	        } else {
	          return accessIndex;
	        }
	      }
	      return null;
	    }
	
	    /**
	     * Gets the sectionID at index provided if the dataSource arrays were flattened,
	     * or null for out of range indexes.
	     */
	  }, {
	    key: 'getSectionIndexForFlatIndex',
	    value: function getSectionIndexForFlatIndex(index) {
	      var accessIndex = index;
	      for (var ii = 0; ii < this.sectionIdentities.length; ii++) {
	        if (accessIndex >= this.rowIdentities[ii].length) {
	          accessIndex -= this.rowIdentities[ii].length;
	        } else {
	          return ii;
	        }
	      }
	      return null;
	    }
	
	    /**
	     * Returns an array containing the number of rows in each section
	     */
	  }, {
	    key: 'getSectionLengths',
	    value: function getSectionLengths() {
	      var results = [];
	      for (var ii = 0; ii < this.sectionIdentities.length; ii++) {
	        results.push(this.rowIdentities[ii].length);
	      }
	      return results;
	    }
	
	    /**
	     * Returns if the section header is dirtied and needs to be rerendered
	     */
	  }, {
	    key: 'sectionHeaderShouldUpdate',
	    value: function sectionHeaderShouldUpdate(sectionIndex) {
	      var needsUpdate = this._dirtySections[sectionIndex];
	      (0, _fbjsLibWarning2['default'])(needsUpdate !== undefined, 'missing dirtyBit for section: ' + sectionIndex);
	      return needsUpdate;
	    }
	
	    /**
	     * Gets the data required to render the section header
	     */
	  }, {
	    key: 'getSectionHeaderData',
	    value: function getSectionHeaderData(sectionIndex) {
	      if (!this._getSectionHeaderData) {
	        return null;
	      }
	      var sectionID = this.sectionIdentities[sectionIndex];
	      (0, _fbjsLibWarning2['default'])(sectionID !== undefined, 'renderSection called on invalid section: ' + sectionIndex);
	      return this._getSectionHeaderData(this._dataBlob, sectionID);
	    }
	
	    /**
	     * Private members and methods.
	     */
	
	  }, {
	    key: '_calculateDirtyArrays',
	    value: function _calculateDirtyArrays(prevDataBlob, prevSectionIDs, prevRowIDs) {
	      // construct a hashmap of the existing (old) id arrays
	      var prevSectionsHash = keyedDictionaryFromArray(prevSectionIDs);
	      var prevRowsHash = {};
	      for (var ii = 0; ii < prevRowIDs.length; ii++) {
	        var sectionID = prevSectionIDs[ii];
	        (0, _fbjsLibWarning2['default'])(!prevRowsHash[sectionID], 'SectionID appears more than once: ' + sectionID);
	        prevRowsHash[sectionID] = keyedDictionaryFromArray(prevRowIDs[ii]);
	      }
	
	      // compare the 2 identity array and get the dirtied rows
	      this._dirtySections = [];
	      this._dirtyRows = [];
	
	      var dirty;
	      for (var sIndex = 0; sIndex < this.sectionIdentities.length; sIndex++) {
	        var sectionID = this.sectionIdentities[sIndex];
	        // dirty if the sectionHeader is new or _sectionHasChanged is true
	        dirty = !prevSectionsHash[sectionID];
	        var sectionHeaderHasChanged = this._sectionHeaderHasChanged;
	        if (!dirty && sectionHeaderHasChanged) {
	          dirty = sectionHeaderHasChanged(this._getSectionHeaderData(prevDataBlob, sectionID), this._getSectionHeaderData(this._dataBlob, sectionID));
	        }
	        this._dirtySections.push(!!dirty);
	
	        this._dirtyRows[sIndex] = [];
	        for (var rIndex = 0; rIndex < this.rowIdentities[sIndex].length; rIndex++) {
	          var rowID = this.rowIdentities[sIndex][rIndex];
	          // dirty if the section is new, row is new or _rowHasChanged is true
	          dirty = !prevSectionsHash[sectionID] || !prevRowsHash[sectionID][rowID] || this._rowHasChanged(this._getRowData(prevDataBlob, sectionID, rowID), this._getRowData(this._dataBlob, sectionID, rowID));
	          this._dirtyRows[sIndex].push(!!dirty);
	        }
	      }
	    }
	  }]);
	
	  return ListViewDataSource;
	})();
	
	function countRows(allRowIDs) {
	  var totalRows = 0;
	  for (var sectionIdx = 0; sectionIdx < allRowIDs.length; sectionIdx++) {
	    var rowIDs = allRowIDs[sectionIdx];
	    totalRows += rowIDs.length;
	  }
	  return totalRows;
	}
	
	function keyedDictionaryFromArray(arr) {
	  if ((0, _fbjsLibIsEmpty2['default'])(arr)) {
	    return {};
	  }
	  var result = {};
	  for (var ii = 0; ii < arr.length; ii++) {
	    var key = arr[ii];
	    (0, _fbjsLibWarning2['default'])(!result[key], 'Value appears more than once in array: ' + key);
	    result[key] = true;
	  }
	  return result;
	}
	
	// extras
	
	module.exports = ListViewDataSource;
	
	// These two 'protected' variables are accessed by ListView to iterate over
	// the data in this class.

/***/ },
/* 250 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isEmpty
	 */
	
	/*eslint-disable no-unused-vars */
	
	/**
	 * Mimics empty from PHP.
	 */
	'use strict';
	
	function isEmpty(obj) {
	  if (Array.isArray(obj)) {
	    return obj.length === 0;
	  } else if (typeof obj === 'object') {
	    for (var i in obj) {
	      return false;
	    }
	    return true;
	  } else {
	    return !obj;
	  }
	}
	
	module.exports = isEmpty;

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule warning
	 */
	
	"use strict";
	
	var emptyFunction = __webpack_require__(252);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if (false) {
	  warning = function (condition, format) {
	    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      args[_key - 2] = arguments[_key];
	    }
	
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	
	    if (format.indexOf('Failed Composite propType: ') === 0) {
	      return; // Ignore CompositeComponent proptype check.
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    }
	  };
	}
	
	module.exports = warning;

/***/ },
/* 252 */
15,
/* 253 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2015-present, Axsy Software Ltd
	 *
	 * This implements a WinJS datasource that will wrap the standard react-native datasource
	 * @providesModule WinJSDataSourceAdapter
	 */
	
	// Definition of the data adapter
	"use strict";
	
	var WinJSDataSourceAdapter = WinJS.Class.define(function (listView) {
	
	    // Constructor
	    this._minPageSize = 50;
	    this._maxPageSize = 50;
	    this._maxCount = 1000;
	    this._listView = listView;
	},
	
	// Data Adapter interface methods
	// These define the contract between the virtualized datasource and the data adapter.
	// These methods will be called by virtualized datasource to fetch items, count etc.
	{
	    // This class only implements the itemsFromIndex and count methods
	
	    // Called to get a count of the items
	    // The value of the count can be updated later in the response to itemsFromIndex
	    getCount: function getCount() {
	        console.log("length request ");
	
	        var that = this;
	
	        return new WinJS.Promise(function (resolve, reject) {
	            if (that._listView.props.dataSource) {
	                console.log("sent " + that._listView.props.dataSource.getRowCount() + " rows");
	                resolve(that._listView.props.dataSource.getRowCount());
	            } else {
	                console.log("no datasource (yet!)");
	                resolve(0);
	            }
	        });
	    },
	
	    // Called by the virtualized datasource to fetch items
	    // It will request a specific item and optionally ask for a number of items on either side of the requested item.
	    // The implementation should return the specific item and, in addition, can choose to return a range of items on either
	    // side of the requested index. The number of extra items returned by the implementation can be more or less than the number requested.
	    //
	    // Must return back an object containing fields:
	    //   items: The array of items of the form items=[{ key: key1, data : { field1: value, field2: value, ... }}, { key: key2, data : {...}}, ...];
	    //   offset: The offset into the array for the requested item
	    //   totalCount: (optional) update the value of the count
	    itemsFromIndex: function itemsFromIndex(requestIndex, countBefore, countAfter) {
	        console.log("data request " + requestIndex);
	        var that = this;
	        if (requestIndex >= that._maxCount) {
	            return WinJS.Promise.wrapError(new WinJS.ErrorFromName(WinJS.UI.FetchError.doesNotExist));
	        }
	
	        var fetchSize, fetchIndex;
	        // See which side of the requestIndex is the overlap
	        if (countBefore > countAfter) {
	            //Limit the overlap
	            countAfter = Math.min(countAfter, 10);
	            //Bound the request size based on the minimum and maximum sizes
	            var fetchBefore = Math.max(Math.min(countBefore, that._maxPageSize - (countAfter + 1)), that._minPageSize - (countAfter + 1));
	            fetchSize = fetchBefore + countAfter + 1;
	            fetchIndex = requestIndex - fetchBefore;
	        } else {
	            countBefore = Math.min(countBefore, 10);
	            var fetchAfter = Math.max(Math.min(countAfter, that._maxPageSize - (countBefore + 1)), that._minPageSize - (countBefore + 1));
	            fetchSize = countBefore + fetchAfter + 1;
	            fetchIndex = requestIndex - countBefore;
	        }
	
	        if (that._listView.props.dataSource) {
	            var results = [],
	                count;
	
	            for (var i = 0; i < fetchSize && fetchIndex + i < that._listView.props.dataSource.getRowCount(); i++) {
	                var rowID = that._listView.props.dataSource.getRowIndexForFlatIndex(fetchIndex + i);
	                var sectionID = that._listView.props.dataSource.getSectionIndexForFlatIndex(fetchIndex + i);
	                var dataItem = that._listView.props.dataSource.getRowData(sectionID, rowID);
	                results.push({
	                    key: (fetchIndex + i).toString(),
	                    data: dataItem
	                });
	            }
	            console.log("returned " + results.length + " items");
	            return new WinJS.Promise(function (resolve, reject) {
	                resolve({
	                    items: results, // The array of items
	                    offset: requestIndex - fetchIndex, // The offset into the array for the requested item
	                    totalCount: that._listView.props.dataSource.getRowCount()
	                });
	            });
	        } else {
	            return new WinJS.Promise(function (resolve, reject) {
	                resolve({
	                    items: [], // The array of items
	                    offset: 0, // The offset into the array for the requested item
	                    totalCount: 0
	                });
	            });
	        }
	    },
	
	    setNotificationHandler: function setNotificationHandler(notificationHandler) {
	        this._notificationHandler = notificationHandler;
	    },
	
	    itemSignature: function itemSignature(item) {
	        return item.hash;
	    }
	    // itemsFromStart: not implemented
	    // itemsFromEnd: not implemented
	    // itemsFromKey: not implemented
	    // itemsFromDescription: not implemented
	});
	
	WinJSDataSourceAdapter.datasource = WinJS.Class.derive(WinJS.UI.VirtualizedDataSource, function (listView) {
	    this._baseDataSourceConstructor(new WinJSDataSourceAdapter(listView));
	});
	
	//     WinJS.Namespace.define("WinJSDataSourceAdapter", {
	//         datasource: WinJS.Class.derive(WinJS.UI.VirtualizedDataSource, function () {
	//             this._baseDataSourceConstructor(new WinJSDataSourceAdapter());
	//         })
	//     });
	
	module.exports = WinJSDataSourceAdapter;

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	
	//
	// Implementation Overview
	//
	// react-winjs is organized around the concept of prop handlers. A prop handler describes
	// how a react-winjs prop affects the underlying WinJS control. Prop handlers come from 3 sources:
	//   1. Handwritten common to all controls. These are defined in a variable called
	//      *defaultPropHandlers*. These are prop handlers which appear on every react-winjs component.
	//   2. WinJS's d.ts file. Most of the prop handlers for each react-winjs component are
	//      automatically generated from WinJS's d.ts file. Information from the d.ts file is stored in
	//      a variable called *RawControlApis*. *RawControlApis* is generated by running the d.ts file
	//      through this tool: https://github.com/winjs/winjs-control-apis
	//   3. Handwritten control-specific. These are defined in a variable called *ControlApis*. When
	//      a react-winjs component has a prop that needs to be defined manually, this is where it
	//      should be defined. There are a number of types of builtin prop handlers defined in the
	//      *PropHandlers* variable which can be used here.
	//
	// When react-winjs builds the list of prop handlers for a component, it gathers them from the above
	// list of sources. If multiple sources define a prop handler with the same name, the one from the
	// source which appears closest to the bottom of the list above wins.
	//
	// There's a particular category of WinJS controls that host content that proved to be particularly
	// challenging to wrap as React components. More specifically, the controls in this category:
	//   - host content
	//   - move the hosted content around in the DOM
	//   - store the hosted content in a Binding.List
	//
	// Controls that fall into this category of hosting content include:
	//   - AppBar/ToolBar
	//   - Hub
	//   - Pivot
	//
	// And the controls that get hosted include (these are the ones that end up being created
	// through WinJSChildComponent, described below):
	//   - AppBarCommand
	//   - HubSection
	//   - PivotItem
	//
	// What made this challenging to solve is that there are some features that aren't achievable in
	// a straight forward way through the React APIs. To solve this, you want to be able to:
	//   - Render a React component *onto* an existing element. React.render can only render *into* an
	//     existing element. For example, when creating a HubSection you want to be able to control
	//     attributes of the win-hub-section element such as its *class* and *style*. With React.render,
	//     you'd only be able to render into the win-hub-section element so the React component wouldn't
	//     be able to control any attributes of the win-hub-section element.
	//   - Hold onto a rendered component and inspect its *type* and *key* prop later. This information
	//     comes in handy when diffing an array of components from a previous render pass with an array
	//     of components for the current render pass. The diff information is used to mutate a
	//     Binding.List to get it into the desired state.
	//
	// The WinJSChildComponent class provides a convenient API for solving both of these problems. When the
	// constructor receives a component, it creates the element (e.g. win-hub-section) that the component
	// is rendered *onto*. The owning control (e.g. WinJS.UI.Hub) is free to manage that element and move
	// it around the DOM. WinJSChildComponent provides the following APIs:
	//   - update: Updates the element based on the component description that is passed in.
	//   - dispose: Disposes the react-winjs component and its associated WinJS control.
	//   - key: Returns the React key associated with the component.
	//   - type: Returns the React type associated with the component.
	//
	
	// Generated from https://github.com/winjs/winjs-control-apis
	var RawControlApis = {
	    AppBar: {
	        closedDisplayMode: {
	            type: "enum",
	            values: [
	                "compact",
	                "full",
	                "minimal",
	                "none"
	            ]
	        },
	        data: {
	            name: "WinJS.Binding.List",
	            type: "reference",
	            typeArguments: [
	                {
	                    name: "WinJS.UI.ICommand",
	                    type: "reference",
	                    typeArguments: []
	                }
	            ]
	        },
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        onAfterClose: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onAfterOpen: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onBeforeClose: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onBeforeOpen: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        opened: {
	            type: "boolean"
	        },
	        placement: {
	            type: "enum",
	            values: [
	                "bottom",
	                "top"
	            ]
	        }
	    },
	    AppBarCommand: {
	        disabled: {
	            type: "boolean"
	        },
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        extraClass: {
	            type: "string"
	        },
	        firstElementFocus: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        flyout: {
	            name: "WinJS.UI.Flyout",
	            type: "reference",
	            typeArguments: []
	        },
	        hidden: {
	            type: "boolean"
	        },
	        icon: {
	            type: "string"
	        },
	        id: {
	            type: "string"
	        },
	        label: {
	            type: "string"
	        },
	        lastElementFocus: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        onClick: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        priority: {
	            type: "number"
	        },
	        section: {
	            type: "string"
	        },
	        selected: {
	            type: "boolean"
	        },
	        tooltip: {
	            type: "string"
	        },
	        type: {
	            type: "string"
	        }
	    },
	    AutoSuggestBox: {
	        chooseSuggestionOnEnter: {
	            type: "boolean"
	        },
	        disabled: {
	            type: "boolean"
	        },
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        onQueryChanged: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onQuerySubmitted: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onResultSuggestionChosen: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onSuggestionsRequested: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        placeholderText: {
	            type: "string"
	        },
	        queryText: {
	            type: "string"
	        },
	        searchHistoryContext: {
	            type: "string"
	        },
	        searchHistoryDisabled: {
	            type: "boolean"
	        }
	    },
	    BackButton: {
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        }
	    },
	    CellSpanningLayout: {
	        groupHeaderPosition: {
	            type: "enum",
	            values: [
	                "left",
	                "top"
	            ]
	        },
	        groupInfo: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        itemInfo: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        maximumRowsOrColumns: {
	            type: "number"
	        },
	        numberOfItemsPerItemsBlock: {
	            type: "any"
	        },
	        orientation: {
	            type: "enum",
	            values: [
	                "horizontal",
	                "vertical"
	            ]
	        }
	    },
	    Command: {
	        disabled: {
	            type: "boolean"
	        },
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        extraClass: {
	            type: "string"
	        },
	        firstElementFocus: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        flyout: {
	            name: "WinJS.UI.Flyout",
	            type: "reference",
	            typeArguments: []
	        },
	        hidden: {
	            type: "boolean"
	        },
	        icon: {
	            type: "string"
	        },
	        id: {
	            type: "string"
	        },
	        label: {
	            type: "string"
	        },
	        lastElementFocus: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        onClick: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        priority: {
	            type: "number"
	        },
	        section: {
	            type: "string"
	        },
	        selected: {
	            type: "boolean"
	        },
	        tooltip: {
	            type: "string"
	        },
	        type: {
	            type: "string"
	        }
	    },
	    ContentDialog: {
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        hidden: {
	            type: "boolean"
	        },
	        onAfterHide: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onAfterShow: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onBeforeHide: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onBeforeShow: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        primaryCommandDisabled: {
	            type: "boolean"
	        },
	        primaryCommandText: {
	            type: "string"
	        },
	        secondaryCommandDisabled: {
	            type: "boolean"
	        },
	        secondaryCommandText: {
	            type: "string"
	        },
	        title: {
	            type: "string"
	        }
	    },
	    DatePicker: {
	        calendar: {
	            type: "string"
	        },
	        current: {
	            name: "Date",
	            type: "reference",
	            typeArguments: []
	        },
	        datePattern: {
	            type: "string"
	        },
	        disabled: {
	            type: "boolean"
	        },
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        maxYear: {
	            type: "number"
	        },
	        minYear: {
	            type: "number"
	        },
	        monthPattern: {
	            type: "string"
	        },
	        onChange: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        yearPattern: {
	            type: "string"
	        }
	    },
	    FlipView: {
	        currentPage: {
	            type: "number"
	        },
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        itemDataSource: {
	            name: "WinJS.UI.IListDataSource",
	            type: "reference",
	            typeArguments: [
	                {
	                    name: "T",
	                    type: "type-param"
	                }
	            ]
	        },
	        itemSpacing: {
	            type: "number"
	        },
	        itemTemplate: {
	            type: "any"
	        },
	        onDataSourceCountChanged: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onPageCompleted: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onPageSelected: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onPageVisibilityChanged: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        orientation: {
	            type: "string"
	        }
	    },
	    Flyout: {
	        alignment: {
	            type: "string"
	        },
	        anchor: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        disabled: {
	            type: "boolean"
	        },
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        hidden: {
	            type: "boolean"
	        },
	        onAfterHide: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onAfterShow: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onBeforeHide: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onBeforeShow: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        placement: {
	            type: "string"
	        }
	    },
	    GridLayout: {
	        backdropColor: {
	            type: "string"
	        },
	        disableBackdrop: {
	            type: "boolean"
	        },
	        groupHeaderPosition: {
	            type: "enum",
	            values: [
	                "left",
	                "top"
	            ]
	        },
	        groupInfo: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        itemInfo: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        maxRows: {
	            type: "number"
	        },
	        maximumRowsOrColumns: {
	            type: "number"
	        },
	        numberOfItemsPerItemsBlock: {
	            type: "any"
	        },
	        orientation: {
	            type: "enum",
	            values: [
	                "horizontal",
	                "vertical"
	            ]
	        }
	    },
	    Hub: {
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        headerTemplate: {
	            type: "any"
	        },
	        indexOfFirstVisible: {
	            type: "number"
	        },
	        indexOfLastVisible: {
	            type: "number"
	        },
	        loadingState: {
	            type: "enum",
	            values: [
	                "complete",
	                "loading"
	            ]
	        },
	        onContentAnimating: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onHeaderInvoked: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onLoadingStateChanged: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        orientation: {
	            type: "enum",
	            values: [
	                "horizontal",
	                "vertical"
	            ]
	        },
	        scrollPosition: {
	            type: "number"
	        },
	        sectionOnScreen: {
	            type: "number"
	        },
	        sections: {
	            name: "WinJS.Binding.List",
	            type: "reference",
	            typeArguments: [
	                {
	                    name: "WinJS.UI.HubSection",
	                    type: "reference",
	                    typeArguments: []
	                }
	            ]
	        },
	        zoomableView: {
	            name: "WinJS.UI.IZoomableView",
	            type: "reference",
	            typeArguments: [
	                {
	                    type: "any"
	                }
	            ]
	        }
	    },
	    HubSection: {
	        contentElement: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        header: {
	            type: "string"
	        },
	        isHeaderStatic: {
	            type: "boolean"
	        }
	    },
	    ItemContainer: {
	        draggable: {
	            type: "boolean"
	        },
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        onInvoked: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onSelectionChanged: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onSelectionChanging: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        selected: {
	            type: "boolean"
	        },
	        selectionDisabled: {
	            type: "boolean"
	        },
	        swipeBehavior: {
	            type: "enum",
	            values: [
	                "none",
	                "select"
	            ]
	        },
	        swipeOrientation: {
	            type: "enum",
	            values: [
	                "horizontal",
	                "vertical"
	            ]
	        },
	        tapBehavior: {
	            type: "enum",
	            values: [
	                "directSelect",
	                "invokeOnly",
	                "none",
	                "toggleSelect"
	            ]
	        }
	    },
	    ListLayout: {
	        backdropColor: {
	            type: "string"
	        },
	        disableBackdrop: {
	            type: "boolean"
	        },
	        groupHeaderPosition: {
	            type: "enum",
	            values: [
	                "left",
	                "top"
	            ]
	        },
	        numberOfItemsPerItemsBlock: {
	            type: "any"
	        },
	        orientation: {
	            type: "enum",
	            values: [
	                "horizontal",
	                "vertical"
	            ]
	        }
	    },
	    ListView: {
	        automaticallyLoadPages: {
	            type: "boolean"
	        },
	        currentItem: {
	            name: "WinJS.UI.IListViewItem",
	            type: "reference",
	            typeArguments: []
	        },
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        footer: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        groupDataSource: {
	            name: "WinJS.UI.IListDataSource",
	            type: "reference",
	            typeArguments: [
	                {
	                    name: "T",
	                    type: "type-param"
	                }
	            ]
	        },
	        groupHeaderTapBehavior: {
	            type: "enum",
	            values: [
	                "invoke",
	                "none"
	            ]
	        },
	        groupHeaderTemplate: {
	            type: "any"
	        },
	        header: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        indexOfFirstVisible: {
	            type: "number"
	        },
	        indexOfLastVisible: {
	            type: "number"
	        },
	        itemDataSource: {
	            name: "WinJS.UI.IListDataSource",
	            type: "reference",
	            typeArguments: [
	                {
	                    name: "T",
	                    type: "type-param"
	                }
	            ]
	        },
	        itemTemplate: {
	            type: "any"
	        },
	        itemsDraggable: {
	            type: "boolean"
	        },
	        itemsReorderable: {
	            type: "boolean"
	        },
	        layout: {
	            name: "WinJS.UI.ILayout2",
	            type: "reference",
	            typeArguments: []
	        },
	        loadingBehavior: {
	            type: "string"
	        },
	        loadingState: {
	            type: "string"
	        },
	        maxDeferredItemCleanup: {
	            type: "number"
	        },
	        maxLeadingPages: {
	            type: "number"
	        },
	        maxTrailingPages: {
	            type: "number"
	        },
	        onAccessibilityAnnotationComplete: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onContentAnimating: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onFooterVisibilityChanged: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onGroupHeaderInvoked: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onHeaderVisibilityChanged: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onItemDragBetween: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onItemDragChanged: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onItemDragDrop: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onItemDragEnd: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onItemDragEnter: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onItemDragLeave: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onItemDragStart: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onItemInvoked: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onKeyboardNavigating: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onLoadingStateChanged: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onSelectionChanged: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onSelectionChanging: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        pagesToLoad: {
	            type: "number"
	        },
	        pagesToLoadThreshold: {
	            type: "number"
	        },
	        scrollPosition: {
	            type: "number"
	        },
	        selection: {
	            name: "WinJS.UI.ISelection",
	            type: "reference",
	            typeArguments: [
	                {
	                    name: "T",
	                    type: "type-param"
	                }
	            ]
	        },
	        selectionMode: {
	            type: "enum",
	            values: [
	                "multi",
	                "none",
	                "single"
	            ]
	        },
	        swipeBehavior: {
	            type: "enum",
	            values: [
	                "none",
	                "select"
	            ]
	        },
	        tapBehavior: {
	            type: "enum",
	            values: [
	                "directSelect",
	                "invokeOnly",
	                "none",
	                "toggleSelect"
	            ]
	        },
	        zoomableView: {
	            name: "WinJS.UI.IZoomableView",
	            type: "reference",
	            typeArguments: [
	                {
	                    name: "WinJS.UI.ListView",
	                    type: "reference",
	                    typeArguments: [
	                        {
	                            name: "T",
	                            type: "type-param"
	                        }
	                    ]
	                }
	            ]
	        }
	    },
	    Menu: {
	        alignment: {
	            type: "string"
	        },
	        anchor: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        commands: {
	            name: "Array",
	            type: "reference",
	            typeArguments: [
	                {
	                    name: "WinJS.UI.MenuCommand",
	                    type: "reference",
	                    typeArguments: []
	                }
	            ]
	        },
	        disabled: {
	            type: "boolean"
	        },
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        hidden: {
	            type: "boolean"
	        },
	        onAfterHide: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onAfterShow: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onBeforeHide: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onBeforeShow: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        placement: {
	            type: "string"
	        }
	    },
	    MenuCommand: {
	        disabled: {
	            type: "boolean"
	        },
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        extraClass: {
	            type: "string"
	        },
	        flyout: {
	            name: "WinJS.UI.Flyout",
	            type: "reference",
	            typeArguments: []
	        },
	        hidden: {
	            type: "boolean"
	        },
	        id: {
	            type: "string"
	        },
	        label: {
	            type: "string"
	        },
	        onClick: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        selected: {
	            type: "boolean"
	        },
	        type: {
	            type: "string"
	        }
	    },
	    NavBar: {
	        closedDisplayMode: {
	            type: "string"
	        },
	        commands: {
	            name: "WinJS.UI.AppBarCommand",
	            type: "reference",
	            typeArguments: []
	        },
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        hidden: {
	            type: "boolean"
	        },
	        onAfterClose: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onAfterOpen: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onBeforeClose: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onBeforeOpen: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onChildrenProcessed: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        opened: {
	            type: "boolean"
	        },
	        placement: {
	            type: "string"
	        }
	    },
	    NavBarCommand: {
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        icon: {
	            type: "string"
	        },
	        label: {
	            type: "string"
	        },
	        location: {
	            type: "any"
	        },
	        onInvoked: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        splitButton: {
	            type: "boolean"
	        },
	        splitOpened: {
	            type: "boolean"
	        },
	        state: {
	            type: "any"
	        },
	        tooltip: {
	            type: "string"
	        }
	    },
	    NavBarContainer: {
	        currentIndex: {
	            type: "number"
	        },
	        data: {
	            name: "WinJS.Binding.List",
	            type: "reference",
	            typeArguments: [
	                {
	                    name: "WinJS.UI.NavBarCommand",
	                    type: "reference",
	                    typeArguments: []
	                }
	            ]
	        },
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        fixedSize: {
	            type: "boolean"
	        },
	        layout: {
	            type: "enum",
	            values: [
	                "horizontal",
	                "vertical"
	            ]
	        },
	        maxRows: {
	            type: "number"
	        },
	        onInvoked: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onSplitToggle: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        template: {
	            name: "WinJS.Binding.Template",
	            type: "reference",
	            typeArguments: []
	        }
	    },
	    Pivot: {
	        customLeftHeader: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        customRightHeader: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        items: {
	            name: "WinJS.Binding.List",
	            type: "reference",
	            typeArguments: [
	                {
	                    name: "WinJS.UI.PivotItem",
	                    type: "reference",
	                    typeArguments: []
	                }
	            ]
	        },
	        locked: {
	            type: "boolean"
	        },
	        onItemAnimationEnd: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onItemAnimationStart: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onSelectionChanged: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        selectedIndex: {
	            type: "number"
	        },
	        selectedItem: {
	            name: "WinJS.UI.PivotItem",
	            type: "reference",
	            typeArguments: []
	        },
	        title: {
	            type: "string"
	        }
	    },
	    PivotItem: {
	        contentElement: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        header: {
	            type: "string"
	        }
	    },
	    Rating: {
	        averageRating: {
	            type: "number"
	        },
	        disabled: {
	            type: "boolean"
	        },
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        enableClear: {
	            type: "boolean"
	        },
	        maxRating: {
	            type: "number"
	        },
	        onCancel: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onChange: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onPreviewChange: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        tooltipStrings: {
	            name: "Array",
	            type: "reference",
	            typeArguments: [
	                {
	                    type: "string"
	                }
	            ]
	        },
	        userRating: {
	            type: "number"
	        }
	    },
	    SearchBox: {
	        chooseSuggestionOnEnter: {
	            type: "boolean"
	        },
	        disabled: {
	            type: "boolean"
	        },
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        focusOnKeyboardInput: {
	            type: "boolean"
	        },
	        onQueryChanged: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onQuerySubmitted: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onResultSuggestionChosen: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onSuggestionsRequested: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        placeholderText: {
	            type: "string"
	        },
	        queryText: {
	            type: "string"
	        },
	        searchHistoryContext: {
	            type: "string"
	        },
	        searchHistoryDisabled: {
	            type: "boolean"
	        }
	    },
	    SemanticZoom: {
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        enableButton: {
	            type: "boolean"
	        },
	        locked: {
	            type: "boolean"
	        },
	        onZoomChanged: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        zoomFactor: {
	            type: "number"
	        },
	        zoomedOut: {
	            type: "boolean"
	        }
	    },
	    SplitView: {
	        closedDisplayMode: {
	            type: "enum",
	            values: [
	                "inline",
	                "none"
	            ]
	        },
	        contentElement: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        onAfterClose: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onAfterOpen: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onBeforeClose: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onBeforeOpen: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        openedDisplayMode: {
	            type: "enum",
	            values: [
	                "inline",
	                "overlay"
	            ]
	        },
	        paneElement: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        paneOpened: {
	            type: "boolean"
	        },
	        panePlacement: {
	            type: "enum",
	            values: [
	                "bottom",
	                "left",
	                "right",
	                "top"
	            ]
	        }
	    },
	    SplitViewCommand: {
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        icon: {
	            type: "string"
	        },
	        label: {
	            type: "string"
	        },
	        onInvoked: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        tooltip: {
	            type: "string"
	        }
	    },
	    SplitViewPaneToggle: {
	        element: {
	            name: "HTMLButtonElement",
	            type: "reference",
	            typeArguments: []
	        },
	        onInvoked: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        splitView: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        }
	    },
	    TimePicker: {
	        clock: {
	            type: "string"
	        },
	        current: {
	            name: "Date",
	            type: "reference",
	            typeArguments: []
	        },
	        disabled: {
	            type: "boolean"
	        },
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        hourPattern: {
	            type: "string"
	        },
	        minuteIncrement: {
	            type: "number"
	        },
	        minutePattern: {
	            type: "string"
	        },
	        onChange: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        periodPattern: {
	            type: "string"
	        }
	    },
	    ToggleSwitch: {
	        checked: {
	            type: "boolean"
	        },
	        disabled: {
	            type: "boolean"
	        },
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        labelOff: {
	            type: "string"
	        },
	        labelOn: {
	            type: "string"
	        },
	        onChange: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        title: {
	            type: "string"
	        }
	    },
	    ToolBar: {
	        closedDisplayMode: {
	            type: "enum",
	            values: [
	                "compact",
	                "full"
	            ]
	        },
	        data: {
	            name: "WinJS.Binding.List",
	            type: "reference",
	            typeArguments: [
	                {
	                    name: "WinJS.UI.ICommand",
	                    type: "reference",
	                    typeArguments: []
	                }
	            ]
	        },
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        onAfterClose: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onAfterOpen: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onBeforeClose: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onBeforeOpen: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        opened: {
	            type: "boolean"
	        }
	    },
	    Tooltip: {
	        contentElement: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        element: {
	            name: "HTMLElement",
	            type: "reference",
	            typeArguments: []
	        },
	        extraClass: {
	            type: "string"
	        },
	        infotip: {
	            type: "boolean"
	        },
	        innerHTML: {
	            type: "string"
	        },
	        onBeforeClose: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onBeforeOpen: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onClosed: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        onOpened: {
	            name: "Function",
	            type: "reference",
	            typeArguments: []
	        },
	        placement: {
	            type: "string"
	        }
	    }
	};
	
	var setImmediate;
	var clearImmediate;
	if (window.setImmediate && window.clearImmediate) {
	    setImmediate = window.setImmediate;
	    clearImmediate = window.clearImmediate;
	} else {
	    setImmediate = function (callback) {
	        return setTimeout(callback, 0);
	    };
	    clearImmediate = window.clearTimeout;
	}
	
	function isEvent(propName) {
	    return propName[0] === "o" && propName[1] === "n";
	}
	
	function mapObject(obj, callback) {
	    var result = {};
	    Object.keys(obj).forEach(function (key) {
	        var value = callback(key, obj[key]);
	        if (value !== undefined) {
	            result[key] = value;
	        }
	    });
	    return result;
	}
	
	function cloneObject(obj) {
	    var result = {};
	    for (k in obj) { result[k] = obj[k]; }
	    return result;
	}
	
	function merge(/* objs */) {
	    var result = {};
	    for (var i = 0, len = arguments.length; i < len; i++) {
	        var obj = arguments[i];
	        if (obj) {
	            for (k in obj) { result[k] = obj[k]; }
	        }
	    }
	    return result;
	}
	
	function endsWith(s, suffix) {
	    return s.length >= suffix.length && s.substr(-suffix.length) === suffix;
	}
	
	function arraysShallowEqual(a, b) {
	    if (a === b) {
	        return true;
	    } else if (a.length !== b.length) {
	        return false;
	    } else {
	        for (var i = 0, len = a.length; i < len; i++) {
	            if (a[i] !== b[i]) {
	                return false;
	            }
	        }
	        return true;
	    }
	}
	
	function nestedSet(obj, path, value) {
	    var parts = path.split(".");
	    var allButLast = parts.slice(0, parts.length - 1);
	    var last = parts[parts.length - 1];
	    var finalObj = allButLast.reduce(function (current, key) {
	        return current[key];
	    }, obj);
	    finalObj[last] = value;
	}
	
	function deparent(element) {
	    var parent = element.parentNode;
	    parent && parent.removeChild(element);
	}
	
	function fireEvent(element, eventName) {
	    var eventObject = document.createEvent("CustomEvent");
	    eventObject.initCustomEvent(
	        eventName,
	        true,  // bubbles
	        false, // cancelable
	        null   // detail
	    );
	    element.dispatchEvent(eventObject);
	}
	
	function makeClassSet(className) {
	    var classSet = {};
	    className && className.split(" ").forEach(function (aClass) {
	        if (aClass) {
	            classSet[aClass] = true;
	        }
	    });
	    return classSet;
	}
	
	function getIn(object, path) {
	    var parts = path.split(".");
	    return parts.reduce(function (current, name) {
	        return current && current[name];
	    }, object);
	}
	
	// Given a type from RawControlApis returns a React propType.
	function typeToPropType(typeInfo) {
	    if (typeInfo.type === "string") {
	        return React.PropTypes.string;
	    } else if (typeInfo.type === "boolean") {
	        return React.PropTypes.bool;
	    } else if (typeInfo.type === "number") {
	        return React.PropTypes.number;
	    } else if (typeInfo.type === "enum") {
	        return React.PropTypes.oneOf(typeInfo.values);
	    } else if (typeInfo.type === "any") {
	        return React.PropTypes.any;
	    } else if (typeInfo.type === "reference") {
	        if (typeInfo.name === "Function") {
	            return React.PropTypes.func;
	        } else if (typeInfo.name === "Array") {
	            var itemPropType = typeToPropType(typeInfo.typeArguments[0]);
	            return itemPropType ? React.PropTypes.arrayOf(itemPropType) : React.PropTypes.array;
	        } else if (getIn(window, typeInfo.name)) {
	            var instance = getIn(window, typeInfo.name);
	            return React.PropTypes.instanceOf(instance);
	        }
	    } else {
	        console.warn("react-winjs typeToPropType: unable to find propType for type: " + JSON.stringify(typeInfo, null, 2));
	    }
	}
	
	// TODO: Revisit all of this diffing stuff:
	//   - Make it more efficient
	//   - It's currently hard to understand because it makes aggressive
	//     assumptions (e.g. each item has a key and each item has a winControl)
	//   - Is it correct?
	//   - Should we just sync an array with a binding list instead of computing
	//     edits based on 2 arrays and then applying them to a binding list?
	function buildIndex(array) {
	    var index = {};
	    array.forEach(function (item, i) {
	        index[item.key] = i;
	    });
	    return index;
	}
	function indexOfKey(array, key) {
	    for (var i = 0; i < array.length; i++) {
	        if (array[i].key === key) {
	            return i;
	        }
	    }
	    return -1;
	}
	function diffArraysByKey(old, latest) {
	    old = old.slice(0);
	    var oldIndex = buildIndex(old);
	    var latestIndex = buildIndex(latest);
	    var edits = [];
	
	    // Handle removals
	    for (i = old.length - 1; i >= 0; i--) {
	        var item = old[i];
	        if (!latestIndex.hasOwnProperty(item.key)) {
	            edits.push({ type: "delete", index: i });
	            old.splice(i, 1);
	        }
	    }
	
	    // Handle insertions and moves
	    for (i = 0; i < latest.length; i++) {
	        var item = latest[i];
	        if (!oldIndex.hasOwnProperty(item.key)) {
	            // Insertion
	            edits.push({ type: "insert", index: i, value: item });
	            old.splice(i, 0, item);
	        } else if (old[i].key !== item.key) {
	            // Move
	            //edits.push({ type: "move", from: oldIndex[item.key], to: i });
	            //old.splice(oldIndex[item.key], 1);
	
	            var fromIndex = indexOfKey(old, item.key);
	            edits.push({ type: "move", from: fromIndex, to: i });
	            old.splice(fromIndex, 1);
	            old.splice(i, 0, item);
	        }
	    }
	
	    return edits;
	}
	function applyEditsToBindingList(list, edits) {
	    edits.forEach(function (edit) {
	        if (edit.type === "delete") {
	            list.splice(edit.index, 1);
	        } else if (edit.type === "insert") {
	            list.splice(edit.index, 0, edit.value.winControl);
	        } else if (edit.type === "move") {
	            list.move(edit.from, edit.to);
	        } else {
	            throw "Unsupported edit type: " + edit.type;
	        }
	    }, this);
	}
	
	// interface IWinJSComponent {
	//     winControl
	//     element
	//     data
	//     displayName
	// }
	
	// interface IWinJSChildComponent extends IWinJSComponent {
	//     key
	//     type
	// }
	
	// Returns a WinJSChildComponent for each component in *children*. Reuses
	// WinJSChildComponents from *childComponentsMap* when possible. Disposes members of
	// *childComponentsMap* if they are no longer needed.
	function processChildren(componentDisplayName, children, childComponentsMap) {
	    var newChildComponents = [];
	    var newChildComponentsMap = {};
	    
	    // A component's *key* represents its identity. If a component in *children* and a
	    // component in *childComponentsMap* have the same *key*, then they are assumed to
	    // represent the same component.
	
	    React.Children.forEach(children, function (component) {
	        if (component) {
	            if (component.ref) {
	                console.warn(
	                    "ref prop (" + component.ref + ") will not work on " +
	                    component.type.displayName + " component because it is inside " +
	                    "of a " + componentDisplayName + " component"
	                );
	            }
	
	            if (component.key === null) {
	                console.error(
	                    component.type.displayName + " component requires a key " +
	                    "when inside of a " + componentDisplayName + " component"
	                );
	            } else {
	                var winjsChildComponent = childComponentsMap[component.key];
	                if (winjsChildComponent) {
	                    if (winjsChildComponent.type === component.type) {
	                        winjsChildComponent.update(component);
	                    } else {
	                        // If a component's *type* has changed then the component must be
	                        // recreated from scratch rather than updated. The reason is that
	                        // the tagName of the underlying DOM element may have changed. The
	                        // only way to change the tagName of the underlying DOM element is
	                        // to instantiate a new react-winjs component.
	                        winjsChildComponent.dispose();
	                        winjsChildComponent = new WinJSChildComponent(component);
	                    }
	                } else {
	                    winjsChildComponent = new WinJSChildComponent(component);
	                }
	                newChildComponents.push(winjsChildComponent);
	                newChildComponentsMap[component.key] = winjsChildComponent;
	            }
	        }
	    });
	
	    Object.keys(childComponentsMap).forEach(function (key) {
	        if (!newChildComponentsMap.hasOwnProperty(key)) {
	            childComponentsMap[key].dispose();
	        }
	    });
	
	    return {
	        childComponents: newChildComponents,
	        childComponentsMap: newChildComponentsMap
	    };
	}
	
	function prefixedProperty(prefix, property) {
	    return prefix + property[0].toUpperCase() + property.substr(1);
	}
	
	var isUnitlessProperty = {
	    flex: true,
	    flexGrow: true,
	    flexPositive: true,
	    flexShrink: true,
	    flexNegative: true,
	    fontWeight: true,
	    lineClamp: true,
	    lineHeight: true,
	    opacity: true,
	    order: true,
	    orphans: true,
	    widows: true,
	    zIndex: true,
	    zoom: true
	};
	var vendorPrefixes = ["Moz", "ms", "Webkit"];
	Object.keys(isUnitlessProperty).forEach(function (property) {
	    vendorPrefixes.forEach(function (prefix) {
	        isUnitlessProperty[prefixedProperty(prefix, property)] = true;
	    });
	});
	
	// Converts the value of a CSS attribute to a string. When certain attributes
	// (e.g. width, height) are specified as numbers, this means adding "px" to the
	// end of the string value.
	function resolveStyleValue(cssProperty, value) {
	    if (typeof value === "number") {
	        return isUnitlessProperty[cssProperty] || value === 0 ?
	            ("" + value) :
	            (value + "px");
	    } else {
	        return value ? ("" + value) : "";
	    }
	}
	
	var PropHandlers = {
	    // Maps to a property on the winControl.
	    property: function (propType) {
	        return {
	            propType: propType,
	            preCtorInit: function property_preCtorInit(element, options, data, displayName, propName, value) {
	                options[propName] = value;
	            },
	            update: function property_update(winjsComponent, propName, oldValue, newValue) {
	                if (oldValue !== newValue) {
	                    winjsComponent.winControl[propName] = newValue;
	                }
	            }
	        };
	    },
	
	    // Maps to a property on the winControl which involves setting focus. Such properties
	    // are set outside of componentWillReceiveProps to prevent React from undoing the
	    // focus move.
	    focusProperty: function (propType) {
	        return {
	            propType: propType,
	            preCtorInit: function focusProperty_preCtorInit(element, options, data, displayName, propName, value) {
	                options[propName] = value;
	            },
	            update: function focusProperty_update(winjsComponent, propName, oldValue, newValue) {
	                if (oldValue !== newValue) {
	                    var asyncToken = winjsComponent.data[propName];
	                    asyncToken && clearImmediate(asyncToken);
	                    asyncToken = setImmediate(function () {
	                        winjsComponent.data[propName] = null;
	                        winjsComponent.winControl[propName] = newValue;
	                    });
	                }
	            },
	            dispose: function focusProperty_dispose(winjsComponent, propName) {
	                var asyncToken = winjsComponent.data[propName];
	                asyncToken && clearImmediate(asyncToken);
	            }
	        };
	    },
	
	    // Maps to a property on the winControl's element.
	    domProperty: function (propType) {
	        return {
	            propType: propType,
	            preCtorInit: function domProperty_preCtorInit(element, options, data, displayName, propName, value) {
	                element[propName] = value;
	            },
	            update: function domProperty_update(winjsComponent, propName, oldValue, newValue) {
	                if (oldValue !== newValue) {
	                    winjsComponent.element[propName] = newValue;
	                }
	            }
	        };
	    },
	
	    // Maps to an attribute on the winControl's element.
	    domAttribute: function (propType) {
	        return {
	            propType: propType,
	            update: function domAttribute_update(winjsComponent, propName, oldValue, newValue) {
	                if (oldValue !== newValue) {
	                    if (newValue !== null && newValue !== undefined) {
	                        winjsComponent.element.setAttribute(propName, "" + newValue);
	                    } else {
	                        winjsComponent.element.removeAttribute(propName);
	                    }
	                }
	            }
	        };
	    },
	
	    // Maps to an event on the winControl.
	    event: {
	        propType: React.PropTypes.func,
	        // Can't set options in preCtorInit for events. The problem is WinJS control options
	        // use a different code path to hook up events than the event property setters.
	        // Consequently, setting an event property will not automatically unhook the event
	        // listener that was specified in the options during initialization. To avoid this
	        // problem, always go thru the event property setters.
	        update: function event_update(winjsComponent, propName, oldValue, newValue) {
	            if (oldValue !== newValue) {
	                winjsComponent.winControl[propName.toLowerCase()] = newValue;
	            }
	        }
	    },
	
	    // Maps to an event on the winControl's element.
	    domEvent: {
	        propType: React.PropTypes.func,
	        preCtorInit: function domEvent_preCtorInit(element, options, data, displayName, propName, value) {
	            element[propName.toLowerCase()] = value;
	        },
	        update: function domEvent_update(winjsComponent, propName, oldValue, newValue) {
	            if (oldValue !== newValue) {
	                winjsComponent.element[propName.toLowerCase()] = newValue;
	            }
	        }
	    },
	
	    //  Enable the addition and removal of CSS classes on the root of the winControl
	    //  but don't clobber whatever CSS classes the underlying control may have added
	    //  (e.g. don't clobber win-listview).
	    winControlClassName: {
	        propType: React.PropTypes.string,
	        preCtorInit: function winControlClassName_preCtorInit(element, options, data, displayName, propName, value) {
	            if (value) {
	                element.className = value;
	            }
	            data[propName] = makeClassSet(value);
	        },
	        update: function winControlClassName_update(winjsComponent, propName, oldValue, newValue) {
	            if (oldValue !== newValue) {
	                var oldClassSet = winjsComponent.data[propName] || {};
	                var newClassSet = makeClassSet(newValue);
	                var elementClassList = winjsComponent.winControl.element.classList;
	                for (var className in oldClassSet) {
	                    if (!newClassSet[className]) {
	                        elementClassList.remove(className);
	                    }
	                }
	                for (var className in newClassSet) {
	                    if (!oldClassSet[className]) {
	                        elementClassList.add(className);
	                    }
	                }
	                winjsComponent.data[propName] = newClassSet;
	            }
	        }
	    },
	
	    //  Enable the addition and removal of inline styles on the root of the winControl
	    //  but don't clobber whatever inline styles the underlying control may have added.
	    winControlStyle: {
	        propType: React.PropTypes.object,
	        preCtorInit: function winControlStyle_preCtorInit(element, options, data, displayName, propName, value) {
	            var elementStyle = element.style;
	            value = value || {};
	            for (var cssProperty in value) {
	                elementStyle[cssProperty] = resolveStyleValue(cssProperty, value[cssProperty]);
	            }
	        },
	        update: function winControlStyle_update(winjsComponent, propName, oldValue, newValue) {
	            if (oldValue !== newValue) {
	                oldValue = oldValue || {};
	                newValue = newValue || {};
	                var elementStyle = winjsComponent.winControl.element.style;
	                for (var cssProperty in oldValue) {
	                    if (!newValue.hasOwnProperty(cssProperty)) {
	                        elementStyle[cssProperty] = "";
	                    }
	                }
	                for (var cssProperty in newValue) {
	                    if (oldValue[cssProperty] !== newValue[cssProperty]) {
	                        elementStyle[cssProperty] = resolveStyleValue(cssProperty, newValue[cssProperty]);
	                    }
	                }
	            }
	        }
	    },
	
	    // Emits a warning to the console whenever prop gets used.
	    warn: function PropHandlers_warn(warnMessage) {
	        return {
	            // Don't need preCtorInit because this prop handler doesn't have any side
	            // effects on the WinJS control. update also runs during initialization so
	            // update is just as good as preCtorInit for our use case.
	            update: function warn_update(winjsComponent, propName, oldValue, newValue) {
	                console.warn(winjsComponent.displayName + ": " + warnMessage);
	            }
	        };
	    },
	
	    // Creates a DOM element and mounts a React component on it. Gives this DOM
	    // element to the *winControlProperty* property of the winControl.
	    propertyWithMount: function PropHandlers_propertyWithMount(winControlProperty) {
	        return {
	            propType: React.PropTypes.element,
	            preCtorInit: function propertyWithMount_preCtorInit(element, options, data, displayName, propName, value) {
	                if (value) {
	                    data[propName] = document.createElement("div");
	                    React.render(value, data[propName]);
	                    options[winControlProperty] = data[propName];
	                }
	            },
	            update: function propertyWithMount_update(winjsComponent, propName, oldValue, newValue) {
	                var winControl = winjsComponent.winControl;
	                var element = winjsComponent.data[propName];
	                if (newValue) {
	                    if (!element) {
	                        element = document.createElement("div");
	                        winjsComponent.data[propName] = element;
	                    }
	                    React.render(newValue, element);
	                    if (winControl[winControlProperty] !== element) {
	                        winControl[winControlProperty] = element;
	                    }
	                } else if (oldValue) {
	                    element && React.unmountComponentAtNode(element);
	                    winControl[winControlProperty] = null;
	                }
	            },
	            dispose: function propertyWithMount_dispose(winjsComponent, propName) {
	                var element = winjsComponent.data[propName];
	                element && React.unmountComponentAtNode(element);
	            }
	        };
	    },
	
	
	    // Mounts a React component on whatever element gets returned by getMountPoint.
	    mountTo: function PropHandlers_mountTo(getMountPoint) {
	        return {
	            propType: React.PropTypes.element,
	            // Can't use preCtorInit because the mount point may not exist until the
	            // constructor has run.
	            update: function mountTo_update(winjsComponent, propName, oldValue, newValue) {
	                var data = winjsComponent.data[propName] || {};
	                var version = (data.version || 0) + 1;
	                winjsComponent.data[propName] = {
	                    // *mountComponent* may run asynchronously and we may queue it multiple
	                    // times before it runs. *version* allows us to ensure only the latest
	                    // version runs and the others are no ops.
	                    version: version,
	                    // *element* is the element to which we last mounted the component.
	                    element: data.element
	                };
	
	                var mountComponent = function () {
	                    if (version === winjsComponent.data[propName].version) {
	                        var oldElement = winjsComponent.data[propName].element;
	
	                        if (newValue) {
	                            var newElement = getMountPoint(winjsComponent);
	                            if (oldElement && oldElement !== newElement) {
	                                React.unmountComponentAtNode(oldElement);
	                            }
	
	                            React.render(newValue, newElement);
	                            winjsComponent.data[propName].element = newElement;
	                        } else if (oldValue) {
	                            oldElement && React.unmountComponentAtNode(oldElement);
	                            winjsComponent.data[propName].element = null;
	                        }
	                    }
	                };
	
	                // *isDeclarativeControlContainer* is a hook some WinJS controls provide
	                // (e.g. HubSection, PivotItem) to ensure that processing runs on the
	                // control only when the control is ready for it. This enables lazy loading
	                // of HubSections/PivotItems (e.g. load off screen items asynchronously in
	                // batches). Additionally, doing processing thru this hook guarantees that
	                // the processing won't run until the control is in the DOM.
	                var winControl = winjsComponent.winControl;
	                var queueProcessing = winControl.constructor.isDeclarativeControlContainer;
	                if (queueProcessing && typeof queueProcessing === "function") {
	                    queueProcessing(winControl, mountComponent);
	                } else {
	                    mountComponent();
	                }
	            },
	            dispose: function mountTo_dispose(winjsComponent, propName) {
	                var data = winjsComponent.data[propName] || {};
	                var element = data.element;
	                element && React.unmountComponentAtNode(element);
	            }
	        };
	    },
	
	    // Uses the Binding.List's editing APIs to make it match the children prop. Does this to
	    // the Binding.List stored in the winControl's property called bindingListName.
	    syncChildrenWithBindingList: function PropHandlers_syncChildrenWithBindingList(bindingListName) {
	        return {
	            preCtorInit: function syncChildrenWithBindingList_preCtorInit(element, options, data, displayName, propName, value) {
	                var latest = processChildren(displayName, value, {});
	                data[propName] = {
	                    winjsChildComponents: latest.childComponents,
	                    winjsChildComponentsMap: latest.childComponentsMap
	                };
	
	                options[bindingListName] = new WinJS.Binding.List(
	                    latest.childComponents.map(function (winjsChildComponent) {
	                        return winjsChildComponent.winControl;
	                    })
	                );
	            },
	            update: function syncChildrenWithBindingList_update(winjsComponent, propName, oldValue, newValue) {
	                var data = winjsComponent.data[propName] || {};
	                var oldChildComponents = data.winjsChildComponents || [];
	                var oldChildComponentsMap = data.winjsChildComponentsMap || {};
	                var latest = processChildren(winjsComponent.displayName, newValue, oldChildComponentsMap);
	
	                var bindingList = winjsComponent.winControl[bindingListName];
	                if (bindingList) {
	                    applyEditsToBindingList(
	                        bindingList,
	                        diffArraysByKey(oldChildComponents, latest.childComponents)
	                    );
	                } else {
	                    winjsComponent.winControl[bindingListName] = new WinJS.Binding.List(latest.childComponents.map(function (winjsChildComponent) {
	                        return winjsChildComponent.winControl;
	                    }));
	                }
	                
	                winjsComponent.data[propName] = {
	                    winjsChildComponents: latest.childComponents,
	                    winjsChildComponentsMap: latest.childComponentsMap
	                };
	            },
	            dispose: function syncChildrenWithBindingList_dispose(winjsComponent, propName) {
	                var data = winjsComponent.data[propName] || {};
	                var childComponents = data.winjsChildComponents || [];
	                childComponents.forEach(function (winjsChildComponent) {
	                    winjsChildComponent.dispose();
	                });
	            }
	        }
	    }
	};
	
	function defineControl(options) {
	    // Required
	    var winjsControl = options.winjsControl;
	
	    // Optional
	    var winControlOptions = options.winControlOptions || {};
	    var preCtorInit = options.preCtorInit || function () { };
	    var propHandlers = options.propHandlers || {};
	    var render = options.render || function (component) {
	        return React.DOM.div();
	    };
	    var displayName = options.displayName;
	
	    function initWinJSComponent(winjsComponent, element, props) {
	        winjsComponent.data = {};
	        winjsComponent.displayName = displayName;
	        winjsComponent.element = element;
	
	        // Give propHandlers that implement preCtorInit the opportunity to run before
	        // instantiating the winControl.
	        var options = cloneObject(winControlOptions);
	        preCtorInit(element, options, winjsComponent.data, displayName);
	        Object.keys(props).forEach(function (propName) {
	            var handler = propHandlers[propName];
	            if (handler && handler.preCtorInit) {
	                handler.preCtorInit(element, options, winjsComponent.data, displayName, propName, props[propName]);
	            }
	        });
	        winjsComponent.winControl = new winjsControl(element, options);        
	
	        // Process propHandlers that don't implement preCtorInit.
	        Object.keys(props).forEach(function (propName) {
	            var handler = propHandlers[propName];
	            if (handler && !handler.preCtorInit) {
	                handler.update(winjsComponent, propName, undefined, props[propName]);
	            }
	        });
	    }
	
	    function updateWinJSComponent(winjsComponent, prevProps, nextProps) {
	        // Handle props that were added or changed
	        Object.keys(nextProps).forEach(function (propName) {
	            var handler = propHandlers[propName];
	            if (handler) {
	                handler.update(winjsComponent, propName, prevProps[propName], nextProps[propName]);
	            }
	        });
	
	        // Handle props that were removed
	        Object.keys(prevProps).forEach(function (propName) {
	            if (!nextProps.hasOwnProperty(propName)) {
	                var handler = propHandlers[propName];
	                if (handler) {
	                    handler.update(winjsComponent, propName, prevProps[propName], undefined);
	                }
	            }
	        });
	    }
	
	    function disposeWinJSComponent(winjsComponent) {
	        winjsComponent.winControl.dispose && winjsComponent.winControl.dispose();
	        Object.keys(propHandlers).forEach(function (propName) {
	            var handler = propHandlers[propName];
	            handler.dispose && handler.dispose(winjsComponent, propName);
	        })
	    }
	
	    return React.createClass({
	        displayName: displayName,
	        statics: {
	            initWinJSComponent: initWinJSComponent,
	            updateWinJSComponent: updateWinJSComponent,
	            disposeWinJSComponent: disposeWinJSComponent
	        },
	        propTypes: mapObject(propHandlers, function (propName, propHandler) {
	            return propHandler.propType;
	        }),
	        shouldComponentUpdate: function () {
	            return false;
	        },
	        // If choosing to implement componentWillMount, be aware that componentWillMount
	        // will run when WinJSChildComponent renders the component to a string via
	        // renderRootlessComponent.
	        componentDidMount: function () {
	            initWinJSComponent(this, React.findDOMNode(this), this.props);
	        },
	        componentWillUnmount: function () {
	            disposeWinJSComponent(this);
	        },
	        componentWillReceiveProps: function (nextProps) {
	            updateWinJSComponent(this, this.props, nextProps);
	        },
	        render: function() {
	            return render(this);
	        }
	    });
	}
	
	var hostEl = document.createElement("div");
	function renderRootlessComponent(component) {
	    var html = React.renderToStaticMarkup(component);
	    hostEl.innerHTML = html;
	    var element = hostEl.firstElementChild;
	    hostEl.removeChild(element);
	    return element;
	}
	
	// TODO: Is there a better way to solve this problem that WinJSChildComponent solves?
	// TODO: Because we're not going thru React's lifecycle, we're missing out on
	// validation of propTypes.
	// TODO: ref doesn't work on WinJSChildComponents. The reason is that during updates, we
	// don't call React.render. Because of this, refs would go stale and only reflect the
	// state of the component after its first render. Consequently, we clone the component
	// during its first render so it never shows up in refs. This should make it clearer
	// that refs don't work than generating stale refs.
	function WinJSChildComponent(component) { // implements IWinJSChildComponent
	    // Clone the component so a ref isn't generated.
	    var clonedComponent = React.cloneElement(component, { ref: null });
	    var element = renderRootlessComponent(clonedComponent);
	    component.type.initWinJSComponent(this, element, component.props);
	    this.key = component.key;
	    this.type = component.type;
	    this._props = component.props;
	    this._disposeWinJSComponent = component.type.disposeWinJSComponent;
	};
	WinJSChildComponent.prototype.update = function (component) {
	    component.type.updateWinJSComponent(this, this._props, component.props);
	    this._props = component.props;
	};
	WinJSChildComponent.prototype.dispose = function () {
	    this._disposeWinJSComponent(this);
	};
	
	
	// Prop handlers that are common to every WinJS control.
	var defaultPropHandlers = {
	    className: PropHandlers.winControlClassName,
	    style: PropHandlers.winControlStyle,
	
	    // TODO: Instead of special casing these, support DOM attributes
	    // more generically.
	    id: PropHandlers.domProperty(React.PropTypes.string),
	    "aria-controls": PropHandlers.domAttribute(React.PropTypes.any),
	    "aria-expanded": PropHandlers.domAttribute(React.PropTypes.any)
	};
	
	// Control-specific prop handlers derived from RawControlApis
	var DefaultControlPropHandlers = (function processRawApis() {
	    var keepProperty = function keepProperty(propertyName) {
	        return !endsWith(propertyName.toLowerCase(), "element");
	    };
	
	    return mapObject(RawControlApis, function (controlName, controlApis) {
	        var propHandlers = {};
	        Object.keys(controlApis).forEach(function (propName) {
	            if (isEvent(propName)) {
	                propHandlers[propName] = PropHandlers.event;
	            } else if (keepProperty(propName)) {
	                var typeInfo = controlApis[propName];
	                var propType = typeToPropType(typeInfo);
	                propHandlers[propName] = PropHandlers.property(propType);
	            }
	        });
	        return propHandlers;
	    });
	})();
	
	// Each entry in controlApis has the same format as the argument to defineControl except
	// updateWithDefaults automatically provides:
	//   - winjsControl
	//   - displayName
	//   - propHandlers
	// and updateWithDefaults implements an extra option:
	//   - underlyingControlName
	// By default, winjsControl, displayName, and propHanders are inferred from the entry's key
	// in controlApis. If underlyingControlName is provided, they will instead be inferred from
	// that name.
	function updateWithDefaults(controlApis) {
	    Object.keys(controlApis).forEach(function (controlName) {
	        var spec = controlApis[controlName];
	        var winjsControlName = spec.underlyingControlName || controlName;
	        spec.winjsControl = spec.winjsControl || WinJS.UI[winjsControlName];
	        spec.displayName = spec.displayName || winjsControlName;
	        spec.propHandlers = merge(
	            defaultPropHandlers, // Common to all WinJS controls
	            DefaultControlPropHandlers[winjsControlName], // Control-specific derived from RawControlApis
	            spec.propHandlers // Control-specific handwritten
	        );
	    });
	    return controlApis;
	}
	
	var typeWarnPropHandler = PropHandlers.warn("Invalid prop 'type'. Instead, the command type is" +
	    " determined by the component: Button, Toggle, Separator, ContentCommand, FlyoutCommand.");
	var CommandSpecs = {
	    Button: {
	        underlyingControlName: "AppBarCommand",
	        winControlOptions: { type: "button" },
	        render: function (component) {
	            return React.DOM.button();
	        },
	        propHandlers: {
	            type: typeWarnPropHandler,
	        }
	    },
	    Toggle: {
	        underlyingControlName: "AppBarCommand",
	        winControlOptions: { type: "toggle" },
	        render: function (component) {
	            return React.DOM.button();
	        },
	        propHandlers: {
	            type: typeWarnPropHandler
	        }
	    },
	    Separator: {
	        underlyingControlName: "AppBarCommand",
	        winControlOptions: { type: "separator" },
	        render: function (component) {
	            return React.DOM.hr();
	        },
	        propHandlers: {
	            type: typeWarnPropHandler
	        }
	    },
	    ContentCommand: {
	        underlyingControlName: "AppBarCommand",
	        winControlOptions: { type: "content" },
	        propHandlers: {
	            type: typeWarnPropHandler,
	            children: PropHandlers.mountTo(function (winjsComponent) {
	                return winjsComponent.winControl.element;
	            })
	        }
	    },
	    FlyoutCommand: {
	        underlyingControlName: "AppBarCommand",
	        winControlOptions: { type: "flyout" },
	        render: function (component) {
	            return React.DOM.button();
	        },
	        propHandlers: {
	            type: typeWarnPropHandler,
	            flyoutComponent: {
	                propType: React.PropTypes.element,
	                update: function FlyoutCommand_flyoutComponent_update(winjsComponent, propName, oldValue, newValue) {
	                    var data = winjsComponent.data[propName];
	                    if (!data) {
	                        var flyoutHost = document.createElement("div");
	                        flyoutHost.className = "win-react-flyout-host";
	                        document.body.appendChild(flyoutHost);
	                        winjsComponent.data[propName] = data = {
	                            flyoutHost: flyoutHost,
	                            flyoutComponent: null
	                        };
	                    }
	                    var oldWinControl = data.flyoutComponent && data.flyoutComponent.winControl;
	                    var instance = React.render(newValue, data.flyoutHost);
	                    if (oldWinControl !== instance.winControl) {
	                        winjsComponent.winControl.flyout = instance.winControl;
	                    }
	                    winjsComponent.data[propName].flyoutComponent = instance;
	                },
	                dispose: function FlyoutCommand_flyoutComponent_dispose(winjsComponent, propName) {
	                    var data = winjsComponent.data[propName];
	                    if (data && data.flyoutHost) {
	                        React.unmountComponentAtNode(data.flyoutHost);
	                        deparent(data.flyoutHost);
	                    }
	                }
	            }
	        }
	    }
	};
	
	var ControlApis = updateWithDefaults({
	    AppBar: {
	        propHandlers: {
	            opened: PropHandlers.focusProperty(React.PropTypes.bool),
	            children: PropHandlers.syncChildrenWithBindingList("data")
	        }
	    },
	    "AppBar.Button": CommandSpecs.Button,
	    "AppBar.Toggle": CommandSpecs.Toggle,
	    "AppBar.Separator": CommandSpecs.Separator,
	    "AppBar.ContentCommand": CommandSpecs.ContentCommand,
	    "AppBar.FlyoutCommand": CommandSpecs.FlyoutCommand,
	    AutoSuggestBox: {},
	    BackButton: {
	        preCtorInit: function (element, options, data, displayName) {
	            element.addEventListener("click", function (eventObject) {
	                // Prevent React from seeing the "click" event to workaround this React
	                // bug: https://github.com/facebook/react/issues/3790
	                eventObject.stopPropagation();
	            });
	        },
	        render: function (component) {
	            return React.DOM.button();
	        }
	    },
	    // CellSpanningLayout: Not a component so just use off of WinJS.UI?
	    ContentDialog: {
	        propHandlers: {
	            hidden: PropHandlers.focusProperty(React.PropTypes.bool),
	            children: PropHandlers.mountTo(function (winjsComponent) {
	                return winjsComponent.winControl.element.querySelector(".win-contentdialog-content");
	            })
	        }
	    },
	    DatePicker: {},
	    FlipView: {},
	    Flyout: {
	        // The WinJS Flyout control doesn't come with a good mount point.
	        // App content and control content are siblings in Flyout.element.
	        // Consequently, if React rendered to Flyout.element, it would destroy
	        // some of Flyout's elements. To fix this, we give Flyout a div
	        // (className="win-react-flyout-mount-point") which will contain only
	        // app content. The React component renders into this div so it doesn't
	        // destroy any control content.
	        render: function (component) {
	            return React.DOM.div(null, React.DOM.div({ className: "win-react-flyout-mount-point" }));
	        },
	        propHandlers: {
	            hidden: PropHandlers.focusProperty(React.PropTypes.bool),
	            children: PropHandlers.mountTo(function (winjsComponent) {
	                return winjsComponent.winControl.element.querySelector(".win-react-flyout-mount-point");
	            })
	        }
	    },
	    // GridLayout: Not a component so just use off of WinJS.UI?
	    Hub: {
	        propHandlers: {
	            children: PropHandlers.syncChildrenWithBindingList("sections")
	        }
	    },
	    "Hub.Section": {
	        underlyingControlName: "HubSection",
	        propHandlers: {
	            children: PropHandlers.mountTo(function (winjsComponent) {
	                return winjsComponent.winControl.contentElement;
	            })
	        }
	    },
	    ItemContainer: {
	        propHandlers: {
	            children: PropHandlers.mountTo(function (winjsComponent) {
	                return winjsComponent.winControl.element.querySelector(".win-item");
	            })
	        }
	    },
	    // ListLayout: Not a component so just use off of WinJS.UI?
	    ListView: {
	        propHandlers: {
	            currentItem: PropHandlers.focusProperty(React.PropTypes.any),
	            headerComponent: PropHandlers.propertyWithMount("header"),
	            footerComponent: PropHandlers.propertyWithMount("footer"),
	        }
	    },
	    // TODO: Keyboarding doesn't work in Menu probably because MenuCommands are not direct
	    // children of the Menu.
	    Menu: {
	        propHandlers: {
	            hidden: PropHandlers.focusProperty(React.PropTypes.bool),
	            children: {
	                // children propHandler looks like this rather than using mountTo on
	                // winControl.element because this enables props.children to have
	                // multiple components whereas the other technique restricts it to one.
	                update: function (winjsComponent, propName, oldValue, newValue) {
	                    // TODO: dispose
	                    React.render(React.DOM.div(null, newValue), winjsComponent.winControl.element);
	                }
	            }
	        }
	    },
	    "Menu.Button": merge(CommandSpecs.Button, {
	        underlyingControlName: "MenuCommand"
	    }),
	    "Menu.Toggle": merge(CommandSpecs.Toggle, {
	        underlyingControlName: "MenuCommand"
	    }),
	    "Menu.Separator": merge(CommandSpecs.Separator, {
	        underlyingControlName: "MenuCommand"
	    }),
	    "Menu.FlyoutCommand": merge(CommandSpecs.FlyoutCommand, {
	        underlyingControlName: "MenuCommand"
	    }),
	    Pivot: {
	        propHandlers: {
	            children: PropHandlers.syncChildrenWithBindingList("items"),
	            customLeftHeaderComponent: PropHandlers.propertyWithMount("customLeftHeader"),
	            customRightHeaderComponent: PropHandlers.propertyWithMount("customRightHeader")
	        }
	    },
	    "Pivot.Item": {
	        underlyingControlName: "PivotItem",
	        propHandlers: {
	            children: PropHandlers.mountTo(function (winjsComponent) {
	                return winjsComponent.winControl.contentElement;
	            })
	        }
	    },
	    Rating: {},
	    SemanticZoom: {
	        propHandlers: {
	            zoomedInComponent: {
	                propType: React.PropTypes.element,
	                preCtorInit: function zoomedInComponent_preCtorInit(element, options, data, displayName, propName, value) {
	                    var child = new WinJSChildComponent(value);
	                    // Zoomed in component should be the first child.
	                    element.insertBefore(child.winControl.element, element.firstElementChild);
	                    data[propName] = child;
	                },
	                update: function zoomedInComponent_update(winjsComponent, propName, oldValue, newValue) {
	                    var child = winjsComponent.data[propName];
	                    if (child.type === newValue.type) {
	                        child.update(newValue);
	                    } else {
	                        console.warn("SemanticZoom: zoomedInComponent's component type can't change");
	                    }
	                },
	                dispose: function zoomedInComponent_dispose(winjsComponent, propName) {
	                    var child = winjsComponent.data[propName];
	                    child && child.dispose();
	                }
	            },
	            zoomedOutComponent: {
	                propType: React.PropTypes.element,
	                preCtorInit: function zoomedOutComponent_preCtorInit(element, options, data, displayName, propName, value) {
	                    var child = new WinJSChildComponent(value);
	                    // Zoomed out component should be the second child.
	                    element.appendChild(child.winControl.element);
	                    data[propName] = child;
	                },
	                update: function zoomedOutComponent_update(winjsComponent, propName, oldValue, newValue) {
	                    var child = winjsComponent.data[propName];
	                    if (child.type === newValue.type) {
	                        child.update(newValue);
	                    } else {
	                        console.warn("SemanticZoom: zoomedOutComponent's component type can't change");
	                    }
	                },
	                dispose: function zoomedOutComponent_dispose(winjsComponent, propName) {
	                    var child = winjsComponent.data[propName];
	                    child && child.dispose();
	                }
	            }
	        }
	    },
	    SplitView: {
	        propHandlers: {
	            paneOpened: PropHandlers.focusProperty(React.PropTypes.bool),
	            paneComponent: PropHandlers.mountTo(function (winjsComponent) {
	                return winjsComponent.winControl.paneElement;
	            }),
	            contentComponent: PropHandlers.mountTo(function (winjsComponent) {
	                return winjsComponent.winControl.contentElement;
	            })
	        }
	    },
	    "SplitView.Command": {
	        underlyingControlName: "SplitViewCommand",
	    },
	    SplitViewPaneToggle: {
	        render: function (component) {
	            return React.DOM.button();
	        },
	        propHandlers: {
	            // paneOpened provides a React-friendly interface for making the SplitViewPaneToggle accessible.
	            // When paneOpened is specified, is not undefined, and is not null, it:
	            //  - Sets SplitViewPaneToggle's aria-expanded attribute to match paneOpened
	            //  - Fires SplitViewPaneToggle's "invoked" event when aria-expanded is mutated
	            paneOpened: {
	                propType: React.PropTypes.bool,
	                update: function paneOpened_update(winjsComponent, propName, oldValue, newValue) {
	                    var data = winjsComponent.data[propName];
	                    if (!data) {
	                        data = {
	                            // WinJS.UI.SplitViewPaneToggle depends on WinJS.Utilities._MutationObserver so it
	                            // is safe to use it here.
	                            ariaExpandedMutationObserver: new WinJS.Utilities._MutationObserver(function () {
	                                var element = winjsComponent.element;
	                                var ariaExpanded = (element.getAttribute("aria-expanded") === "true");
	                                if (ariaExpanded !== winjsComponent.data[propName].value) {
	                                    fireEvent(element, "invoked"); // Fire WinJS.UI.SplitViewPaneToggle's invoked event
	                                }
	                            }),
	                            observing: false,
	                            value: newValue
	                        };
	                        winjsComponent.data[propName] = data;
	                    }
	
	                    if (oldValue !== newValue) {
	                        if (newValue !== null && newValue !== undefined) {
	                            winjsComponent.element.setAttribute("aria-expanded", newValue ? "true" : "false");
	                            if (!data.observing) {
	                                data.observing = true;
	                                data.ariaExpandedMutationObserver.observe(winjsComponent.element, {
	                                    attributes: true,
	                                    attributeFilter: ["aria-expanded"]
	                                });
	                            }
	                        } else {
	                            winjsComponent.element.removeAttribute("aria-expanded");
	                            if (data.observing) {
	                                data.observing = false;
	                                data.ariaExpandedMutationObserver.disconnect();
	                            }
	                        }
	                    }
	
	                    data.value = newValue;
	                },
	                dispose: function paneOpened_dispose(winjsComponent, propName) {
	                    var data = winjsComponent.data[propName];
	                    if (data && data.observing) {
	                        data.ariaExpandedMutationObserver.disconnect();
	                    }
	                }
	            }
	        }
	    },
	    TimePicker: {},
	    ToggleSwitch: {},
	    ToolBar: {
	        propHandlers: {
	            opened: PropHandlers.focusProperty(React.PropTypes.bool),
	            children: PropHandlers.syncChildrenWithBindingList("data")
	        }
	    },
	    "ToolBar.Button": CommandSpecs.Button,
	    "ToolBar.Toggle": CommandSpecs.Toggle,
	    "ToolBar.Separator": CommandSpecs.Separator,
	    "ToolBar.ContentCommand": CommandSpecs.ContentCommand,
	    "ToolBar.FlyoutCommand": CommandSpecs.FlyoutCommand,
	    Tooltip: {
	        propHandlers: {
	            children: PropHandlers.mountTo(function (winjsComponent) {
	                return winjsComponent.winControl.element;
	            }),
	            contentComponent: PropHandlers.propertyWithMount("contentElement")
	        }
	    }
	});
	
	//
	// Publish
	//
	
	var ReactWinJS = {};
	
	// Controls
	//
	
	// Sort to ensure that controls come before their subcontrols
	// (e.g. AppBar comes before AppBar.Toggle).
	Object.keys(ControlApis).sort().forEach(function (controlName) {
	    nestedSet(ReactWinJS, controlName, defineControl(ControlApis[controlName]));
	});
	
	// Utilites
	//
	
	// Given a function that returns a React component,
	// returns an item renderer function that can be used
	// with WinJS controls. Useful for describing FlipView
	// and ListView item templates as React components.
	ReactWinJS.reactRenderer = function reactRenderer(componentFunction) {
	    var componentFunctionBound;
	    var renderItem = function renderItem(item) {
	        var element = document.createElement("div");
	        element.className = "win-react-renderer-host";
	        React.render(componentFunctionBound(item), element);
	        WinJS.Utilities.markDisposable(element, function () {
	            React.unmountComponentAtNode(element);
	        });
	        return element;
	    };
	
	    return function itemRenderer(itemOrItemPromise) {
	        if (!componentFunctionBound) {
	            componentFunctionBound = componentFunction.bind(this);
	        }
	
	        return WinJS.Promise.is(itemOrItemPromise) ?
	            itemOrItemPromise.then(renderItem) :
	            renderItem(itemOrItemPromise);
	    }
	};
	
	
	// Low-level utilities for wrapping custom WinJS-style controls
	//
	
	ReactWinJS.defineControl = defineControl;
	ReactWinJS.PropHandlers = PropHandlers;
	ReactWinJS.defaultPropHandlers = defaultPropHandlers;
	
	module.exports = ReactWinJS;


/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * @providesModule ReactModal
	 */
	'use strict';
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _ReactStyleSheet = __webpack_require__(154);
	
	var _ReactStyleSheet2 = _interopRequireDefault(_ReactStyleSheet);
	
	var _ReactView = __webpack_require__(164);
	
	var _ReactView2 = _interopRequireDefault(_ReactView);
	
	var Modal = (function (_Component) {
	  _inherits(Modal, _Component);
	
	  function Modal() {
	    _classCallCheck(this, Modal);
	
	    _get(Object.getPrototypeOf(Modal.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(Modal, [{
	    key: 'render',
	    value: function render() {
	      if (this.props.visible === false) {
	        if (this.shown) {
	          this.props.onDismiss && this.props.onDismiss();
	        }
	        this.shown = false;
	        return null;
	      }
	
	      this.shown = true;
	
	      if (this.props.transparent) {
	        var modalBackgroundColor = { backgroundColor: 'transparent' };
	      }
	
	      return _react2['default'].createElement(
	        _ReactView2['default'],
	        { style: [styles.modal, modalBackgroundColor] },
	        _react2['default'].createElement(
	          _ReactView2['default'],
	          { style: [styles.container] },
	          this.props.children
	        )
	      );
	    }
	  }]);
	
	  return Modal;
	})(_react.Component);
	
	Modal.propTypes = {
	  animated: _react.PropTypes.bool,
	  transparent: _react.PropTypes.bool,
	  onDismiss: _react.PropTypes.func
	};
	
	var styles = _ReactStyleSheet2['default'].create({
	  modal: {
	    position: 'fixed',
	    left: 0,
	    right: 0,
	    bottom: 0,
	    top: 0,
	    backgroundColor: '#fff',
	    zIndex: 9999
	  },
	  container: {
	    position: 'absolute',
	    left: 0,
	    right: 0,
	    bottom: 0,
	    top: 0
	  }
	});
	
	module.exports = Modal;

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015, Facebook, Inc.  All rights reserved.
	 *
	 * @providesModule ReactNavigator
	 */
	/* eslint-disable no-extra-boolean-cast*/
	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _ReactDimensions = __webpack_require__(247);
	
	var _ReactDimensions2 = _interopRequireDefault(_ReactDimensions);
	
	var _ReactInteractionMixin = __webpack_require__(257);
	
	var _ReactInteractionMixin2 = _interopRequireDefault(_ReactInteractionMixin);
	
	var _coreJsLibraryFnMap = __webpack_require__(258);
	
	var _coreJsLibraryFnMap2 = _interopRequireDefault(_coreJsLibraryFnMap);
	
	var _ReactNavigationContext = __webpack_require__(261);
	
	var _ReactNavigationContext2 = _interopRequireDefault(_ReactNavigationContext);
	
	var _ReactNavigatorBreadcrumbNavigationBar = __webpack_require__(271);
	
	var _ReactNavigatorBreadcrumbNavigationBar2 = _interopRequireDefault(_ReactNavigatorBreadcrumbNavigationBar);
	
	var _ReactNavigatorNavigationBar = __webpack_require__(280);
	
	var _ReactNavigatorNavigationBar2 = _interopRequireDefault(_ReactNavigatorNavigationBar);
	
	var _ReactNavigatorSceneConfigs = __webpack_require__(281);
	
	var _ReactNavigatorSceneConfigs2 = _interopRequireDefault(_ReactNavigatorSceneConfigs);
	
	var _ReactPanResponder = __webpack_require__(240);
	
	var _ReactPanResponder2 = _interopRequireDefault(_ReactPanResponder);
	
	var _ReactStyleSheet = __webpack_require__(154);
	
	var _ReactStyleSheet2 = _interopRequireDefault(_ReactStyleSheet);
	
	var _polyfillsSubscribable = __webpack_require__(283);
	
	var _polyfillsSubscribable2 = _interopRequireDefault(_polyfillsSubscribable);
	
	var _reactTimerMixin = __webpack_require__(284);
	
	var _reactTimerMixin2 = _interopRequireDefault(_reactTimerMixin);
	
	var _ReactView = __webpack_require__(164);
	
	var _ReactView2 = _interopRequireDefault(_ReactView);
	
	var _polyfillsClamp = __webpack_require__(285);
	
	var _polyfillsClamp2 = _interopRequireDefault(_polyfillsClamp);
	
	var _ReactFlattenStyle = __webpack_require__(162);
	
	var _ReactFlattenStyle2 = _interopRequireDefault(_ReactFlattenStyle);
	
	var _fbjsLibInvariant = __webpack_require__(231);
	
	var _fbjsLibInvariant2 = _interopRequireDefault(_fbjsLibInvariant);
	
	var _rebound = __webpack_require__(286);
	
	var _rebound2 = _interopRequireDefault(_rebound);
	
	var _ReactSetNativeProps = __webpack_require__(279);
	
	var _ReactSetNativeProps2 = _interopRequireDefault(_ReactSetNativeProps);
	
	var _historyLibCreateHashHistory = __webpack_require__(289);
	
	var _historyLibCreateHashHistory2 = _interopRequireDefault(_historyLibCreateHashHistory);
	
	var history = (0, _historyLibCreateHashHistory2['default'])();
	var _unlisten;
	
	// TODO: this is not ideal because there is no guarantee that the navigator
	// is full screen, hwoever we don't have a good way to measure the actual
	// size of the navigator right now, so this is the next best thing.
	var SCREEN_WIDTH = _ReactDimensions2['default'].get('window').width;
	var SCREEN_HEIGHT = _ReactDimensions2['default'].get('window').height;
	var SCENE_DISABLED_NATIVE_PROPS = {
	  pointerEvents: 'none',
	  style: {
	    top: SCREEN_HEIGHT,
	    bottom: -SCREEN_HEIGHT,
	    opacity: 0
	  }
	};
	
	var __uid = 0;
	function getuid() {
	  return __uid++;
	}
	
	function getRouteID(route) {
	  if (route === null || typeof route !== 'object') {
	    return String(route);
	  }
	
	  var key = '__navigatorRouteID';
	
	  if (!route.hasOwnProperty(key)) {
	    Object.defineProperty(route, key, {
	      enumerable: false,
	      configurable: false,
	      writable: false,
	      value: getuid()
	    });
	  }
	  return route[key];
	}
	
	// styles moved to the top of the file so getDefaultProps can refer to it
	var styles = _ReactStyleSheet2['default'].create({
	  container: {
	    flex: 1,
	    overflow: 'hidden'
	  },
	  defaultSceneStyle: {
	    position: 'absolute',
	    left: 0,
	    right: 0,
	    bottom: 0,
	    top: 0
	  },
	  baseScene: {
	    position: 'absolute',
	    overflow: 'hidden',
	    left: 0,
	    right: 0,
	    bottom: 0,
	    top: 0
	  },
	  disabledScene: {
	    top: SCREEN_HEIGHT,
	    bottom: -SCREEN_HEIGHT
	  },
	  transitioner: {
	    flex: 1,
	    backgroundColor: 'transparent',
	    overflow: 'hidden'
	  }
	});
	
	var GESTURE_ACTIONS = ['pop', 'jumpBack', 'jumpForward'];
	
	/**
	 * Use `Navigator` to transition between different scenes in your app. To
	 * accomplish this, provide route objects to the navigator to identify each
	 * scene, and also a `renderScene` function that the navigator can use to
	 * render the scene for a given route.
	 *
	 * To change the animation or gesture properties of the scene, provide a
	 * `configureScene` prop to get the config object for a given route. See
	 * `Navigator.SceneConfigs` for default animations and more info on
	 * scene config options.
	 *
	 * ### Basic Usage
	 *
	 * ```
	 *   <Navigator
	 *     initialRoute={{name: 'My First Scene', index: 0}}
	 *     renderScene={(route, navigator) =>
	 *       <MySceneComponent
	 *         name={route.name}
	 *         onForward={() => {
	 *           var nextIndex = route.index + 1;
	 *           navigator.push({
	 *             name: 'Scene ' + nextIndex,
	 *             index: nextIndex,
	 *           });
	 *         }}
	 *         onBack={() => {
	 *           if (route.index > 0) {
	 *             navigator.pop();
	 *           }
	 *         }}
	 *       />
	 *     }
	 *   />
	 * ```
	 *
	 * ### Navigator Methods
	 *
	 * If you have a ref to the Navigator element, you can invoke several methods
	 * on it to trigger navigation:
	 *
	 *  - `getCurrentRoutes()` - returns the current list of routes
	 *  - `jumpBack()` - Jump backward without unmounting the current scene
	 *  - `jumpForward()` - Jump forward to the next scene in the route stack
	 *  - `jumpTo(route)` - Transition to an existing scene without unmounting
	 *  - `push(route)` - Navigate forward to a new scene, squashing any scenes
	 *     that you could `jumpForward` to
	 *  - `pop()` - Transition back and unmount the current scene
	 *  - `replace(route)` - Replace the current scene with a new route
	 *  - `replaceAtIndex(route, index)` - Replace a scene as specified by an index
	 *  - `replacePrevious(route)` - Replace the previous scene
	 *  - `immediatelyResetRouteStack(routeStack)` - Reset every scene with an
	 *     array of routes
	 *  - `popToRoute(route)` - Pop to a particular scene, as specified by its
	 *     route. All scenes after it will be unmounted
	 *  - `popToTop()` - Pop to the first scene in the stack, unmounting every
	 *     other scene
	 *
	 */
	var Navigator = _react2['default'].createClass({
	  displayName: 'Navigator',
	
	  propTypes: {
	    /**
	     * Optional function that allows configuration about scene animations and
	     * gestures. Will be invoked with the route and should return a scene
	     * configuration object
	     *
	     * ```
	     * (route) => Navigator.SceneConfigs.FloatFromRight
	     * ```
	     */
	    configureScene: _react.PropTypes.func,
	
	    /**
	     * Required function which renders the scene for a given route. Will be
	     * invoked with the route and the navigator object
	     *
	     * ```
	     * (route, navigator) =>
	     *   <MySceneComponent title={route.title} />
	     * ```
	     */
	    renderScene: _react.PropTypes.func.isRequired,
	
	    /**
	     * Specify a route to start on. A route is an object that the navigator
	     * will use to identify each scene to render. `initialRoute` must be
	     * a route in the `initialRouteStack` if both props are provided. The
	     * `initialRoute` will default to the last item in the `initialRouteStack`.
	     */
	    initialRoute: _react.PropTypes.object,
	
	    /**
	     * Provide a set of routes to initially mount. Required if no initialRoute
	     * is provided. Otherwise, it will default to an array containing only the
	     * `initialRoute`
	     */
	    initialRouteStack: _react.PropTypes.arrayOf(_react.PropTypes.object),
	
	    /**
	     * @deprecated
	     * Use `navigationContext.addListener('willfocus', callback)` instead.
	     *
	     * Will emit the target route upon mounting and before each nav transition
	     */
	    onWillFocus: _react.PropTypes.func,
	
	    /**
	     * @deprecated
	     * Use `navigationContext.addListener('didfocus', callback)` instead.
	     *
	     * Will be called with the new route of each scene after the transition is
	     * complete or after the initial mounting
	     */
	    onDidFocus: _react.PropTypes.func,
	
	    /**
	     * Optionally provide a navigation bar that persists across scene
	     * transitions
	     */
	    navigationBar: _react.PropTypes.node,
	
	    /**
	     * Optionally provide the navigator object from a parent Navigator
	     */
	    navigator: _react.PropTypes.object,
	
	    /**
	     * Styles to apply to the container of each scene
	     */
	    sceneStyle: _ReactView2['default'].propTypes.style
	  },
	
	  statics: {
	    BreadcrumbNavigationBar: _ReactNavigatorBreadcrumbNavigationBar2['default'],
	    NavigationBar: _ReactNavigatorNavigationBar2['default'],
	    SceneConfigs: _ReactNavigatorSceneConfigs2['default']
	  },
	
	  mixins: [_reactTimerMixin2['default'], _ReactInteractionMixin2['default'], _polyfillsSubscribable2['default'].Mixin],
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      configureScene: function configureScene() {
	        return _ReactNavigatorSceneConfigs2['default'].PushFromRight;
	      },
	      sceneStyle: styles.defaultSceneStyle
	    };
	  },
	
	  getInitialState: function getInitialState() {
	    var _this = this;
	
	    this._renderedSceneMap = new _coreJsLibraryFnMap2['default']();
	
	    var routeStack = this.props.initialRouteStack || [this.props.initialRoute];
	    (0, _fbjsLibInvariant2['default'])(routeStack.length >= 1, 'Navigator requires props.initialRoute or props.initialRouteStack.');
	    var initialRouteIndex = routeStack.length - 1;
	    if (this.props.initialRoute) {
	      initialRouteIndex = routeStack.indexOf(this.props.initialRoute);
	      (0, _fbjsLibInvariant2['default'])(initialRouteIndex !== -1, 'initialRoute is not in initialRouteStack.');
	    }
	    return {
	      sceneConfigStack: routeStack.map(function (route) {
	        return _this.props.configureScene(route);
	      }),
	      routeStack: routeStack,
	      presentedIndex: initialRouteIndex,
	      transitionFromIndex: null,
	      activeGesture: null,
	      pendingGestureProgress: null,
	      transitionQueue: []
	    };
	  },
	
	  componentWillMount: function componentWillMount() {
	    var _this2 = this;
	
	    // TODO(t7489503): Don't need this once ES6 Class landed.
	    this.__defineGetter__('navigationContext', this._getNavigationContext);
	
	    this._subRouteFocus = [];
	    this.parentNavigator = this.props.navigator;
	    this._handlers = {};
	    this.springSystem = new _rebound2['default'].SpringSystem();
	    this.spring = this.springSystem.createSpring();
	    this.spring.setRestSpeedThreshold(0.05);
	    this.spring.setCurrentValue(0).setAtRest();
	    this.spring.addListener({
	      onSpringEndStateChange: function onSpringEndStateChange() {
	        if (!_this2._interactionHandle) {
	          _this2._interactionHandle = _this2.createInteractionHandle();
	        }
	      },
	      onSpringUpdate: function onSpringUpdate() {
	        _this2._handleSpringUpdate();
	      },
	      onSpringAtRest: function onSpringAtRest() {
	        _this2._completeTransition();
	      }
	    });
	    this.panGesture = _ReactPanResponder2['default'].create({
	      onMoveShouldSetPanResponder: this._handleMoveShouldSetPanResponder,
	      onPanResponderGrant: this._handlePanResponderGrant,
	      onPanResponderRelease: this._handlePanResponderRelease,
	      onPanResponderMove: this._handlePanResponderMove,
	      onPanResponderTerminate: this._handlePanResponderTerminate
	    });
	    this._interactionHandle = null;
	    this._emitWillFocus(this.state.routeStack[this.state.presentedIndex]);
	    this.hashChanged = false;
	  },
	
	  componentDidMount: function componentDidMount() {
	    this._handleSpringUpdate();
	    this._emitDidFocus(this.state.routeStack[this.state.presentedIndex]);
	
	    // NOTE: Listen for changes to the current location. The
	    // listener is called once immediately.
	    _unlisten = history.listen((function (location) {
	      var destIndex = 0;
	      if (location.pathname.indexOf('/scene_') != -1) {
	        destIndex = parseInt(location.pathname.replace('/scene_', ''));
	      }
	      if (destIndex < this.state.routeStack.length && destIndex != this.state.routeStack.length) {
	        this.hashChanged = true;
	        this._jumpN(destIndex - this.state.presentedIndex);
	        this.hashChanged = false;
	      }
	    }).bind(this));
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    if (this._navigationContext) {
	      this._navigationContext.dispose();
	      this._navigationContext = null;
	    }
	
	    // When you're finished, stop the listener.
	    _unlisten();
	  },
	
	  /**
	   * @param {RouteStack} nextRouteStack Next route stack to reinitialize. This
	   * doesn't accept stack item `id`s, which implies that all existing items are
	   * destroyed, and then potentially recreated according to `routeStack`. Does
	   * not animate, immediately replaces and rerenders navigation bar and stack
	   * items.
	   */
	  immediatelyResetRouteStack: function immediatelyResetRouteStack(nextRouteStack) {
	    var _this3 = this;
	
	    var destIndex = nextRouteStack.length - 1;
	    this.setState({
	      routeStack: nextRouteStack,
	      sceneConfigStack: nextRouteStack.map(this.props.configureScene),
	      presentedIndex: destIndex,
	      activeGesture: null,
	      transitionFromIndex: null,
	      transitionQueue: []
	    }, function () {
	      _this3._handleSpringUpdate();
	    });
	  },
	
	  _transitionTo: function _transitionTo(destIndex, velocity, jumpSpringTo, cb) {
	    if (destIndex === this.state.presentedIndex) {
	      return;
	    }
	    if (this.state.transitionFromIndex !== null) {
	      this.state.transitionQueue.push({
	        destIndex: destIndex,
	        velocity: velocity,
	        cb: cb
	      });
	      return;
	    }
	    this.state.transitionFromIndex = this.state.presentedIndex;
	    this.state.presentedIndex = destIndex;
	    this.state.transitionCb = cb;
	    this._onAnimationStart();
	    // if (AnimationsDebugModule) {
	    //   AnimationsDebugModule.startRecordingFps();
	    // }
	    var sceneConfig = this.state.sceneConfigStack[this.state.transitionFromIndex] || this.state.sceneConfigStack[this.state.presentedIndex];
	    (0, _fbjsLibInvariant2['default'])(sceneConfig, 'Cannot configure scene at index ' + this.state.transitionFromIndex);
	    if (jumpSpringTo != null) {
	      this.spring.setCurrentValue(jumpSpringTo);
	    }
	    this.spring.setOvershootClampingEnabled(true);
	    this.spring.getSpringConfig().friction = sceneConfig.springFriction;
	    this.spring.getSpringConfig().tension = sceneConfig.springTension;
	    this.spring.setVelocity(velocity || sceneConfig.defaultTransitionVelocity);
	    this.spring.setEndValue(1);
	  },
	
	  /**
	   * This happens for each frame of either a gesture or a transition. If both are
	   * happening, we only set values for the transition and the gesture will catch up later
	   */
	  _handleSpringUpdate: function _handleSpringUpdate() {
	    // Prioritize handling transition in progress over a gesture:
	    if (this.state.transitionFromIndex != null) {
	      this._transitionBetween(this.state.transitionFromIndex, this.state.presentedIndex, this.spring.getCurrentValue());
	    } else if (this.state.activeGesture != null) {
	      var presentedToIndex = this.state.presentedIndex + this._deltaForGestureAction(this.state.activeGesture);
	      this._transitionBetween(this.state.presentedIndex, presentedToIndex, this.spring.getCurrentValue());
	    }
	  },
	
	  /**
	   * This happens at the end of a transition started by transitionTo, and when the spring catches up to a pending gesture
	   */
	  _completeTransition: function _completeTransition() {
	    if (this.spring.getCurrentValue() !== 1 && this.spring.getCurrentValue() !== 0) {
	      // The spring has finished catching up to a gesture in progress. Remove the pending progress
	      // and we will be in a normal activeGesture state
	      if (this.state.pendingGestureProgress) {
	        this.state.pendingGestureProgress = null;
	      }
	      return;
	    }
	    this._onAnimationEnd();
	    var presentedIndex = this.state.presentedIndex;
	    var didFocusRoute = this._subRouteFocus[presentedIndex] || this.state.routeStack[presentedIndex];
	    this._emitDidFocus(didFocusRoute);
	    // if (AnimationsDebugModule) {
	    //   AnimationsDebugModule.stopRecordingFps(Date.now());
	    // }
	    this.state.transitionFromIndex = null;
	    this.spring.setCurrentValue(0).setAtRest();
	    this._hideScenes();
	    if (this.state.transitionCb) {
	      this.state.transitionCb();
	      this.state.transitionCb = null;
	    }
	    if (this._interactionHandle) {
	      this.clearInteractionHandle(this._interactionHandle);
	      this._interactionHandle = null;
	    }
	    if (this.state.pendingGestureProgress) {
	      // A transition completed, but there is already another gesture happening.
	      // Enable the scene and set the spring to catch up with the new gesture
	      var gestureToIndex = this.state.presentedIndex + this._deltaForGestureAction(this.state.activeGesture);
	      this._enableScene(gestureToIndex);
	      this.spring.setEndValue(this.state.pendingGestureProgress);
	      return;
	    }
	    if (this.state.transitionQueue.length) {
	      var queuedTransition = this.state.transitionQueue.shift();
	      this._enableScene(queuedTransition.destIndex);
	      this._emitWillFocus(this.state.routeStack[queuedTransition.destIndex]);
	      this._transitionTo(queuedTransition.destIndex, queuedTransition.velocity, null, queuedTransition.cb);
	    }
	  },
	
	  _emitDidFocus: function _emitDidFocus(route) {
	    this.navigationContext.emit('didfocus', { route: route });
	
	    if (this.props.onDidFocus) {
	      this.props.onDidFocus(route);
	    }
	  },
	
	  _emitWillFocus: function _emitWillFocus(route) {
	    this.navigationContext.emit('willfocus', { route: route });
	
	    var navBar = this._navBar;
	    if (navBar && navBar.handleWillFocus) {
	      navBar.handleWillFocus(route);
	    }
	    if (this.props.onWillFocus) {
	      this.props.onWillFocus(route);
	    }
	  },
	
	  /**
	   * Hides all scenes that we are not currently on, gesturing to, or transitioning from
	   */
	  _hideScenes: function _hideScenes() {
	    var gesturingToIndex = null;
	    if (this.state.activeGesture) {
	      gesturingToIndex = this.state.presentedIndex + this._deltaForGestureAction(this.state.activeGesture);
	    }
	    for (var i = 0; i < this.state.routeStack.length; i++) {
	      if (i === this.state.presentedIndex || i === this.state.transitionFromIndex || i === gesturingToIndex) {
	        continue;
	      }
	      this._disableScene(i);
	    }
	  },
	
	  /**
	   * Push a scene off the screen, so that opacity:0 scenes will not block touches sent to the presented scenes
	   */
	  _disableScene: function _disableScene(sceneIndex) {
	    this.refs['scene_' + sceneIndex] && (0, _ReactSetNativeProps2['default'])(this.refs['scene_' + sceneIndex], SCENE_DISABLED_NATIVE_PROPS);
	  },
	
	  /**
	   * Put the scene back into the state as defined by props.sceneStyle, so transitions can happen normally
	   */
	  _enableScene: function _enableScene(sceneIndex) {
	    // First, determine what the defined styles are for scenes in this navigator
	    var sceneStyle = (0, _ReactFlattenStyle2['default'])([styles.baseScene, this.props.sceneStyle]);
	    // Then restore the pointer events and top value for this scene
	    var enabledSceneNativeProps = {
	      pointerEvents: 'auto',
	      style: {
	        top: sceneStyle.top,
	        bottom: sceneStyle.bottom
	      }
	    };
	    if (sceneIndex !== this.state.transitionFromIndex && sceneIndex !== this.state.presentedIndex) {
	      // If we are not in a transition from this index, make sure opacity is 0
	      // to prevent the enabled scene from flashing over the presented scene
	      enabledSceneNativeProps.style.opacity = 0;
	    }
	    this.refs['scene_' + sceneIndex] && (0, _ReactSetNativeProps2['default'])(this.refs['scene_' + sceneIndex], enabledSceneNativeProps);
	  },
	
	  _onAnimationStart: function _onAnimationStart() {
	    var fromIndex = this.state.presentedIndex;
	    var toIndex = this.state.presentedIndex;
	    if (this.state.transitionFromIndex != null) {
	      fromIndex = this.state.transitionFromIndex;
	    } else if (this.state.activeGesture) {
	      toIndex = this.state.presentedIndex + this._deltaForGestureAction(this.state.activeGesture);
	    }
	    this._setRenderSceneToHardwareTextureAndroid(fromIndex, true);
	    this._setRenderSceneToHardwareTextureAndroid(toIndex, true);
	    var navBar = this._navBar;
	    if (navBar && navBar.onAnimationStart) {
	      navBar.onAnimationStart(fromIndex, toIndex);
	    }
	  },
	
	  _onAnimationEnd: function _onAnimationEnd() {
	    var max = this.state.routeStack.length - 1;
	    for (var index = 0; index <= max; index++) {
	      this._setRenderSceneToHardwareTextureAndroid(index, false);
	    }
	
	    var navBar = this._navBar;
	    if (navBar && navBar.onAnimationEnd) {
	      navBar.onAnimationEnd();
	    }
	  },
	
	  _setRenderSceneToHardwareTextureAndroid: function _setRenderSceneToHardwareTextureAndroid(sceneIndex, shouldRenderToHardwareTexture) {
	    var viewAtIndex = this.refs['scene_' + sceneIndex];
	    if (viewAtIndex === null || viewAtIndex === undefined) {
	      return;
	    }
	    (0, _ReactSetNativeProps2['default'])(viewAtIndex, { renderToHardwareTextureAndroid: shouldRenderToHardwareTexture });
	  },
	
	  _handleTouchStart: function _handleTouchStart() {
	    this._eligibleGestures = GESTURE_ACTIONS;
	  },
	
	  _handleMoveShouldSetPanResponder: function _handleMoveShouldSetPanResponder(e, gestureState) {
	    var sceneConfig = this.state.sceneConfigStack[this.state.presentedIndex];
	    if (!sceneConfig) {
	      return false;
	    }
	    this._expectingGestureGrant = this._matchGestureAction(this._eligibleGestures, sceneConfig.gestures, gestureState);
	    return !!this._expectingGestureGrant;
	  },
	
	  _doesGestureOverswipe: function _doesGestureOverswipe(gestureName) {
	    var wouldOverswipeBack = this.state.presentedIndex <= 0 && (gestureName === 'pop' || gestureName === 'jumpBack');
	    var wouldOverswipeForward = this.state.presentedIndex >= this.state.routeStack.length - 1 && gestureName === 'jumpForward';
	    return wouldOverswipeForward || wouldOverswipeBack;
	  },
	
	  _handlePanResponderGrant: function _handlePanResponderGrant(e, gestureState) {
	    (0, _fbjsLibInvariant2['default'])(this._expectingGestureGrant, 'Responder granted unexpectedly.');
	    this._attachGesture(this._expectingGestureGrant);
	    this._onAnimationStart();
	    this._expectingGestureGrant = null;
	  },
	
	  _deltaForGestureAction: function _deltaForGestureAction(gestureAction) {
	    switch (gestureAction) {
	      case 'pop':
	      case 'jumpBack':
	        return -1;
	      case 'jumpForward':
	        return 1;
	      default:
	        (0, _fbjsLibInvariant2['default'])(false, 'Unsupported gesture action ' + gestureAction);
	        return;
	    }
	  },
	
	  _handlePanResponderRelease: function _handlePanResponderRelease(e, gestureState) {
	    var _this4 = this;
	
	    var sceneConfig = this.state.sceneConfigStack[this.state.presentedIndex];
	    var releaseGestureAction = this.state.activeGesture;
	    if (!releaseGestureAction) {
	      // The gesture may have been detached while responder, so there is no action here
	      return;
	    }
	    var releaseGesture = sceneConfig.gestures[releaseGestureAction];
	    var destIndex = this.state.presentedIndex + this._deltaForGestureAction(this.state.activeGesture);
	    if (this.spring.getCurrentValue() === 0) {
	      // The spring is at zero, so the gesture is already complete
	      this.spring.setCurrentValue(0).setAtRest();
	      this._completeTransition();
	      return;
	    }
	    var isTravelVertical = releaseGesture.direction === 'top-to-bottom' || releaseGesture.direction === 'bottom-to-top';
	    var isTravelInverted = releaseGesture.direction === 'right-to-left' || releaseGesture.direction === 'bottom-to-top';
	    var velocity, gestureDistance;
	    if (isTravelVertical) {
	      velocity = isTravelInverted ? -gestureState.vy : gestureState.vy;
	      gestureDistance = isTravelInverted ? -gestureState.dy : gestureState.dy;
	    } else {
	      velocity = isTravelInverted ? -gestureState.vx : gestureState.vx;
	      gestureDistance = isTravelInverted ? -gestureState.dx : gestureState.dx;
	    }
	    var transitionVelocity = (0, _polyfillsClamp2['default'])(-10, velocity, 10);
	    if (Math.abs(velocity) < releaseGesture.notMoving) {
	      // The gesture velocity is so slow, is "not moving"
	      var hasGesturedEnoughToComplete = gestureDistance > releaseGesture.fullDistance * releaseGesture.stillCompletionRatio;
	      transitionVelocity = hasGesturedEnoughToComplete ? releaseGesture.snapVelocity : -releaseGesture.snapVelocity;
	    }
	    if (transitionVelocity < 0 || this._doesGestureOverswipe(releaseGestureAction)) {
	      // This gesture is to an overswiped region or does not have enough velocity to complete
	      // If we are currently mid-transition, then this gesture was a pending gesture. Because this gesture takes no action, we can stop here
	      if (this.state.transitionFromIndex == null) {
	        // There is no current transition, so we need to transition back to the presented index
	        var transitionBackToPresentedIndex = this.state.presentedIndex;
	        // slight hack: change the presented index for a moment in order to transitionTo correctly
	        this.state.presentedIndex = destIndex;
	        this._transitionTo(transitionBackToPresentedIndex, -transitionVelocity, 1 - this.spring.getCurrentValue());
	      }
	    } else {
	      // The gesture has enough velocity to complete, so we transition to the gesture's destination
	      this._emitWillFocus(this.state.routeStack[destIndex]);
	      this._transitionTo(destIndex, transitionVelocity, null, function () {
	        if (releaseGestureAction === 'pop') {
	          _this4._cleanScenesPastIndex(destIndex);
	        }
	      });
	    }
	    this._detachGesture();
	  },
	
	  _handlePanResponderTerminate: function _handlePanResponderTerminate(e, gestureState) {
	    if (this.state.activeGesture == null) {
	      return;
	    }
	    var destIndex = this.state.presentedIndex + this._deltaForGestureAction(this.state.activeGesture);
	    this._detachGesture();
	    var transitionBackToPresentedIndex = this.state.presentedIndex;
	    // slight hack: change the presented index for a moment in order to transitionTo correctly
	    this.state.presentedIndex = destIndex;
	    this._transitionTo(transitionBackToPresentedIndex, null, 1 - this.spring.getCurrentValue());
	  },
	
	  _attachGesture: function _attachGesture(gestureId) {
	    this.state.activeGesture = gestureId;
	    var gesturingToIndex = this.state.presentedIndex + this._deltaForGestureAction(this.state.activeGesture);
	    this._enableScene(gesturingToIndex);
	  },
	
	  _detachGesture: function _detachGesture() {
	    this.state.activeGesture = null;
	    this.state.pendingGestureProgress = null;
	    this._hideScenes();
	  },
	
	  _handlePanResponderMove: function _handlePanResponderMove(e, gestureState) {
	    var sceneConfig = this.state.sceneConfigStack[this.state.presentedIndex];
	    if (this.state.activeGesture) {
	      var gesture = sceneConfig.gestures[this.state.activeGesture];
	      return this._moveAttachedGesture(gesture, gestureState);
	    }
	    var matchedGesture = this._matchGestureAction(GESTURE_ACTIONS, sceneConfig.gestures, gestureState);
	    if (matchedGesture) {
	      this._attachGesture(matchedGesture);
	    }
	  },
	
	  _moveAttachedGesture: function _moveAttachedGesture(gesture, gestureState) {
	    var isTravelVertical = gesture.direction === 'top-to-bottom' || gesture.direction === 'bottom-to-top';
	    var isTravelInverted = gesture.direction === 'right-to-left' || gesture.direction === 'bottom-to-top';
	    var distance = isTravelVertical ? gestureState.dy : gestureState.dx;
	    distance = isTravelInverted ? -distance : distance;
	    var gestureDetectMovement = gesture.gestureDetectMovement;
	    var nextProgress = (distance - gestureDetectMovement) / (gesture.fullDistance - gestureDetectMovement);
	    if (nextProgress < 0 && gesture.isDetachable) {
	      var gesturingToIndex = this.state.presentedIndex + this._deltaForGestureAction(this.state.activeGesture);
	      this._transitionBetween(this.state.presentedIndex, gesturingToIndex, 0);
	      this._detachGesture();
	      if (this.state.pendingGestureProgress != null) {
	        this.spring.setCurrentValue(0);
	      }
	      return;
	    }
	    if (this._doesGestureOverswipe(this.state.activeGesture)) {
	      var frictionConstant = gesture.overswipe.frictionConstant;
	      var frictionByDistance = gesture.overswipe.frictionByDistance;
	      var frictionRatio = 1 / (frictionConstant + Math.abs(nextProgress) * frictionByDistance);
	      nextProgress *= frictionRatio;
	    }
	    nextProgress = (0, _polyfillsClamp2['default'])(0, nextProgress, 1);
	    if (this.state.transitionFromIndex != null) {
	      this.state.pendingGestureProgress = nextProgress;
	    } else if (this.state.pendingGestureProgress) {
	      this.spring.setEndValue(nextProgress);
	    } else {
	      this.spring.setCurrentValue(nextProgress);
	    }
	  },
	
	  _matchGestureAction: function _matchGestureAction(eligibleGestures, gestures, gestureState) {
	    var _this5 = this;
	
	    if (!gestures) {
	      return null;
	    }
	    var matchedGesture = null;
	    eligibleGestures.some(function (gestureName, gestureIndex) {
	      var gesture = gestures[gestureName];
	      if (!gesture) {
	        return;
	      }
	      if (gesture.overswipe == null && _this5._doesGestureOverswipe(gestureName)) {
	        // cannot swipe past first or last scene without overswiping
	        return false;
	      }
	      var isTravelVertical = gesture.direction === 'top-to-bottom' || gesture.direction === 'bottom-to-top';
	      var isTravelInverted = gesture.direction === 'right-to-left' || gesture.direction === 'bottom-to-top';
	      var currentLoc = isTravelVertical ? gestureState.moveY : gestureState.moveX;
	      var travelDist = isTravelVertical ? gestureState.dy : gestureState.dx;
	      var oppositeAxisTravelDist = isTravelVertical ? gestureState.dx : gestureState.dy;
	      var edgeHitWidth = gesture.edgeHitWidth;
	      if (isTravelInverted) {
	        currentLoc = -currentLoc;
	        travelDist = -travelDist;
	        oppositeAxisTravelDist = -oppositeAxisTravelDist;
	        edgeHitWidth = isTravelVertical ? -(SCREEN_HEIGHT - edgeHitWidth) : -(SCREEN_WIDTH - edgeHitWidth);
	      }
	      var moveStartedInRegion = gesture.edgeHitWidth == null || currentLoc < edgeHitWidth;
	      if (!moveStartedInRegion) {
	        return false;
	      }
	      var moveTravelledFarEnough = travelDist >= gesture.gestureDetectMovement;
	      if (!moveTravelledFarEnough) {
	        return false;
	      }
	      var directionIsCorrect = Math.abs(travelDist) > Math.abs(oppositeAxisTravelDist) * gesture.directionRatio;
	      if (directionIsCorrect) {
	        matchedGesture = gestureName;
	        return true;
	      } else {
	        _this5._eligibleGestures = _this5._eligibleGestures.slice().splice(gestureIndex, 1);
	      }
	    });
	    return matchedGesture;
	  },
	
	  _transitionSceneStyle: function _transitionSceneStyle(fromIndex, toIndex, progress, index) {
	    var viewAtIndex = this.refs['scene_' + index];
	    if (viewAtIndex === null || viewAtIndex === undefined) {
	      return;
	    }
	    // Use toIndex animation when we move forwards. Use fromIndex when we move back
	    var sceneConfigIndex = fromIndex < toIndex ? toIndex : fromIndex;
	    var sceneConfig = this.state.sceneConfigStack[sceneConfigIndex];
	    // this happens for overswiping when there is no scene at toIndex
	    if (!sceneConfig) {
	      sceneConfig = this.state.sceneConfigStack[sceneConfigIndex - 1];
	    }
	    var styleToUse = {};
	    var useFn = index < fromIndex || index < toIndex ? sceneConfig.animationInterpolators.out : sceneConfig.animationInterpolators.into;
	    var directionAdjustedProgress = fromIndex < toIndex ? progress : 1 - progress;
	    var didChange = useFn(styleToUse, directionAdjustedProgress);
	    if (didChange) {
	      (0, _ReactSetNativeProps2['default'])(viewAtIndex, { style: styleToUse });
	    }
	  },
	
	  _transitionBetween: function _transitionBetween(fromIndex, toIndex, progress) {
	    this._transitionSceneStyle(fromIndex, toIndex, progress, fromIndex);
	    this._transitionSceneStyle(fromIndex, toIndex, progress, toIndex);
	    var navBar = this._navBar;
	    if (navBar && navBar.updateProgress && toIndex >= 0 && fromIndex >= 0) {
	      navBar.updateProgress(progress, fromIndex, toIndex);
	    }
	  },
	
	  _handleResponderTerminationRequest: function _handleResponderTerminationRequest() {
	    return false;
	  },
	
	  _getDestIndexWithinBounds: function _getDestIndexWithinBounds(n) {
	    var currentIndex = this.state.presentedIndex;
	    var destIndex = currentIndex + n;
	    (0, _fbjsLibInvariant2['default'])(destIndex >= 0, 'Cannot jump before the first route.');
	    var maxIndex = this.state.routeStack.length - 1;
	    (0, _fbjsLibInvariant2['default'])(maxIndex >= destIndex, 'Cannot jump past the last route.');
	    return destIndex;
	  },
	
	  _jumpN: function _jumpN(n) {
	    var destIndex = this._getDestIndexWithinBounds(n);
	    this._enableScene(destIndex);
	    this._emitWillFocus(this.state.routeStack[destIndex]);
	    this._transitionTo(destIndex);
	    if (!this.hashChanged) {
	      if (n > 0) {
	        history.pushState({ index: destIndex }, '/scene_' + getRouteID(this.state.routeStack[destIndex]));
	      } else {
	        history.go(n);
	      }
	    }
	  },
	
	  jumpTo: function jumpTo(route) {
	    var destIndex = this.state.routeStack.indexOf(route);
	    (0, _fbjsLibInvariant2['default'])(destIndex !== -1, 'Cannot jump to route that is not in the route stack');
	    this._jumpN(destIndex - this.state.presentedIndex);
	  },
	
	  jumpForward: function jumpForward() {
	    this._jumpN(1);
	  },
	
	  jumpBack: function jumpBack() {
	    this._jumpN(-1);
	  },
	
	  push: function push(route) {
	    var _this6 = this;
	
	    (0, _fbjsLibInvariant2['default'])(!!route, 'Must supply route to push');
	    var activeLength = this.state.presentedIndex + 1;
	    var activeStack = this.state.routeStack.slice(0, activeLength);
	    var activeAnimationConfigStack = this.state.sceneConfigStack.slice(0, activeLength);
	    var nextStack = activeStack.concat([route]);
	    var destIndex = nextStack.length - 1;
	    var nextAnimationConfigStack = activeAnimationConfigStack.concat([this.props.configureScene(route)]);
	    this._emitWillFocus(nextStack[destIndex]);
	    this.setState({
	      routeStack: nextStack,
	      sceneConfigStack: nextAnimationConfigStack
	    }, function () {
	      history.pushState({ index: destIndex }, '/scene_' + getRouteID(route));
	      _this6._enableScene(destIndex);
	      _this6._transitionTo(destIndex);
	    });
	  },
	
	  _popN: function _popN(n) {
	    var _this7 = this;
	
	    if (n === 0) {
	      return;
	    }
	    (0, _fbjsLibInvariant2['default'])(this.state.presentedIndex - n >= 0, 'Cannot pop below zero');
	    var popIndex = this.state.presentedIndex - n;
	    this._enableScene(popIndex);
	    this._emitWillFocus(this.state.routeStack[popIndex]);
	    this._transitionTo(popIndex, null, // default velocity
	    null, // no spring jumping
	    function () {
	      history.go(-n);
	      _this7._cleanScenesPastIndex(popIndex);
	    });
	  },
	
	  pop: function pop() {
	    if (this.state.transitionQueue.length) {
	      // This is the workaround to prevent user from firing multiple `pop()`
	      // calls that may pop the routes beyond the limit.
	      // Because `this.state.presentedIndex` does not update until the
	      // transition starts, we can't reliably use `this.state.presentedIndex`
	      // to know whether we can safely keep popping the routes or not at this
	      //  moment.
	      return;
	    }
	
	    if (this.state.presentedIndex > 0) {
	      this._popN(1);
	    }
	  },
	
	  /**
	   * Replace a route in the navigation stack.
	   *
	   * `index` specifies the route in the stack that should be replaced.
	   * If it's negative, it counts from the back.
	   */
	  replaceAtIndex: function replaceAtIndex(route, index, cb) {
	    var _this8 = this;
	
	    (0, _fbjsLibInvariant2['default'])(!!route, 'Must supply route to replace');
	    if (index < 0) {
	      index += this.state.routeStack.length;
	    }
	
	    if (this.state.routeStack.length <= index) {
	      return;
	    }
	
	    var nextRouteStack = this.state.routeStack.slice();
	    var nextAnimationModeStack = this.state.sceneConfigStack.slice();
	    nextRouteStack[index] = route;
	    nextAnimationModeStack[index] = this.props.configureScene(route);
	
	    if (index === this.state.presentedIndex) {
	      this._emitWillFocus(route);
	    }
	    this.setState({
	      routeStack: nextRouteStack,
	      sceneConfigStack: nextAnimationModeStack
	    }, function () {
	      if (index === _this8.state.presentedIndex) {
	        _this8._emitDidFocus(route);
	      }
	      cb && cb();
	    });
	  },
	
	  /**
	   * Replaces the current scene in the stack.
	   */
	  replace: function replace(route) {
	    this.replaceAtIndex(route, this.state.presentedIndex);
	  },
	
	  /**
	   * Replace the current route's parent.
	   */
	  replacePrevious: function replacePrevious(route) {
	    this.replaceAtIndex(route, this.state.presentedIndex - 1);
	  },
	
	  popToTop: function popToTop() {
	    this.popToRoute(this.state.routeStack[0]);
	  },
	
	  popToRoute: function popToRoute(route) {
	    var indexOfRoute = this.state.routeStack.indexOf(route);
	    (0, _fbjsLibInvariant2['default'])(indexOfRoute !== -1, 'Calling popToRoute for a route that doesn\'t exist!');
	    var numToPop = this.state.presentedIndex - indexOfRoute;
	    this._popN(numToPop);
	  },
	
	  replacePreviousAndPop: function replacePreviousAndPop(route) {
	    if (this.state.routeStack.length < 2) {
	      return;
	    }
	    this.replacePrevious(route);
	    this.pop();
	  },
	
	  resetTo: function resetTo(route) {
	    var _this9 = this;
	
	    (0, _fbjsLibInvariant2['default'])(!!route, 'Must supply route to push');
	    this.replaceAtIndex(route, 0, function () {
	      // Do not use popToRoute here, because race conditions could prevent the
	      // route from existing at this time. Instead, just go to index 0
	      if (_this9.state.presentedIndex > 0) {
	        _this9._popN(_this9.state.presentedIndex);
	      }
	    });
	  },
	
	  getCurrentRoutes: function getCurrentRoutes() {
	    // Clone before returning to avoid caller mutating the stack
	    return this.state.routeStack.slice();
	  },
	
	  _cleanScenesPastIndex: function _cleanScenesPastIndex(index) {
	    var newStackLength = index + 1;
	    // Remove any unneeded rendered routes.
	    if (newStackLength < this.state.routeStack.length) {
	      this.setState({
	        sceneConfigStack: this.state.sceneConfigStack.slice(0, newStackLength),
	        routeStack: this.state.routeStack.slice(0, newStackLength)
	      });
	    }
	  },
	
	  _renderScene: function _renderScene(route, i) {
	    var _this10 = this;
	
	    var disabledSceneStyle = null;
	    var disabledScenePointerEvents = 'auto';
	    if (i !== this.state.presentedIndex) {
	      disabledSceneStyle = styles.disabledScene;
	      disabledScenePointerEvents = 'none';
	    }
	
	    return _react2['default'].createElement(
	      _ReactView2['default'],
	      {
	        key: 'scene_' + getRouteID(route),
	        ref: 'scene_' + i,
	        onStartShouldSetResponderCapture: function () {
	          return _this10.state.transitionFromIndex != null || _this10.state.transitionFromIndex != null;
	        },
	        pointerEvents: disabledScenePointerEvents,
	        style: [styles.baseScene, this.props.sceneStyle, disabledSceneStyle] },
	      this.props.renderScene(route, this)
	    );
	  },
	
	  _renderNavigationBar: function _renderNavigationBar() {
	    var _this11 = this;
	
	    if (!this.props.navigationBar) {
	      return null;
	    }
	    return _react2['default'].cloneElement(this.props.navigationBar, {
	      ref: function ref(navBar) {
	        _this11._navBar = navBar;
	      },
	      navigator: this,
	      navState: this.state
	    });
	  },
	
	  render: function render() {
	    var _this12 = this;
	
	    var newRenderedSceneMap = new _coreJsLibraryFnMap2['default']();
	    var scenes = this.state.routeStack.map(function (route, index) {
	      var renderedScene;
	      if (_this12._renderedSceneMap.has(route) && index !== _this12.state.presentedIndex) {
	        renderedScene = _this12._renderedSceneMap.get(route);
	      } else {
	        renderedScene = _this12._renderScene(route, index);
	      }
	      newRenderedSceneMap.set(route, renderedScene);
	      return renderedScene;
	    });
	    this._renderedSceneMap = newRenderedSceneMap;
	    return _react2['default'].createElement(
	      _ReactView2['default'],
	      { style: [styles.container, this.props.style] },
	      _react2['default'].createElement(
	        _ReactView2['default'],
	        _extends({
	          style: styles.transitioner
	        }, this.panGesture.panHandlers, {
	          onTouchStart: this._handleTouchStart,
	          onResponderTerminationRequest: this._handleResponderTerminationRequest }),
	        scenes
	      ),
	      this._renderNavigationBar()
	    );
	  },
	
	  _getNavigationContext: function _getNavigationContext() {
	    if (!this._navigationContext) {
	      this._navigationContext = new _ReactNavigationContext2['default']();
	    }
	    return this._navigationContext;
	  }
	});
	
	module.exports = Navigator;

/***/ },
/* 257 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright 2004-present Facebook. All Rights Reserved.
	 *
	 * @providesModule ReactInteractionMixin
	 * 
	 */
	'use strict';
	
	/**
	 * This mixin provides safe versions of InteractionManager start/end methods
	 * that ensures `clearInteractionHandle` is always called
	 * once per start, even if the component is unmounted.
	 */
	var InteractionMixin = {
	  componentWillUnmount: function componentWillUnmount() {},
	
	  _interactionMixinHandles: [],
	
	  createInteractionHandle: function createInteractionHandle() {},
	
	  clearInteractionHandle: function clearInteractionHandle(clearHandle) {},
	
	  /**
	   * Schedule work for after all interactions have completed.
	   *
	   * @param {function} callback
	   */
	  runAfterInteractions: function runAfterInteractions(callback) {}
	};
	
	module.exports = InteractionMixin;

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(182);
	__webpack_require__(183);
	__webpack_require__(205);
	__webpack_require__(259);
	__webpack_require__(260);
	module.exports = __webpack_require__(191).Map;

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(213);
	
	// 23.1 Map Objects
	__webpack_require__(227)('Map', function(get){
	  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key){
	    var entry = strong.getEntry(this, key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value){
	    return strong.def(this, key === 0 ? 0 : key, value);
	  }
	}, strong, true);

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $def  = __webpack_require__(189);
	
	$def($def.P, 'Map', {toJSON: __webpack_require__(229)('Map')});

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * @providesModule ReactNavigationContext
	 */
	'use strict';
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _ReactNavigationEvent = __webpack_require__(262);
	
	var _ReactNavigationEvent2 = _interopRequireDefault(_ReactNavigationEvent);
	
	var _ReactNavigationEventEmitter = __webpack_require__(263);
	
	var _ReactNavigationEventEmitter2 = _interopRequireDefault(_ReactNavigationEventEmitter);
	
	var _ReactNavigationTreeNode = __webpack_require__(269);
	
	var _ReactNavigationTreeNode2 = _interopRequireDefault(_ReactNavigationTreeNode);
	
	var _fbjsLibEmptyFunction = __webpack_require__(252);
	
	var _fbjsLibEmptyFunction2 = _interopRequireDefault(_fbjsLibEmptyFunction);
	
	var _fbjsLibInvariant = __webpack_require__(231);
	
	var _fbjsLibInvariant2 = _interopRequireDefault(_fbjsLibInvariant);
	
	var AT_TARGET = _ReactNavigationEvent2['default'].AT_TARGET;
	var BUBBLING_PHASE = _ReactNavigationEvent2['default'].BUBBLING_PHASE;
	var CAPTURING_PHASE = _ReactNavigationEvent2['default'].CAPTURING_PHASE;
	
	/**
	 * Class that contains the info and methods for app navigation.
	 */
	
	var NavigationContext = (function () {
	  function NavigationContext() {
	    _classCallCheck(this, NavigationContext);
	
	    this._bubbleEventEmitter = new _ReactNavigationEventEmitter2['default'](this);
	    this._captureEventEmitter = new _ReactNavigationEventEmitter2['default'](this);
	    this._currentRoute = null;
	
	    // Sets the protected property `__node`.
	    this.__node = new _ReactNavigationTreeNode2['default'](this);
	
	    this._emitCounter = 0;
	    this._emitQueue = [];
	
	    this.addListener('willfocus', this._onFocus, this);
	    this.addListener('didfocus', this._onFocus, this);
	  }
	
	  /* $FlowFixMe - get/set properties not yet supported */
	
	  _createClass(NavigationContext, [{
	    key: 'appendChild',
	    value: function appendChild(childContext) {
	      this.__node.appendChild(childContext.__node);
	    }
	  }, {
	    key: 'addListener',
	    value: function addListener(eventType, listener, context, useCapture) {
	      var emitter = useCapture ? this._captureEventEmitter : this._bubbleEventEmitter;
	      if (emitter) {
	        return emitter.addListener(eventType, listener, context);
	      } else {
	        return { remove: _fbjsLibEmptyFunction2['default'] };
	      }
	    }
	  }, {
	    key: 'emit',
	    value: function emit(eventType, data, didEmitCallback) {
	      var _this = this;
	
	      if (this._emitCounter > 0) {
	        // An event cycle that was previously created hasn't finished yet.
	
	        var args = Array.prototype.slice.call(arguments);
	        this._emitQueue.push(args);
	        return;
	      }
	
	      this._emitCounter++;
	
	      var targets = [this];
	      var parentTarget = this.parent;
	      while (parentTarget) {
	        targets.unshift(parentTarget);
	        parentTarget = parentTarget.parent;
	      }
	
	      var propagationStopped = false;
	      var defaultPrevented = false;
	      var callback = function callback(event) {
	        propagationStopped = propagationStopped || event.isPropagationStopped();
	        defaultPrevented = defaultPrevented || event.defaultPrevented;
	      };
	
	      // capture phase
	      targets.some(function (currentTarget) {
	        if (propagationStopped) {
	          return true;
	        }
	
	        var extraInfo = {
	          defaultPrevented: defaultPrevented,
	          eventPhase: CAPTURING_PHASE,
	          propagationStopped: propagationStopped,
	          target: _this
	        };
	
	        currentTarget.__emit(eventType, data, callback, extraInfo);
	      }, this);
	
	      // bubble phase
	      targets.reverse().some(function (currentTarget) {
	        if (propagationStopped) {
	          return true;
	        }
	        var extraInfo = {
	          defaultPrevented: defaultPrevented,
	          eventPhase: BUBBLING_PHASE,
	          propagationStopped: propagationStopped,
	          target: _this
	        };
	        currentTarget.__emit(eventType, data, callback, extraInfo);
	      }, this);
	
	      if (didEmitCallback) {
	        var event = _ReactNavigationEvent2['default'].pool(eventType, this, data);
	        propagationStopped && event.stopPropagation();
	        defaultPrevented && event.preventDefault();
	        didEmitCallback.call(this, event);
	        event.dispose();
	      }
	
	      this._emitCounter--;
	      while (this._emitQueue.length) {
	        var args = this._emitQueue.shift();
	        this.emit.apply(this, args);
	      }
	    }
	  }, {
	    key: 'dispose',
	    value: function dispose() {
	      // clean up everything.
	      this._bubbleEventEmitter && this._bubbleEventEmitter.removeAllListeners();
	      this._captureEventEmitter && this._captureEventEmitter.removeAllListeners();
	      this._bubbleEventEmitter = null;
	      this._captureEventEmitter = null;
	      this._currentRoute = null;
	    }
	
	    // This method `__method` is protected.
	  }, {
	    key: '__emit',
	    value: function __emit(eventType, data, didEmitCallback, extraInfo) {
	      var emitter;
	      switch (extraInfo.eventPhase) {
	        case CAPTURING_PHASE:
	          // phase = 1
	          emitter = this._captureEventEmitter;
	          break;
	        case BUBBLING_PHASE:
	          // phase = 3
	          emitter = this._bubbleEventEmitter;
	          break;
	        default:
	          (0, _fbjsLibInvariant2['default'])(false, 'invalid event phase %s', extraInfo.eventPhase);
	      }
	
	      if (extraInfo.target === this) {
	        // phase = 2
	        extraInfo.eventPhase = AT_TARGET;
	      }
	
	      if (emitter) {
	        emitter.emit(eventType, data, didEmitCallback, extraInfo);
	      }
	    }
	  }, {
	    key: '_onFocus',
	    value: function _onFocus(event) {
	      (0, _fbjsLibInvariant2['default'])(event.data && event.data.hasOwnProperty('route'), 'didfocus event should provide route');
	      this._currentRoute = event.data.route;
	    }
	  }, {
	    key: 'parent',
	    get: function get() {
	      var parent = this.__node.getParent();
	      return parent ? parent.getValue() : null;
	    }
	
	    /* $FlowFixMe - get/set properties not yet supported */
	  }, {
	    key: 'currentRoute',
	    get: function get() {
	      return this._currentRoute;
	    }
	  }]);
	
	  return NavigationContext;
	})();
	
	module.exports = NavigationContext;
	// Put this event cycle into the queue and will finish them later.

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * @providesModule ReactNavigationEvent
	 * 
	 */
	'use strict';
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _fbjsLibInvariant = __webpack_require__(231);
	
	var _fbjsLibInvariant2 = _interopRequireDefault(_fbjsLibInvariant);
	
	var NavigationEventPool = (function () {
	  function NavigationEventPool() {
	    _classCallCheck(this, NavigationEventPool);
	
	    this._list = [];
	  }
	
	  _createClass(NavigationEventPool, [{
	    key: 'get',
	    value: function get(type, currentTarget, data) {
	      var event;
	      if (this._list.length > 0) {
	        event = this._list.pop();
	        event.constructor.call(event, type, currentTarget, data);
	      } else {
	        event = new NavigationEvent(type, currentTarget, data);
	      }
	      return event;
	    }
	  }, {
	    key: 'put',
	    value: function put(event) {
	      this._list.push(event);
	    }
	  }]);
	
	  return NavigationEventPool;
	})();
	
	var _navigationEventPool = new NavigationEventPool();
	
	/**
	 * The NavigationEvent interface represents any event of the navigation.
	 * It contains common properties and methods to any event.
	 *
	 * == Important Properties ==
	 *
	 * - target:
	 *   A reference to the navigation context that dispatched the event. It is
	 *   different from event.currentTarget when the event handler is called during
	 *   the bubbling or capturing phase of the event.
	 *
	 * - currentTarget:
	 *   Identifies the current target for the event, as the event traverses the
	 *   navigation context tree. It always refers to the navigation context the
	 *   event handler has been attached to as opposed to event.target which
	 *   identifies the navigation context on which the event occurred.
	 *
	 * - eventPhase:
	 *   Returns an integer value which specifies the current evaluation phase of
	 *   the event flow; possible values are listed in NavigationEvent phase
	 *   constants below.
	 */
	
	var NavigationEvent = (function () {
	  _createClass(NavigationEvent, null, [{
	    key: 'pool',
	    value: function pool(type, currentTarget, data) {
	      return _navigationEventPool.get(type, currentTarget, data);
	    }
	  }]);
	
	  function NavigationEvent(type, currentTarget, data) {
	    _classCallCheck(this, NavigationEvent);
	
	    this.target = currentTarget;
	    this.eventPhase = NavigationEvent.NONE;
	
	    this._type = type;
	    this._currentTarget = currentTarget;
	    this._data = data;
	    this._defaultPrevented = false;
	    this._disposed = false;
	    this._propagationStopped = false;
	  }
	
	  /**
	   * Event phase constants.
	   * These values describe which phase the event flow is currently being
	   * evaluated.
	   */
	
	  // No event is being processed at this time.
	
	  /* $FlowFixMe - get/set properties not yet supported */
	
	  _createClass(NavigationEvent, [{
	    key: 'preventDefault',
	    value: function preventDefault() {
	      this._defaultPrevented = true;
	    }
	  }, {
	    key: 'stopPropagation',
	    value: function stopPropagation() {
	      this._propagationStopped = true;
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      this.preventDefault();
	      this.stopPropagation();
	    }
	  }, {
	    key: 'isPropagationStopped',
	    value: function isPropagationStopped() {
	      return this._propagationStopped;
	    }
	
	    /**
	     * Dispose the event.
	     * NavigationEvent shall be disposed after being emitted by
	     * `NavigationEventEmitter`.
	     */
	  }, {
	    key: 'dispose',
	    value: function dispose() {
	      (0, _fbjsLibInvariant2['default'])(!this._disposed, 'NavigationEvent is already disposed');
	      this._disposed = true;
	
	      // Clean up.
	      this.target = null;
	      this.eventPhase = NavigationEvent.NONE;
	      this._type = null;
	      this._currentTarget = null;
	      this._data = null;
	      this._defaultPrevented = false;
	
	      // Put this back to the pool to reuse the instance.
	      _navigationEventPool.put(this);
	    }
	  }, {
	    key: 'type',
	    get: function get() {
	      return this._type;
	    }
	
	    /* $FlowFixMe - get/set properties not yet supported */
	  }, {
	    key: 'currentTarget',
	    get: function get() {
	      return this._currentTarget;
	    }
	
	    /* $FlowFixMe - get/set properties not yet supported */
	  }, {
	    key: 'data',
	    get: function get() {
	      return this._data;
	    }
	
	    /* $FlowFixMe - get/set properties not yet supported */
	  }, {
	    key: 'defaultPrevented',
	    get: function get() {
	      return this._defaultPrevented;
	    }
	  }]);
	
	  return NavigationEvent;
	})();
	
	NavigationEvent.NONE = 0;
	
	// The event is being propagated through the currentTarget's ancestor objects.
	NavigationEvent.CAPTURING_PHASE = 1;
	
	// The event has arrived at the event's currentTarget. Event listeners registered for
	// this phase are called at this time.
	NavigationEvent.AT_TARGET = 2;
	
	// The event is propagating back up through the currentTarget's ancestors in reverse
	// order, starting with the parent. This is known as bubbling, and occurs only
	// if event propagation isn't prevented. Event listeners registered for this
	// phase are triggered during this process.
	NavigationEvent.BUBBLING_PHASE = 3;
	
	module.exports = NavigationEvent;
	
	// Returns an integer value which specifies the current evaluation phase of
	// the event flow.

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * @providesModule ReactNavigationEventEmitter
	 * 
	 */
	'use strict';
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _EventEmitter2 = __webpack_require__(264);
	
	var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);
	
	var _ReactNavigationEvent = __webpack_require__(262);
	
	var _ReactNavigationEvent2 = _interopRequireDefault(_ReactNavigationEvent);
	
	var NavigationEventEmitter = (function (_EventEmitter) {
	  _inherits(NavigationEventEmitter, _EventEmitter);
	
	  function NavigationEventEmitter(target) {
	    _classCallCheck(this, NavigationEventEmitter);
	
	    _get(Object.getPrototypeOf(NavigationEventEmitter.prototype), 'constructor', this).call(this);
	    this._emitting = false;
	    this._emitQueue = [];
	    this._target = target;
	  }
	
	  _createClass(NavigationEventEmitter, [{
	    key: 'emit',
	    value: function emit(eventType, data, didEmitCallback, extraInfo) {
	      if (this._emitting) {
	        // An event cycle that was previously created hasn't finished yet.
	
	        var args = Array.prototype.slice.call(arguments);
	        this._emitQueue.unshift(args);
	        return;
	      }
	
	      this._emitting = true;
	
	      var event = _ReactNavigationEvent2['default'].pool(eventType, this._target, data);
	
	      if (extraInfo) {
	        if (extraInfo.target) {
	          event.target = extraInfo.target;
	        }
	
	        if (extraInfo.eventPhase) {
	          event.eventPhase = extraInfo.eventPhase;
	        }
	
	        if (extraInfo.defaultPrevented) {
	          event.preventDefault();
	        }
	
	        if (extraInfo.propagationStopped) {
	          event.stopPropagation();
	        }
	      }
	
	      // EventEmitter#emit only takes `eventType` as `String`. Casting `eventType`
	      // to `String` to make  happy.
	      _get(Object.getPrototypeOf(NavigationEventEmitter.prototype), 'emit', this).call(this, String(eventType), event);
	
	      if (typeof didEmitCallback === 'function') {
	        didEmitCallback.call(this._target, event);
	      }
	      event.dispose();
	
	      this._emitting = false;
	
	      while (this._emitQueue.length) {
	        var args = this._emitQueue.shift();
	        this.emit.apply(this, args);
	      }
	    }
	  }]);
	
	  return NavigationEventEmitter;
	})(_EventEmitter3['default']);
	
	module.exports = NavigationEventEmitter;
	// Put this event cycle into the queue and will finish them later.

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @generated SignedSource<<494e66dea72a3e90b763a5ec50b1e0ca>>
	 *
	 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	 * !! This file is a check-in of a static_upstream project!      !!
	 * !!                                                            !!
	 * !! You should not modify this file directly. Instead:         !!
	 * !! 1) Use `fjs use-upstream` to temporarily replace this with !!
	 * !!    the latest version from upstream.                       !!
	 * !! 2) Make your changes, test them, etc.                      !!
	 * !! 3) Use `fjs push-upstream` to copy your changes back to    !!
	 * !!    static_upstream.                                        !!
	 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	 *
	 * @providesModule EventEmitter
	 * @typechecks
	 */
	
	'use strict';
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _ReactEmitterSubscription = __webpack_require__(265);
	
	var _ReactEmitterSubscription2 = _interopRequireDefault(_ReactEmitterSubscription);
	
	var _ReactErrorUtils = __webpack_require__(267);
	
	var _ReactErrorUtils2 = _interopRequireDefault(_ReactErrorUtils);
	
	var _ReactEventSubscriptionVendor = __webpack_require__(268);
	
	var _ReactEventSubscriptionVendor2 = _interopRequireDefault(_ReactEventSubscriptionVendor);
	
	var _fbjsLibEmptyFunction = __webpack_require__(252);
	
	var _fbjsLibEmptyFunction2 = _interopRequireDefault(_fbjsLibEmptyFunction);
	
	var _fbjsLibInvariant = __webpack_require__(231);
	
	var _fbjsLibInvariant2 = _interopRequireDefault(_fbjsLibInvariant);
	
	/**
	 * @class EventEmitter
	 * @description
	 * An EventEmitter is responsible for managing a set of listeners and publishing
	 * events to them when it is told that such events happened. In addition to the
	 * data for the given event it also sends a event control object which allows
	 * the listeners/handlers to prevent the default behavior of the given event.
	 *
	 * The emitter is designed to be generic enough to support all the different
	 * contexts in which one might want to emit events. It is a simple multicast
	 * mechanism on top of which extra functionality can be composed. For example, a
	 * more advanced emitter may use an EventHolder and EventFactory.
	 */
	
	var EventEmitter = (function () {
	  /**
	   * @constructor
	   */
	
	  function EventEmitter() {
	    _classCallCheck(this, EventEmitter);
	
	    this._subscriber = new _ReactEventSubscriptionVendor2['default']();
	  }
	
	  /**
	   * Adds a listener to be invoked when events of the specified type are
	   * emitted. An optional calling context may be provided. The data arguments
	   * emitted will be passed to the listener function.
	   *
	   * TODO: Annotate the listener arg's type. This is tricky because listeners
	   *       can be invoked with varargs.
	   *
	   * @param {string} eventType - Name of the event to listen to
	   * @param {function} listener - Function to invoke when the specified event is
	   *   emitted
	   * @param {*} context - Optional context object to use when invoking the
	   *   listener
	   */
	
	  _createClass(EventEmitter, [{
	    key: 'addListener',
	    value: function addListener(eventType, listener, context) {
	      return this._subscriber.addSubscription(eventType, new _ReactEmitterSubscription2['default'](this._subscriber, listener, context));
	    }
	
	    /**
	     * Similar to addListener, except that the listener is removed after it is
	     * invoked once.
	     *
	     * @param {string} eventType - Name of the event to listen to
	     * @param {function} listener - Function to invoke only once when the
	     *   specified event is emitted
	     * @param {*} context - Optional context object to use when invoking the
	     *   listener
	     */
	  }, {
	    key: 'once',
	    value: function once(eventType, listener, context) {
	      var emitter = this;
	      return this.addListener(eventType, function () {
	        emitter.removeCurrentListener();
	        listener.apply(context, arguments);
	      });
	    }
	
	    /**
	     * Removes all of the registered listeners, including those registered as
	     * listener maps.
	     *
	     * @param {?string} eventType - Optional name of the event whose registered
	     *   listeners to remove
	     */
	  }, {
	    key: 'removeAllListeners',
	    value: function removeAllListeners(eventType) {
	      this._subscriber.removeAllSubscriptions(eventType);
	    }
	
	    /**
	     * Provides an API that can be called during an eventing cycle to remove the
	     * last listener that was invoked. This allows a developer to provide an event
	     * object that can remove the listener (or listener map) during the
	     * invocation.
	     *
	     * If it is called when not inside of an emitting cycle it will throw.
	     *
	     * @throws {Error} When called not during an eventing cycle
	     *
	     * @example
	     *   var subscription = emitter.addListenerMap({
	     *     someEvent: function(data, event) {
	     *       console.log(data);
	     *       emitter.removeCurrentListener();
	     *     }
	     *   });
	     *
	     *   emitter.emit('someEvent', 'abc'); // logs 'abc'
	     *   emitter.emit('someEvent', 'def'); // does not log anything
	     */
	  }, {
	    key: 'removeCurrentListener',
	    value: function removeCurrentListener() {
	      (0, _fbjsLibInvariant2['default'])(!!this._currentSubscription, 'Not in an emitting cycle; there is no current subscription');
	      this._subscriber.removeSubscription(this._currentSubscription);
	    }
	
	    /**
	     * Returns an array of listeners that are currently registered for the given
	     * event.
	     *
	     * @param {string} eventType - Name of the event to query
	     * @returns {array}
	     */
	  }, {
	    key: 'listeners',
	    value: function listeners(eventType) /* TODO: Array<EventSubscription> */{
	      var subscriptions = this._subscriber.getSubscriptionsForType(eventType);
	      return subscriptions ? subscriptions.filter(_fbjsLibEmptyFunction2['default'].thatReturnsTrue).map(function (subscription) {
	        return subscription.listener;
	      }) : [];
	    }
	
	    /**
	     * Emits an event of the given type with the given data. All handlers of that
	     * particular type will be notified.
	     *
	     * @param {string} eventType - Name of the event to emit
	     * @param {...*} Arbitrary arguments to be passed to each registered listener
	     *
	     * @example
	     *   emitter.addListener('someEvent', function(message) {
	     *     console.log(message);
	     *   });
	     *
	     *   emitter.emit('someEvent', 'abc'); // logs 'abc'
	     */
	  }, {
	    key: 'emit',
	    value: function emit(eventType) {
	      var subscriptions = this._subscriber.getSubscriptionsForType(eventType);
	      if (subscriptions) {
	        var keys = Object.keys(subscriptions);
	        for (var ii = 0; ii < keys.length; ii++) {
	          var key = keys[ii];
	          var subscription = subscriptions[key];
	
	          // The subscription may have been removed during this event loop.
	          if (subscription) {
	            this._currentSubscription = subscription;
	
	            _ReactErrorUtils2['default'].applyWithGuard(subscription.listener, subscription.context, Array.prototype.slice.call(arguments, 1), null, 'EventEmitter:' + eventType);
	          }
	        }
	        this._currentSubscription = null;
	      }
	    }
	  }]);
	
	  return EventEmitter;
	})();
	
	module.exports = EventEmitter;

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @generated SignedSource<<d17b6e5d9b7118fb0ed9169f579e5b8a>>
	 *
	 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	 * !! This file is a check-in of a static_upstream project!      !!
	 * !!                                                            !!
	 * !! You should not modify this file directly. Instead:         !!
	 * !! 1) Use `fjs use-upstream` to temporarily replace this with !!
	 * !!    the latest version from upstream.                       !!
	 * !! 2) Make your changes, test them, etc.                      !!
	 * !! 3) Use `fjs push-upstream` to copy your changes back to    !!
	 * !!    static_upstream.                                        !!
	 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	 *
	 * @providesModule ReactEmitterSubscription
	 * @typechecks
	 */
	'use strict';
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _ReactEventSubscription = __webpack_require__(266);
	
	var _ReactEventSubscription2 = _interopRequireDefault(_ReactEventSubscription);
	
	/**
	 * EmitterSubscription represents a subscription with listener and context data.
	 */
	
	var EmitterSubscription = (function (_EventSubscription) {
	  _inherits(EmitterSubscription, _EventSubscription);
	
	  /**
	   * @param {EventSubscriptionVendor} subscriber - The subscriber that controls
	   *   this subscription
	   * @param {function} listener - Function to invoke when the specified event is
	   *   emitted
	   * @param {*} context - Optional context object to use when invoking the
	   *   listener
	   */
	
	  function EmitterSubscription(subscriber, listener, context) {
	    _classCallCheck(this, EmitterSubscription);
	
	    _get(Object.getPrototypeOf(EmitterSubscription.prototype), 'constructor', this).call(this, subscriber);
	    this.listener = listener;
	    this.context = context;
	  }
	
	  return EmitterSubscription;
	})(_ReactEventSubscription2['default']);
	
	module.exports = EmitterSubscription;

/***/ },
/* 266 */
/***/ function(module, exports) {

	/**
	 * @generated SignedSource<<92108a17b1f3eee4b7e3dd7d484aa17a>>
	 *
	 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	 * !! This file is a check-in of a static_upstream project!      !!
	 * !!                                                            !!
	 * !! You should not modify this file directly. Instead:         !!
	 * !! 1) Use `fjs use-upstream` to temporarily replace this with !!
	 * !!    the latest version from upstream.                       !!
	 * !! 2) Make your changes, test them, etc.                      !!
	 * !! 3) Use `fjs push-upstream` to copy your changes back to    !!
	 * !!    static_upstream.                                        !!
	 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	 *
	 * @providesModule ReactEventSubscription
	 * @typechecks
	 */
	'use strict';
	
	/**
	 * EventSubscription represents a subscription to a particular event. It can
	 * remove its own subscription.
	 */
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var EventSubscription = (function () {
	
	  /**
	   * @param {EventSubscriptionVendor} subscriber the subscriber that controls
	   *   this subscription.
	   */
	
	  function EventSubscription(subscriber) {
	    _classCallCheck(this, EventSubscription);
	
	    this.subscriber = subscriber;
	  }
	
	  /**
	   * Removes this subscription from the subscriber that controls it.
	   */
	
	  _createClass(EventSubscription, [{
	    key: 'remove',
	    value: function remove() {
	      this.subscriber.removeSubscription(this);
	    }
	  }]);
	
	  return EventSubscription;
	})();
	
	module.exports = EventSubscription;

/***/ },
/* 267 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * @providesModule ReactErrorUtils
	 */
	
	'use strict';
	
	(function (global) {
	  var ErrorUtils = {
	    _inGuard: 0,
	    _globalHandler: null,
	    setGlobalHandler: function setGlobalHandler(fun) {
	      ErrorUtils._globalHandler = fun;
	    },
	    reportError: function reportError(error) {
	      ErrorUtils._globalHandler && ErrorUtils._globalHandler(error);
	    },
	    reportFatalError: function reportFatalError(error) {
	      ErrorUtils._globalHandler && ErrorUtils._globalHandler(error, true);
	    },
	    applyWithGuard: function applyWithGuard(fun, context, args) {
	      try {
	        ErrorUtils._inGuard++;
	        return fun.apply(context, args);
	      } catch (e) {
	        ErrorUtils.reportError(e);
	      } finally {
	        ErrorUtils._inGuard--;
	      }
	    },
	    applyWithGuardIfNeeded: function applyWithGuardIfNeeded(fun, context, args) {
	      if (ErrorUtils.inGuard()) {
	        return fun.apply(context, args);
	      } else {
	        ErrorUtils.applyWithGuard(fun, context, args);
	      }
	    },
	    inGuard: function inGuard() {
	      return ErrorUtils._inGuard;
	    },
	    guard: function guard(fun, name, context) {
	      if (typeof fun !== 'function') {
	        console.warn('A function must be passed to ErrorUtils.guard, got ', fun);
	        return null;
	      }
	      name = name || fun.name || '<generated guard>';
	      function guarded() {
	        return ErrorUtils.applyWithGuard(fun, context || this, arguments, null, name);
	      }
	
	      return guarded;
	    }
	  };
	  global.ErrorUtils = ErrorUtils;
	
	  /**
	   * This is the error handler that is called when we encounter an exception
	   * when loading a module.
	   */
	  function setupErrorGuard() {
	    var onError = function onError(e) {
	      global.console.error('Error: ' + '\n stack: ' + e.stack + '\n line: ' + e.line + '\n message: ' + e.message, e);
	    };
	    global.ErrorUtils.setGlobalHandler(onError);
	  }
	
	  setupErrorGuard();
	})(window);
	
	module.exports = ErrorUtils;
	/* eslint global-strict:0 */

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @generated SignedSource<<24d5cc1cdd24704296686faf89dd36cf>>
	 *
	 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	 * !! This file is a check-in of a static_upstream project!      !!
	 * !!                                                            !!
	 * !! You should not modify this file directly. Instead:         !!
	 * !! 1) Use `fjs use-upstream` to temporarily replace this with !!
	 * !!    the latest version from upstream.                       !!
	 * !! 2) Make your changes, test them, etc.                      !!
	 * !! 3) Use `fjs push-upstream` to copy your changes back to    !!
	 * !!    static_upstream.                                        !!
	 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	 *
	 * @providesModule ReactEventSubscriptionVendor
	 * @typechecks
	 */
	'use strict';
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _fbjsLibInvariant = __webpack_require__(231);
	
	var _fbjsLibInvariant2 = _interopRequireDefault(_fbjsLibInvariant);
	
	/**
	 * EventSubscriptionVendor stores a set of EventSubscriptions that are
	 * subscribed to a particular event type.
	 */
	
	var EventSubscriptionVendor = (function () {
	  function EventSubscriptionVendor() {
	    _classCallCheck(this, EventSubscriptionVendor);
	
	    this._subscriptionsForType = {};
	    this._currentSubscription = null;
	  }
	
	  /**
	   * Adds a subscription keyed by an event type.
	   *
	   * @param {string} eventType
	   * @param {EventSubscription} subscription
	   */
	
	  _createClass(EventSubscriptionVendor, [{
	    key: 'addSubscription',
	    value: function addSubscription(eventType, subscription) {
	      (0, _fbjsLibInvariant2['default'])(subscription.subscriber === this, 'The subscriber of the subscription is incorrectly set.');
	      if (!this._subscriptionsForType[eventType]) {
	        this._subscriptionsForType[eventType] = [];
	      }
	      var key = this._subscriptionsForType[eventType].length;
	      this._subscriptionsForType[eventType].push(subscription);
	      subscription.eventType = eventType;
	      subscription.key = key;
	      return subscription;
	    }
	
	    /**
	     * Removes a bulk set of the subscriptions.
	     *
	     * @param {?string} eventType - Optional name of the event type whose
	     *   registered supscriptions to remove, if null remove all subscriptions.
	     */
	  }, {
	    key: 'removeAllSubscriptions',
	    value: function removeAllSubscriptions(eventType) {
	      if (eventType === undefined) {
	        this._subscriptionsForType = {};
	      } else {
	        delete this._subscriptionsForType[eventType];
	      }
	    }
	
	    /**
	     * Removes a specific subscription. Instead of calling this function, call
	     * `subscription.remove()` directly.
	     *
	     * @param {object} subscription
	     */
	  }, {
	    key: 'removeSubscription',
	    value: function removeSubscription(subscription) {
	      var eventType = subscription.eventType;
	      var key = subscription.key;
	
	      var subscriptionsForType = this._subscriptionsForType[eventType];
	      if (subscriptionsForType) {
	        delete subscriptionsForType[key];
	      }
	    }
	
	    /**
	     * Returns the array of subscriptions that are currently registered for the
	     * given event type.
	     *
	     * Note: This array can be potentially sparse as subscriptions are deleted
	     * from it when they are removed.
	     *
	     * TODO: This returns a nullable array. wat?
	     *
	     * @param {string} eventType
	     * @returns {?array}
	     */
	  }, {
	    key: 'getSubscriptionsForType',
	    value: function getSubscriptionsForType(eventType) {
	      return this._subscriptionsForType[eventType];
	    }
	  }]);
	
	  return EventSubscriptionVendor;
	})();
	
	module.exports = EventSubscriptionVendor;

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * @providesModule ReactNavigationTreeNode
	 * 
	 * @typechecks
	 */
	
	'use strict';
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _fbjsLibInvariant = __webpack_require__(231);
	
	var _fbjsLibInvariant2 = _interopRequireDefault(_fbjsLibInvariant);
	
	var _immutable = __webpack_require__(270);
	
	/**
	 * Utility to build a tree of nodes.
	 * Note that this tree does not perform cyclic redundancy check
	 * while appending child node.
	 */
	
	var NavigationTreeNode = (function () {
	  function NavigationTreeNode(value) {
	    _classCallCheck(this, NavigationTreeNode);
	
	    this.__parent = null;
	    this._children = new _immutable.List();
	    this._value = value;
	  }
	
	  _createClass(NavigationTreeNode, [{
	    key: 'getValue',
	    value: function getValue() {
	      return this._value;
	    }
	  }, {
	    key: 'getParent',
	    value: function getParent() {
	      return this.__parent;
	    }
	  }, {
	    key: 'getChildrenCount',
	    value: function getChildrenCount() {
	      return this._children.size;
	    }
	  }, {
	    key: 'getChildAt',
	    value: function getChildAt(index) {
	      return index > -1 && index < this._children.size ? this._children.get(index) : null;
	    }
	  }, {
	    key: 'appendChild',
	    value: function appendChild(child) {
	      if (child.__parent) {
	        child.__parent.removeChild(child);
	      }
	      child.__parent = this;
	      this._children = this._children.push(child);
	    }
	  }, {
	    key: 'removeChild',
	    value: function removeChild(child) {
	      var index = this._children.indexOf(child);
	
	      (0, _fbjsLibInvariant2['default'])(index > -1, 'The node to be removed is not a child of this node.');
	
	      child.__parent = null;
	
	      this._children = this._children.splice(index, 1);
	    }
	  }, {
	    key: 'indexOf',
	    value: function indexOf(child) {
	      return this._children.indexOf(child);
	    }
	  }, {
	    key: 'forEach',
	    value: function forEach(callback, context) {
	      this._children.forEach(callback, context);
	    }
	  }, {
	    key: 'map',
	    value: function map(callback, context) {
	      return this._children.map(callback, context).toJS();
	    }
	  }, {
	    key: 'some',
	    value: function some(callback, context) {
	      return this._children.some(callback, context);
	    }
	  }]);
	
	  return NavigationTreeNode;
	})();
	
	module.exports = NavigationTreeNode;

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 *  Copyright (c) 2014-2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */
	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  global.Immutable = factory()
	}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;
	
	  function createClass(ctor, superClass) {
	    if (superClass) {
	      ctor.prototype = Object.create(superClass.prototype);
	    }
	    ctor.prototype.constructor = ctor;
	  }
	
	  // Used for setting prototype methods that IE8 chokes on.
	  var DELETE = 'delete';
	
	  // Constants describing the size of trie nodes.
	  var SHIFT = 5; // Resulted in best performance after ______?
	  var SIZE = 1 << SHIFT;
	  var MASK = SIZE - 1;
	
	  // A consistent shared value representing "not set" which equals nothing other
	  // than itself, and nothing that could be provided externally.
	  var NOT_SET = {};
	
	  // Boolean references, Rough equivalent of `bool &`.
	  var CHANGE_LENGTH = { value: false };
	  var DID_ALTER = { value: false };
	
	  function MakeRef(ref) {
	    ref.value = false;
	    return ref;
	  }
	
	  function SetRef(ref) {
	    ref && (ref.value = true);
	  }
	
	  // A function which returns a value representing an "owner" for transient writes
	  // to tries. The return value will only ever equal itself, and will not equal
	  // the return of any subsequent call of this function.
	  function OwnerID() {}
	
	  // http://jsperf.com/copy-array-inline
	  function arrCopy(arr, offset) {
	    offset = offset || 0;
	    var len = Math.max(0, arr.length - offset);
	    var newArr = new Array(len);
	    for (var ii = 0; ii < len; ii++) {
	      newArr[ii] = arr[ii + offset];
	    }
	    return newArr;
	  }
	
	  function ensureSize(iter) {
	    if (iter.size === undefined) {
	      iter.size = iter.__iterate(returnTrue);
	    }
	    return iter.size;
	  }
	
	  function wrapIndex(iter, index) {
	    // This implements "is array index" which the ECMAString spec defines as:
	    //     A String property name P is an array index if and only if
	    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
	    //     to 2^32−1.
	    // However note that we're currently calling ToNumber() instead of ToUint32()
	    // which should be improved in the future, as floating point numbers should
	    // not be accepted as an array index.
	    if (typeof index !== 'number') {
	      var numIndex = +index;
	      if ('' + numIndex !== index) {
	        return NaN;
	      }
	      index = numIndex;
	    }
	    return index < 0 ? ensureSize(iter) + index : index;
	  }
	
	  function returnTrue() {
	    return true;
	  }
	
	  function wholeSlice(begin, end, size) {
	    return (begin === 0 || (size !== undefined && begin <= -size)) &&
	      (end === undefined || (size !== undefined && end >= size));
	  }
	
	  function resolveBegin(begin, size) {
	    return resolveIndex(begin, size, 0);
	  }
	
	  function resolveEnd(end, size) {
	    return resolveIndex(end, size, size);
	  }
	
	  function resolveIndex(index, size, defaultIndex) {
	    return index === undefined ?
	      defaultIndex :
	      index < 0 ?
	        Math.max(0, size + index) :
	        size === undefined ?
	          index :
	          Math.min(size, index);
	  }
	
	  function Iterable(value) {
	      return isIterable(value) ? value : Seq(value);
	    }
	
	
	  createClass(KeyedIterable, Iterable);
	    function KeyedIterable(value) {
	      return isKeyed(value) ? value : KeyedSeq(value);
	    }
	
	
	  createClass(IndexedIterable, Iterable);
	    function IndexedIterable(value) {
	      return isIndexed(value) ? value : IndexedSeq(value);
	    }
	
	
	  createClass(SetIterable, Iterable);
	    function SetIterable(value) {
	      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
	    }
	
	
	
	  function isIterable(maybeIterable) {
	    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
	  }
	
	  function isKeyed(maybeKeyed) {
	    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
	  }
	
	  function isIndexed(maybeIndexed) {
	    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
	  }
	
	  function isAssociative(maybeAssociative) {
	    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
	  }
	
	  function isOrdered(maybeOrdered) {
	    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
	  }
	
	  Iterable.isIterable = isIterable;
	  Iterable.isKeyed = isKeyed;
	  Iterable.isIndexed = isIndexed;
	  Iterable.isAssociative = isAssociative;
	  Iterable.isOrdered = isOrdered;
	
	  Iterable.Keyed = KeyedIterable;
	  Iterable.Indexed = IndexedIterable;
	  Iterable.Set = SetIterable;
	
	
	  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
	
	  /* global Symbol */
	
	  var ITERATE_KEYS = 0;
	  var ITERATE_VALUES = 1;
	  var ITERATE_ENTRIES = 2;
	
	  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator';
	
	  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
	
	
	  function src_Iterator__Iterator(next) {
	      this.next = next;
	    }
	
	    src_Iterator__Iterator.prototype.toString = function() {
	      return '[Iterator]';
	    };
	
	
	  src_Iterator__Iterator.KEYS = ITERATE_KEYS;
	  src_Iterator__Iterator.VALUES = ITERATE_VALUES;
	  src_Iterator__Iterator.ENTRIES = ITERATE_ENTRIES;
	
	  src_Iterator__Iterator.prototype.inspect =
	  src_Iterator__Iterator.prototype.toSource = function () { return this.toString(); }
	  src_Iterator__Iterator.prototype[ITERATOR_SYMBOL] = function () {
	    return this;
	  };
	
	
	  function iteratorValue(type, k, v, iteratorResult) {
	    var value = type === 0 ? k : type === 1 ? v : [k, v];
	    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
	      value: value, done: false
	    });
	    return iteratorResult;
	  }
	
	  function iteratorDone() {
	    return { value: undefined, done: true };
	  }
	
	  function hasIterator(maybeIterable) {
	    return !!getIteratorFn(maybeIterable);
	  }
	
	  function isIterator(maybeIterator) {
	    return maybeIterator && typeof maybeIterator.next === 'function';
	  }
	
	  function getIterator(iterable) {
	    var iteratorFn = getIteratorFn(iterable);
	    return iteratorFn && iteratorFn.call(iterable);
	  }
	
	  function getIteratorFn(iterable) {
	    var iteratorFn = iterable && (
	      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
	      iterable[FAUX_ITERATOR_SYMBOL]
	    );
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }
	
	  function isArrayLike(value) {
	    return value && typeof value.length === 'number';
	  }
	
	  createClass(Seq, Iterable);
	    function Seq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        isIterable(value) ? value.toSeq() : seqFromValue(value);
	    }
	
	    Seq.of = function(/*...values*/) {
	      return Seq(arguments);
	    };
	
	    Seq.prototype.toSeq = function() {
	      return this;
	    };
	
	    Seq.prototype.toString = function() {
	      return this.__toString('Seq {', '}');
	    };
	
	    Seq.prototype.cacheResult = function() {
	      if (!this._cache && this.__iterateUncached) {
	        this._cache = this.entrySeq().toArray();
	        this.size = this._cache.length;
	      }
	      return this;
	    };
	
	    // abstract __iterateUncached(fn, reverse)
	
	    Seq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, true);
	    };
	
	    // abstract __iteratorUncached(type, reverse)
	
	    Seq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, true);
	    };
	
	
	
	  createClass(KeyedSeq, Seq);
	    function KeyedSeq(value) {
	      return value === null || value === undefined ?
	        emptySequence().toKeyedSeq() :
	        isIterable(value) ?
	          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
	          keyedSeqFromValue(value);
	    }
	
	    KeyedSeq.prototype.toKeyedSeq = function() {
	      return this;
	    };
	
	
	
	  createClass(IndexedSeq, Seq);
	    function IndexedSeq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
	    }
	
	    IndexedSeq.of = function(/*...values*/) {
	      return IndexedSeq(arguments);
	    };
	
	    IndexedSeq.prototype.toIndexedSeq = function() {
	      return this;
	    };
	
	    IndexedSeq.prototype.toString = function() {
	      return this.__toString('Seq [', ']');
	    };
	
	    IndexedSeq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, false);
	    };
	
	    IndexedSeq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, false);
	    };
	
	
	
	  createClass(SetSeq, Seq);
	    function SetSeq(value) {
	      return (
	        value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value
	      ).toSetSeq();
	    }
	
	    SetSeq.of = function(/*...values*/) {
	      return SetSeq(arguments);
	    };
	
	    SetSeq.prototype.toSetSeq = function() {
	      return this;
	    };
	
	
	
	  Seq.isSeq = isSeq;
	  Seq.Keyed = KeyedSeq;
	  Seq.Set = SetSeq;
	  Seq.Indexed = IndexedSeq;
	
	  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';
	
	  Seq.prototype[IS_SEQ_SENTINEL] = true;
	
	
	
	  // #pragma Root Sequences
	
	  createClass(ArraySeq, IndexedSeq);
	    function ArraySeq(array) {
	      this._array = array;
	      this.size = array.length;
	    }
	
	    ArraySeq.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
	    };
	
	    ArraySeq.prototype.__iterate = function(fn, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };
	
	    ArraySeq.prototype.__iterator = function(type, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      var ii = 0;
	      return new src_Iterator__Iterator(function() 
	        {return ii > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
	      );
	    };
	
	
	
	  createClass(ObjectSeq, KeyedSeq);
	    function ObjectSeq(object) {
	      var keys = Object.keys(object);
	      this._object = object;
	      this._keys = keys;
	      this.size = keys.length;
	    }
	
	    ObjectSeq.prototype.get = function(key, notSetValue) {
	      if (notSetValue !== undefined && !this.has(key)) {
	        return notSetValue;
	      }
	      return this._object[key];
	    };
	
	    ObjectSeq.prototype.has = function(key) {
	      return this._object.hasOwnProperty(key);
	    };
	
	    ObjectSeq.prototype.__iterate = function(fn, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        if (fn(object[key], key, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };
	
	    ObjectSeq.prototype.__iterator = function(type, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      var ii = 0;
	      return new src_Iterator__Iterator(function()  {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, key, object[key]);
	      });
	    };
	
	  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;
	
	
	  createClass(IterableSeq, IndexedSeq);
	    function IterableSeq(iterable) {
	      this._iterable = iterable;
	      this.size = iterable.length || iterable.size;
	    }
	
	    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      var iterations = 0;
	      if (isIterator(iterator)) {
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (fn(step.value, iterations++, this) === false) {
	            break;
	          }
	        }
	      }
	      return iterations;
	    };
	
	    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      if (!isIterator(iterator)) {
	        return new src_Iterator__Iterator(iteratorDone);
	      }
	      var iterations = 0;
	      return new src_Iterator__Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step : iteratorValue(type, iterations++, step.value);
	      });
	    };
	
	
	
	  createClass(IteratorSeq, IndexedSeq);
	    function IteratorSeq(iterator) {
	      this._iterator = iterator;
	      this._iteratorCache = [];
	    }
	
	    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      while (iterations < cache.length) {
	        if (fn(cache[iterations], iterations++, this) === false) {
	          return iterations;
	        }
	      }
	      var step;
	      while (!(step = iterator.next()).done) {
	        var val = step.value;
	        cache[iterations] = val;
	        if (fn(val, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	
	    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      return new src_Iterator__Iterator(function()  {
	        if (iterations >= cache.length) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          cache[iterations] = step.value;
	        }
	        return iteratorValue(type, iterations, cache[iterations++]);
	      });
	    };
	
	
	
	
	  // # pragma Helper functions
	
	  function isSeq(maybeSeq) {
	    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
	  }
	
	  var EMPTY_SEQ;
	
	  function emptySequence() {
	    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
	  }
	
	  function keyedSeqFromValue(value) {
	    var seq =
	      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
	      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
	      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
	      typeof value === 'object' ? new ObjectSeq(value) :
	      undefined;
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of [k, v] entries, '+
	        'or keyed object: ' + value
	      );
	    }
	    return seq;
	  }
	
	  function indexedSeqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value);
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values: ' + value
	      );
	    }
	    return seq;
	  }
	
	  function seqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value) ||
	      (typeof value === 'object' && new ObjectSeq(value));
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values, or keyed object: ' + value
	      );
	    }
	    return seq;
	  }
	
	  function maybeIndexedSeqFromValue(value) {
	    return (
	      isArrayLike(value) ? new ArraySeq(value) :
	      isIterator(value) ? new IteratorSeq(value) :
	      hasIterator(value) ? new IterableSeq(value) :
	      undefined
	    );
	  }
	
	  function seqIterate(seq, fn, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    }
	    return seq.__iterateUncached(fn, reverse);
	  }
	
	  function seqIterator(seq, type, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      var ii = 0;
	      return new src_Iterator__Iterator(function()  {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
	      });
	    }
	    return seq.__iteratorUncached(type, reverse);
	  }
	
	  createClass(Collection, Iterable);
	    function Collection() {
	      throw TypeError('Abstract');
	    }
	
	
	  createClass(KeyedCollection, Collection);function KeyedCollection() {}
	
	  createClass(IndexedCollection, Collection);function IndexedCollection() {}
	
	  createClass(SetCollection, Collection);function SetCollection() {}
	
	
	  Collection.Keyed = KeyedCollection;
	  Collection.Indexed = IndexedCollection;
	  Collection.Set = SetCollection;
	
	  /**
	   * An extension of the "same-value" algorithm as [described for use by ES6 Map
	   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
	   *
	   * NaN is considered the same as NaN, however -0 and 0 are considered the same
	   * value, which is different from the algorithm described by
	   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
	   *
	   * This is extended further to allow Objects to describe the values they
	   * represent, by way of `valueOf` or `equals` (and `hashCode`).
	   *
	   * Note: because of this extension, the key equality of Immutable.Map and the
	   * value equality of Immutable.Set will differ from ES6 Map and Set.
	   *
	   * ### Defining custom values
	   *
	   * The easiest way to describe the value an object represents is by implementing
	   * `valueOf`. For example, `Date` represents a value by returning a unix
	   * timestamp for `valueOf`:
	   *
	   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
	   *     var date2 = new Date(1234567890000);
	   *     date1.valueOf(); // 1234567890000
	   *     assert( date1 !== date2 );
	   *     assert( Immutable.is( date1, date2 ) );
	   *
	   * Note: overriding `valueOf` may have other implications if you use this object
	   * where JavaScript expects a primitive, such as implicit string coercion.
	   *
	   * For more complex types, especially collections, implementing `valueOf` may
	   * not be performant. An alternative is to implement `equals` and `hashCode`.
	   *
	   * `equals` takes another object, presumably of similar type, and returns true
	   * if the it is equal. Equality is symmetrical, so the same result should be
	   * returned if this and the argument are flipped.
	   *
	   *     assert( a.equals(b) === b.equals(a) );
	   *
	   * `hashCode` returns a 32bit integer number representing the object which will
	   * be used to determine how to store the value object in a Map or Set. You must
	   * provide both or neither methods, one must not exist without the other.
	   *
	   * Also, an important relationship between these methods must be upheld: if two
	   * values are equal, they *must* return the same hashCode. If the values are not
	   * equal, they might have the same hashCode; this is called a hash collision,
	   * and while undesirable for performance reasons, it is acceptable.
	   *
	   *     if (a.equals(b)) {
	   *       assert( a.hashCode() === b.hashCode() );
	   *     }
	   *
	   * All Immutable collections implement `equals` and `hashCode`.
	   *
	   */
	  function is(valueA, valueB) {
	    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	      return true;
	    }
	    if (!valueA || !valueB) {
	      return false;
	    }
	    if (typeof valueA.valueOf === 'function' &&
	        typeof valueB.valueOf === 'function') {
	      valueA = valueA.valueOf();
	      valueB = valueB.valueOf();
	      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	        return true;
	      }
	      if (!valueA || !valueB) {
	        return false;
	      }
	    }
	    if (typeof valueA.equals === 'function' &&
	        typeof valueB.equals === 'function' &&
	        valueA.equals(valueB)) {
	      return true;
	    }
	    return false;
	  }
	
	  function fromJS(json, converter) {
	    return converter ?
	      fromJSWith(converter, json, '', {'': json}) :
	      fromJSDefault(json);
	  }
	
	  function fromJSWith(converter, json, key, parentJSON) {
	    if (Array.isArray(json)) {
	      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    if (isPlainObj(json)) {
	      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    return json;
	  }
	
	  function fromJSDefault(json) {
	    if (Array.isArray(json)) {
	      return IndexedSeq(json).map(fromJSDefault).toList();
	    }
	    if (isPlainObj(json)) {
	      return KeyedSeq(json).map(fromJSDefault).toMap();
	    }
	    return json;
	  }
	
	  function isPlainObj(value) {
	    return value && (value.constructor === Object || value.constructor === undefined);
	  }
	
	  var src_Math__imul =
	    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
	    Math.imul :
	    function imul(a, b) {
	      a = a | 0; // int
	      b = b | 0; // int
	      var c = a & 0xffff;
	      var d = b & 0xffff;
	      // Shift by 0 fixes the sign on the high part.
	      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
	    };
	
	  // v8 has an optimization for storing 31-bit signed numbers.
	  // Values which have either 00 or 11 as the high order bits qualify.
	  // This function drops the highest order bit in a signed number, maintaining
	  // the sign bit.
	  function smi(i32) {
	    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
	  }
	
	  function hash(o) {
	    if (o === false || o === null || o === undefined) {
	      return 0;
	    }
	    if (typeof o.valueOf === 'function') {
	      o = o.valueOf();
	      if (o === false || o === null || o === undefined) {
	        return 0;
	      }
	    }
	    if (o === true) {
	      return 1;
	    }
	    var type = typeof o;
	    if (type === 'number') {
	      var h = o | 0;
	      if (h !== o) {
	        h ^= o * 0xFFFFFFFF;
	      }
	      while (o > 0xFFFFFFFF) {
	        o /= 0xFFFFFFFF;
	        h ^= o;
	      }
	      return smi(h);
	    }
	    if (type === 'string') {
	      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
	    }
	    if (typeof o.hashCode === 'function') {
	      return o.hashCode();
	    }
	    return hashJSObj(o);
	  }
	
	  function cachedHashString(string) {
	    var hash = stringHashCache[string];
	    if (hash === undefined) {
	      hash = hashString(string);
	      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
	        STRING_HASH_CACHE_SIZE = 0;
	        stringHashCache = {};
	      }
	      STRING_HASH_CACHE_SIZE++;
	      stringHashCache[string] = hash;
	    }
	    return hash;
	  }
	
	  // http://jsperf.com/hashing-strings
	  function hashString(string) {
	    // This is the hash from JVM
	    // The hash code for a string is computed as
	    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
	    // where s[i] is the ith character of the string and n is the length of
	    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
	    // (exclusive) by dropping high bits.
	    var hash = 0;
	    for (var ii = 0; ii < string.length; ii++) {
	      hash = 31 * hash + string.charCodeAt(ii) | 0;
	    }
	    return smi(hash);
	  }
	
	  function hashJSObj(obj) {
	    var hash;
	    if (usingWeakMap) {
	      hash = weakMap.get(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }
	
	    hash = obj[UID_HASH_KEY];
	    if (hash !== undefined) {
	      return hash;
	    }
	
	    if (!canDefineProperty) {
	      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
	      if (hash !== undefined) {
	        return hash;
	      }
	
	      hash = getIENodeHash(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }
	
	    hash = ++objHashUID;
	    if (objHashUID & 0x40000000) {
	      objHashUID = 0;
	    }
	
	    if (usingWeakMap) {
	      weakMap.set(obj, hash);
	    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
	      throw new Error('Non-extensible objects are not allowed as keys.');
	    } else if (canDefineProperty) {
	      Object.defineProperty(obj, UID_HASH_KEY, {
	        'enumerable': false,
	        'configurable': false,
	        'writable': false,
	        'value': hash
	      });
	    } else if (obj.propertyIsEnumerable !== undefined &&
	               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
	      // Since we can't define a non-enumerable property on the object
	      // we'll hijack one of the less-used non-enumerable properties to
	      // save our hash on it. Since this is a function it will not show up in
	      // `JSON.stringify` which is what we want.
	      obj.propertyIsEnumerable = function() {
	        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
	      };
	      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
	    } else if (obj.nodeType !== undefined) {
	      // At this point we couldn't get the IE `uniqueID` to use as a hash
	      // and we couldn't use a non-enumerable property to exploit the
	      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
	      // itself.
	      obj[UID_HASH_KEY] = hash;
	    } else {
	      throw new Error('Unable to set a non-enumerable property on object.');
	    }
	
	    return hash;
	  }
	
	  // Get references to ES5 object methods.
	  var isExtensible = Object.isExtensible;
	
	  // True if Object.defineProperty works as expected. IE8 fails this test.
	  var canDefineProperty = (function() {
	    try {
	      Object.defineProperty({}, '@', {});
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }());
	
	  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
	  // and avoid memory leaks from the IE cloneNode bug.
	  function getIENodeHash(node) {
	    if (node && node.nodeType > 0) {
	      switch (node.nodeType) {
	        case 1: // Element
	          return node.uniqueID;
	        case 9: // Document
	          return node.documentElement && node.documentElement.uniqueID;
	      }
	    }
	  }
	
	  // If possible, use a WeakMap.
	  var usingWeakMap = typeof WeakMap === 'function';
	  var weakMap;
	  if (usingWeakMap) {
	    weakMap = new WeakMap();
	  }
	
	  var objHashUID = 0;
	
	  var UID_HASH_KEY = '__immutablehash__';
	  if (typeof Symbol === 'function') {
	    UID_HASH_KEY = Symbol(UID_HASH_KEY);
	  }
	
	  var STRING_HASH_CACHE_MIN_STRLEN = 16;
	  var STRING_HASH_CACHE_MAX_SIZE = 255;
	  var STRING_HASH_CACHE_SIZE = 0;
	  var stringHashCache = {};
	
	  function invariant(condition, error) {
	    if (!condition) throw new Error(error);
	  }
	
	  function assertNotInfinite(size) {
	    invariant(
	      size !== Infinity,
	      'Cannot perform this action with an infinite size.'
	    );
	  }
	
	  createClass(ToKeyedSequence, KeyedSeq);
	    function ToKeyedSequence(indexed, useKeys) {
	      this._iter = indexed;
	      this._useKeys = useKeys;
	      this.size = indexed.size;
	    }
	
	    ToKeyedSequence.prototype.get = function(key, notSetValue) {
	      return this._iter.get(key, notSetValue);
	    };
	
	    ToKeyedSequence.prototype.has = function(key) {
	      return this._iter.has(key);
	    };
	
	    ToKeyedSequence.prototype.valueSeq = function() {
	      return this._iter.valueSeq();
	    };
	
	    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
	      var reversedSequence = reverseFactory(this, true);
	      if (!this._useKeys) {
	        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
	      }
	      return reversedSequence;
	    };
	
	    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
	      var mappedSequence = mapFactory(this, mapper, context);
	      if (!this._useKeys) {
	        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
	      }
	      return mappedSequence;
	    };
	
	    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var ii;
	      return this._iter.__iterate(
	        this._useKeys ?
	          function(v, k)  {return fn(v, k, this$0)} :
	          ((ii = reverse ? resolveSize(this) : 0),
	            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
	        reverse
	      );
	    };
	
	    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
	      if (this._useKeys) {
	        return this._iter.__iterator(type, reverse);
	      }
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var ii = reverse ? resolveSize(this) : 0;
	      return new src_Iterator__Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
	      });
	    };
	
	  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;
	
	
	  createClass(ToIndexedSequence, IndexedSeq);
	    function ToIndexedSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }
	
	    ToIndexedSequence.prototype.includes = function(value) {
	      return this._iter.includes(value);
	    };
	
	    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
	    };
	
	    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      return new src_Iterator__Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, iterations++, step.value, step)
	      });
	    };
	
	
	
	  createClass(ToSetSequence, SetSeq);
	    function ToSetSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }
	
	    ToSetSequence.prototype.has = function(key) {
	      return this._iter.includes(key);
	    };
	
	    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
	    };
	
	    ToSetSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new src_Iterator__Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, step.value, step.value, step);
	      });
	    };
	
	
	
	  createClass(FromEntriesSequence, KeyedSeq);
	    function FromEntriesSequence(entries) {
	      this._iter = entries;
	      this.size = entries.size;
	    }
	
	    FromEntriesSequence.prototype.entrySeq = function() {
	      return this._iter.toSeq();
	    };
	
	    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(entry ) {
	        // Check if entry exists first so array access doesn't throw for holes
	        // in the parent iteration.
	        if (entry) {
	          validateEntry(entry);
	          var indexedIterable = isIterable(entry);
	          return fn(
	            indexedIterable ? entry.get(1) : entry[1],
	            indexedIterable ? entry.get(0) : entry[0],
	            this$0
	          );
	        }
	      }, reverse);
	    };
	
	    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new src_Iterator__Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          // Check if entry exists first so array access doesn't throw for holes
	          // in the parent iteration.
	          if (entry) {
	            validateEntry(entry);
	            var indexedIterable = isIterable(entry);
	            return iteratorValue(
	              type,
	              indexedIterable ? entry.get(0) : entry[0],
	              indexedIterable ? entry.get(1) : entry[1],
	              step
	            );
	          }
	        }
	      });
	    };
	
	
	  ToIndexedSequence.prototype.cacheResult =
	  ToKeyedSequence.prototype.cacheResult =
	  ToSetSequence.prototype.cacheResult =
	  FromEntriesSequence.prototype.cacheResult =
	    cacheResultThrough;
	
	
	  function flipFactory(iterable) {
	    var flipSequence = makeSequence(iterable);
	    flipSequence._iter = iterable;
	    flipSequence.size = iterable.size;
	    flipSequence.flip = function()  {return iterable};
	    flipSequence.reverse = function () {
	      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
	      reversedSequence.flip = function()  {return iterable.reverse()};
	      return reversedSequence;
	    };
	    flipSequence.has = function(key ) {return iterable.includes(key)};
	    flipSequence.includes = function(key ) {return iterable.has(key)};
	    flipSequence.cacheResult = cacheResultThrough;
	    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
	    }
	    flipSequence.__iteratorUncached = function(type, reverse) {
	      if (type === ITERATE_ENTRIES) {
	        var iterator = iterable.__iterator(type, reverse);
	        return new src_Iterator__Iterator(function()  {
	          var step = iterator.next();
	          if (!step.done) {
	            var k = step.value[0];
	            step.value[0] = step.value[1];
	            step.value[1] = k;
	          }
	          return step;
	        });
	      }
	      return iterable.__iterator(
	        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
	        reverse
	      );
	    }
	    return flipSequence;
	  }
	
	
	  function mapFactory(iterable, mapper, context) {
	    var mappedSequence = makeSequence(iterable);
	    mappedSequence.size = iterable.size;
	    mappedSequence.has = function(key ) {return iterable.has(key)};
	    mappedSequence.get = function(key, notSetValue)  {
	      var v = iterable.get(key, NOT_SET);
	      return v === NOT_SET ?
	        notSetValue :
	        mapper.call(context, v, key, iterable);
	    };
	    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(
	        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
	        reverse
	      );
	    }
	    mappedSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      return new src_Iterator__Iterator(function()  {
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var key = entry[0];
	        return iteratorValue(
	          type,
	          key,
	          mapper.call(context, entry[1], key, iterable),
	          step
	        );
	      });
	    }
	    return mappedSequence;
	  }
	
	
	  function reverseFactory(iterable, useKeys) {
	    var reversedSequence = makeSequence(iterable);
	    reversedSequence._iter = iterable;
	    reversedSequence.size = iterable.size;
	    reversedSequence.reverse = function()  {return iterable};
	    if (iterable.flip) {
	      reversedSequence.flip = function () {
	        var flipSequence = flipFactory(iterable);
	        flipSequence.reverse = function()  {return iterable.flip()};
	        return flipSequence;
	      };
	    }
	    reversedSequence.get = function(key, notSetValue) 
	      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
	    reversedSequence.has = function(key )
	      {return iterable.has(useKeys ? key : -1 - key)};
	    reversedSequence.includes = function(value ) {return iterable.includes(value)};
	    reversedSequence.cacheResult = cacheResultThrough;
	    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
	    };
	    reversedSequence.__iterator =
	      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
	    return reversedSequence;
	  }
	
	
	  function filterFactory(iterable, predicate, context, useKeys) {
	    var filterSequence = makeSequence(iterable);
	    if (useKeys) {
	      filterSequence.has = function(key ) {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
	      };
	      filterSequence.get = function(key, notSetValue)  {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
	          v : notSetValue;
	      };
	    }
	    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      }, reverse);
	      return iterations;
	    };
	    filterSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterations = 0;
	      return new src_Iterator__Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          var key = entry[0];
	          var value = entry[1];
	          if (predicate.call(context, value, key, iterable)) {
	            return iteratorValue(type, useKeys ? key : iterations++, value, step);
	          }
	        }
	      });
	    }
	    return filterSequence;
	  }
	
	
	  function countByFactory(iterable, grouper, context) {
	    var groups = src_Map__Map().asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        0,
	        function(a ) {return a + 1}
	      );
	    });
	    return groups.asImmutable();
	  }
	
	
	  function groupByFactory(iterable, grouper, context) {
	    var isKeyedIter = isKeyed(iterable);
	    var groups = (isOrdered(iterable) ? OrderedMap() : src_Map__Map()).asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
	      );
	    });
	    var coerce = iterableClass(iterable);
	    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
	  }
	
	
	  function sliceFactory(iterable, begin, end, useKeys) {
	    var originalSize = iterable.size;
	
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      end = end | 0;
	    }
	
	    if (wholeSlice(begin, end, originalSize)) {
	      return iterable;
	    }
	
	    var resolvedBegin = resolveBegin(begin, originalSize);
	    var resolvedEnd = resolveEnd(end, originalSize);
	
	    // begin or end will be NaN if they were provided as negative numbers and
	    // this iterable's size is unknown. In that case, cache first so there is
	    // a known size and these do not resolve to NaN.
	    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
	      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
	    }
	
	    // Note: resolvedEnd is undefined when the original sequence's length is
	    // unknown and this slice did not supply an end and should contain all
	    // elements after resolvedBegin.
	    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
	    var resolvedSize = resolvedEnd - resolvedBegin;
	    var sliceSize;
	    if (resolvedSize === resolvedSize) {
	      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
	    }
	
	    var sliceSeq = makeSequence(iterable);
	
	    // If iterable.size is undefined, the size of the realized sliceSeq is
	    // unknown at this point unless the number of items to slice is 0
	    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;
	
	    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
	      sliceSeq.get = function (index, notSetValue) {
	        index = wrapIndex(this, index);
	        return index >= 0 && index < sliceSize ?
	          iterable.get(index + resolvedBegin, notSetValue) :
	          notSetValue;
	      }
	    }
	
	    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (sliceSize === 0) {
	        return 0;
	      }
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var skipped = 0;
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k)  {
	        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
	                 iterations !== sliceSize;
	        }
	      });
	      return iterations;
	    };
	
	    sliceSeq.__iteratorUncached = function(type, reverse) {
	      if (sliceSize !== 0 && reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      // Don't bother instantiating parent iterator if taking 0.
	      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
	      var skipped = 0;
	      var iterations = 0;
	      return new src_Iterator__Iterator(function()  {
	        while (skipped++ < resolvedBegin) {
	          iterator.next();
	        }
	        if (++iterations > sliceSize) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (useKeys || type === ITERATE_VALUES) {
	          return step;
	        } else if (type === ITERATE_KEYS) {
	          return iteratorValue(type, iterations - 1, undefined, step);
	        } else {
	          return iteratorValue(type, iterations - 1, step.value[1], step);
	        }
	      });
	    }
	
	    return sliceSeq;
	  }
	
	
	  function takeWhileFactory(iterable, predicate, context) {
	    var takeSequence = makeSequence(iterable);
	    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c) 
	        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
	      );
	      return iterations;
	    };
	    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterating = true;
	      return new src_Iterator__Iterator(function()  {
	        if (!iterating) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var k = entry[0];
	        var v = entry[1];
	        if (!predicate.call(context, v, k, this$0)) {
	          iterating = false;
	          return iteratorDone();
	        }
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return takeSequence;
	  }
	
	
	  function skipWhileFactory(iterable, predicate, context, useKeys) {
	    var skipSequence = makeSequence(iterable);
	    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      });
	      return iterations;
	    };
	    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var skipping = true;
	      var iterations = 0;
	      return new src_Iterator__Iterator(function()  {
	        var step, k, v;
	        do {
	          step = iterator.next();
	          if (step.done) {
	            if (useKeys || type === ITERATE_VALUES) {
	              return step;
	            } else if (type === ITERATE_KEYS) {
	              return iteratorValue(type, iterations++, undefined, step);
	            } else {
	              return iteratorValue(type, iterations++, step.value[1], step);
	            }
	          }
	          var entry = step.value;
	          k = entry[0];
	          v = entry[1];
	          skipping && (skipping = predicate.call(context, v, k, this$0));
	        } while (skipping);
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return skipSequence;
	  }
	
	
	  function concatFactory(iterable, values) {
	    var isKeyedIterable = isKeyed(iterable);
	    var iters = [iterable].concat(values).map(function(v ) {
	      if (!isIterable(v)) {
	        v = isKeyedIterable ?
	          keyedSeqFromValue(v) :
	          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
	      } else if (isKeyedIterable) {
	        v = KeyedIterable(v);
	      }
	      return v;
	    }).filter(function(v ) {return v.size !== 0});
	
	    if (iters.length === 0) {
	      return iterable;
	    }
	
	    if (iters.length === 1) {
	      var singleton = iters[0];
	      if (singleton === iterable ||
	          isKeyedIterable && isKeyed(singleton) ||
	          isIndexed(iterable) && isIndexed(singleton)) {
	        return singleton;
	      }
	    }
	
	    var concatSeq = new ArraySeq(iters);
	    if (isKeyedIterable) {
	      concatSeq = concatSeq.toKeyedSeq();
	    } else if (!isIndexed(iterable)) {
	      concatSeq = concatSeq.toSetSeq();
	    }
	    concatSeq = concatSeq.flatten(true);
	    concatSeq.size = iters.reduce(
	      function(sum, seq)  {
	        if (sum !== undefined) {
	          var size = seq.size;
	          if (size !== undefined) {
	            return sum + size;
	          }
	        }
	      },
	      0
	    );
	    return concatSeq;
	  }
	
	
	  function flattenFactory(iterable, depth, useKeys) {
	    var flatSequence = makeSequence(iterable);
	    flatSequence.__iterateUncached = function(fn, reverse) {
	      var iterations = 0;
	      var stopped = false;
	      function flatDeep(iter, currentDepth) {var this$0 = this;
	        iter.__iterate(function(v, k)  {
	          if ((!depth || currentDepth < depth) && isIterable(v)) {
	            flatDeep(v, currentDepth + 1);
	          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
	            stopped = true;
	          }
	          return !stopped;
	        }, reverse);
	      }
	      flatDeep(iterable, 0);
	      return iterations;
	    }
	    flatSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(type, reverse);
	      var stack = [];
	      var iterations = 0;
	      return new src_Iterator__Iterator(function()  {
	        while (iterator) {
	          var step = iterator.next();
	          if (step.done !== false) {
	            iterator = stack.pop();
	            continue;
	          }
	          var v = step.value;
	          if (type === ITERATE_ENTRIES) {
	            v = v[1];
	          }
	          if ((!depth || stack.length < depth) && isIterable(v)) {
	            stack.push(iterator);
	            iterator = v.__iterator(type, reverse);
	          } else {
	            return useKeys ? step : iteratorValue(type, iterations++, v, step);
	          }
	        }
	        return iteratorDone();
	      });
	    }
	    return flatSequence;
	  }
	
	
	  function flatMapFactory(iterable, mapper, context) {
	    var coerce = iterableClass(iterable);
	    return iterable.toSeq().map(
	      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
	    ).flatten(true);
	  }
	
	
	  function interposeFactory(iterable, separator) {
	    var interposedSequence = makeSequence(iterable);
	    interposedSequence.size = iterable.size && iterable.size * 2 -1;
	    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k) 
	        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
	        fn(v, iterations++, this$0) !== false},
	        reverse
	      );
	      return iterations;
	    };
	    interposedSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      var step;
	      return new src_Iterator__Iterator(function()  {
	        if (!step || iterations % 2) {
	          step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	        }
	        return iterations % 2 ?
	          iteratorValue(type, iterations++, separator) :
	          iteratorValue(type, iterations++, step.value, step);
	      });
	    };
	    return interposedSequence;
	  }
	
	
	  function sortFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    var isKeyedIterable = isKeyed(iterable);
	    var index = 0;
	    var entries = iterable.toSeq().map(
	      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
	    ).toArray();
	    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
	      isKeyedIterable ?
	      function(v, i)  { entries[i].length = 2; } :
	      function(v, i)  { entries[i] = v[1]; }
	    );
	    return isKeyedIterable ? KeyedSeq(entries) :
	      isIndexed(iterable) ? IndexedSeq(entries) :
	      SetSeq(entries);
	  }
	
	
	  function maxFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    if (mapper) {
	      var entry = iterable.toSeq()
	        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
	        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
	      return entry && entry[0];
	    } else {
	      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
	    }
	  }
	
	  function maxCompare(comparator, a, b) {
	    var comp = comparator(b, a);
	    // b is considered the new max if the comparator declares them equal, but
	    // they are not equal and b is in fact a nullish value.
	    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
	  }
	
	
	  function zipWithFactory(keyIter, zipper, iters) {
	    var zipSequence = makeSequence(keyIter);
	    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
	    // Note: this a generic base implementation of __iterate in terms of
	    // __iterator which may be more generically useful in the future.
	    zipSequence.__iterate = function(fn, reverse) {
	      /* generic:
	      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        iterations++;
	        if (fn(step.value[1], step.value[0], this) === false) {
	          break;
	        }
	      }
	      return iterations;
	      */
	      // indexed:
	      var iterator = this.__iterator(ITERATE_VALUES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        if (fn(step.value, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	    zipSequence.__iteratorUncached = function(type, reverse) {
	      var iterators = iters.map(function(i )
	        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
	      );
	      var iterations = 0;
	      var isDone = false;
	      return new src_Iterator__Iterator(function()  {
	        var steps;
	        if (!isDone) {
	          steps = iterators.map(function(i ) {return i.next()});
	          isDone = steps.some(function(s ) {return s.done});
	        }
	        if (isDone) {
	          return iteratorDone();
	        }
	        return iteratorValue(
	          type,
	          iterations++,
	          zipper.apply(null, steps.map(function(s ) {return s.value}))
	        );
	      });
	    };
	    return zipSequence
	  }
	
	
	  // #pragma Helper Functions
	
	  function reify(iter, seq) {
	    return isSeq(iter) ? seq : iter.constructor(seq);
	  }
	
	  function validateEntry(entry) {
	    if (entry !== Object(entry)) {
	      throw new TypeError('Expected [K, V] tuple: ' + entry);
	    }
	  }
	
	  function resolveSize(iter) {
	    assertNotInfinite(iter.size);
	    return ensureSize(iter);
	  }
	
	  function iterableClass(iterable) {
	    return isKeyed(iterable) ? KeyedIterable :
	      isIndexed(iterable) ? IndexedIterable :
	      SetIterable;
	  }
	
	  function makeSequence(iterable) {
	    return Object.create(
	      (
	        isKeyed(iterable) ? KeyedSeq :
	        isIndexed(iterable) ? IndexedSeq :
	        SetSeq
	      ).prototype
	    );
	  }
	
	  function cacheResultThrough() {
	    if (this._iter.cacheResult) {
	      this._iter.cacheResult();
	      this.size = this._iter.size;
	      return this;
	    } else {
	      return Seq.prototype.cacheResult.call(this);
	    }
	  }
	
	  function defaultComparator(a, b) {
	    return a > b ? 1 : a < b ? -1 : 0;
	  }
	
	  function forceIterator(keyPath) {
	    var iter = getIterator(keyPath);
	    if (!iter) {
	      // Array might not be iterable in this environment, so we need a fallback
	      // to our wrapped type.
	      if (!isArrayLike(keyPath)) {
	        throw new TypeError('Expected iterable or array-like: ' + keyPath);
	      }
	      iter = getIterator(Iterable(keyPath));
	    }
	    return iter;
	  }
	
	  createClass(src_Map__Map, KeyedCollection);
	
	    // @pragma Construction
	
	    function src_Map__Map(value) {
	      return value === null || value === undefined ? emptyMap() :
	        isMap(value) && !isOrdered(value) ? value :
	        emptyMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }
	
	    src_Map__Map.prototype.toString = function() {
	      return this.__toString('Map {', '}');
	    };
	
	    // @pragma Access
	
	    src_Map__Map.prototype.get = function(k, notSetValue) {
	      return this._root ?
	        this._root.get(0, undefined, k, notSetValue) :
	        notSetValue;
	    };
	
	    // @pragma Modification
	
	    src_Map__Map.prototype.set = function(k, v) {
	      return updateMap(this, k, v);
	    };
	
	    src_Map__Map.prototype.setIn = function(keyPath, v) {
	      return this.updateIn(keyPath, NOT_SET, function()  {return v});
	    };
	
	    src_Map__Map.prototype.remove = function(k) {
	      return updateMap(this, k, NOT_SET);
	    };
	
	    src_Map__Map.prototype.deleteIn = function(keyPath) {
	      return this.updateIn(keyPath, function()  {return NOT_SET});
	    };
	
	    src_Map__Map.prototype.update = function(k, notSetValue, updater) {
	      return arguments.length === 1 ?
	        k(this) :
	        this.updateIn([k], notSetValue, updater);
	    };
	
	    src_Map__Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
	      if (!updater) {
	        updater = notSetValue;
	        notSetValue = undefined;
	      }
	      var updatedValue = updateInDeepMap(
	        this,
	        forceIterator(keyPath),
	        notSetValue,
	        updater
	      );
	      return updatedValue === NOT_SET ? undefined : updatedValue;
	    };
	
	    src_Map__Map.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._root = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyMap();
	    };
	
	    // @pragma Composition
	
	    src_Map__Map.prototype.merge = function(/*...iters*/) {
	      return mergeIntoMapWith(this, undefined, arguments);
	    };
	
	    src_Map__Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, merger, iters);
	    };
	
	    src_Map__Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.merge === 'function' ?
	          m.merge.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };
	
	    src_Map__Map.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoMapWith(this, deepMerger(undefined), arguments);
	    };
	
	    src_Map__Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, deepMerger(merger), iters);
	    };
	
	    src_Map__Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.mergeDeep === 'function' ?
	          m.mergeDeep.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };
	
	    src_Map__Map.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator));
	    };
	
	    src_Map__Map.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator, mapper));
	    };
	
	    // @pragma Mutability
	
	    src_Map__Map.prototype.withMutations = function(fn) {
	      var mutable = this.asMutable();
	      fn(mutable);
	      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
	    };
	
	    src_Map__Map.prototype.asMutable = function() {
	      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
	    };
	
	    src_Map__Map.prototype.asImmutable = function() {
	      return this.__ensureOwner();
	    };
	
	    src_Map__Map.prototype.wasAltered = function() {
	      return this.__altered;
	    };
	
	    src_Map__Map.prototype.__iterator = function(type, reverse) {
	      return new MapIterator(this, type, reverse);
	    };
	
	    src_Map__Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      this._root && this._root.iterate(function(entry ) {
	        iterations++;
	        return fn(entry[1], entry[0], this$0);
	      }, reverse);
	      return iterations;
	    };
	
	    src_Map__Map.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeMap(this.size, this._root, ownerID, this.__hash);
	    };
	
	
	  function isMap(maybeMap) {
	    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
	  }
	
	  src_Map__Map.isMap = isMap;
	
	  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';
	
	  var MapPrototype = src_Map__Map.prototype;
	  MapPrototype[IS_MAP_SENTINEL] = true;
	  MapPrototype[DELETE] = MapPrototype.remove;
	  MapPrototype.removeIn = MapPrototype.deleteIn;
	
	
	  // #pragma Trie Nodes
	
	
	
	    function ArrayMapNode(ownerID, entries) {
	      this.ownerID = ownerID;
	      this.entries = entries;
	    }
	
	    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };
	
	    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;
	
	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;
	
	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }
	
	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);
	
	      if (removed && entries.length === 1) {
	        return; // undefined
	      }
	
	      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
	        return createNodes(ownerID, entries, key, value);
	      }
	
	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);
	
	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }
	
	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }
	
	      return new ArrayMapNode(ownerID, newEntries);
	    };
	
	
	
	
	    function BitmapIndexedNode(ownerID, bitmap, nodes) {
	      this.ownerID = ownerID;
	      this.bitmap = bitmap;
	      this.nodes = nodes;
	    }
	
	    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
	      var bitmap = this.bitmap;
	      return (bitmap & bit) === 0 ? notSetValue :
	        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
	    };
	
	    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var bit = 1 << keyHashFrag;
	      var bitmap = this.bitmap;
	      var exists = (bitmap & bit) !== 0;
	
	      if (!exists && value === NOT_SET) {
	        return this;
	      }
	
	      var idx = popCount(bitmap & (bit - 1));
	      var nodes = this.nodes;
	      var node = exists ? nodes[idx] : undefined;
	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	
	      if (newNode === node) {
	        return this;
	      }
	
	      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
	        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
	      }
	
	      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
	        return nodes[idx ^ 1];
	      }
	
	      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
	        return newNode;
	      }
	
	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
	      var newNodes = exists ? newNode ?
	        setIn(nodes, idx, newNode, isEditable) :
	        spliceOut(nodes, idx, isEditable) :
	        spliceIn(nodes, idx, newNode, isEditable);
	
	      if (isEditable) {
	        this.bitmap = newBitmap;
	        this.nodes = newNodes;
	        return this;
	      }
	
	      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
	    };
	
	
	
	
	    function HashArrayMapNode(ownerID, count, nodes) {
	      this.ownerID = ownerID;
	      this.count = count;
	      this.nodes = nodes;
	    }
	
	    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var node = this.nodes[idx];
	      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
	    };
	
	    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var removed = value === NOT_SET;
	      var nodes = this.nodes;
	      var node = nodes[idx];
	
	      if (removed && !node) {
	        return this;
	      }
	
	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	      if (newNode === node) {
	        return this;
	      }
	
	      var newCount = this.count;
	      if (!node) {
	        newCount++;
	      } else if (!newNode) {
	        newCount--;
	        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
	          return packNodes(ownerID, nodes, newCount, idx);
	        }
	      }
	
	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newNodes = setIn(nodes, idx, newNode, isEditable);
	
	      if (isEditable) {
	        this.count = newCount;
	        this.nodes = newNodes;
	        return this;
	      }
	
	      return new HashArrayMapNode(ownerID, newCount, newNodes);
	    };
	
	
	
	
	    function HashCollisionNode(ownerID, keyHash, entries) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entries = entries;
	    }
	
	    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };
	
	    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	
	      var removed = value === NOT_SET;
	
	      if (keyHash !== this.keyHash) {
	        if (removed) {
	          return this;
	        }
	        SetRef(didAlter);
	        SetRef(didChangeSize);
	        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
	      }
	
	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;
	
	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }
	
	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);
	
	      if (removed && len === 2) {
	        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
	      }
	
	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);
	
	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }
	
	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }
	
	      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
	    };
	
	
	
	
	    function ValueNode(ownerID, keyHash, entry) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entry = entry;
	    }
	
	    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
	    };
	
	    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;
	      var keyMatch = is(key, this.entry[0]);
	      if (keyMatch ? value === this.entry[1] : removed) {
	        return this;
	      }
	
	      SetRef(didAlter);
	
	      if (removed) {
	        SetRef(didChangeSize);
	        return; // undefined
	      }
	
	      if (keyMatch) {
	        if (ownerID && ownerID === this.ownerID) {
	          this.entry[1] = value;
	          return this;
	        }
	        return new ValueNode(ownerID, this.keyHash, [key, value]);
	      }
	
	      SetRef(didChangeSize);
	      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
	    };
	
	
	
	  // #pragma Iterators
	
	  ArrayMapNode.prototype.iterate =
	  HashCollisionNode.prototype.iterate = function (fn, reverse) {
	    var entries = this.entries;
	    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
	      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
	        return false;
	      }
	    }
	  }
	
	  BitmapIndexedNode.prototype.iterate =
	  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
	    var nodes = this.nodes;
	    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
	      var node = nodes[reverse ? maxIndex - ii : ii];
	      if (node && node.iterate(fn, reverse) === false) {
	        return false;
	      }
	    }
	  }
	
	  ValueNode.prototype.iterate = function (fn, reverse) {
	    return fn(this.entry);
	  }
	
	  createClass(MapIterator, src_Iterator__Iterator);
	
	    function MapIterator(map, type, reverse) {
	      this._type = type;
	      this._reverse = reverse;
	      this._stack = map._root && mapIteratorFrame(map._root);
	    }
	
	    MapIterator.prototype.next = function() {
	      var type = this._type;
	      var stack = this._stack;
	      while (stack) {
	        var node = stack.node;
	        var index = stack.index++;
	        var maxIndex;
	        if (node.entry) {
	          if (index === 0) {
	            return mapIteratorValue(type, node.entry);
	          }
	        } else if (node.entries) {
	          maxIndex = node.entries.length - 1;
	          if (index <= maxIndex) {
	            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
	          }
	        } else {
	          maxIndex = node.nodes.length - 1;
	          if (index <= maxIndex) {
	            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
	            if (subNode) {
	              if (subNode.entry) {
	                return mapIteratorValue(type, subNode.entry);
	              }
	              stack = this._stack = mapIteratorFrame(subNode, stack);
	            }
	            continue;
	          }
	        }
	        stack = this._stack = this._stack.__prev;
	      }
	      return iteratorDone();
	    };
	
	
	  function mapIteratorValue(type, entry) {
	    return iteratorValue(type, entry[0], entry[1]);
	  }
	
	  function mapIteratorFrame(node, prev) {
	    return {
	      node: node,
	      index: 0,
	      __prev: prev
	    };
	  }
	
	  function makeMap(size, root, ownerID, hash) {
	    var map = Object.create(MapPrototype);
	    map.size = size;
	    map._root = root;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }
	
	  var EMPTY_MAP;
	  function emptyMap() {
	    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
	  }
	
	  function updateMap(map, k, v) {
	    var newRoot;
	    var newSize;
	    if (!map._root) {
	      if (v === NOT_SET) {
	        return map;
	      }
	      newSize = 1;
	      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
	    } else {
	      var didChangeSize = MakeRef(CHANGE_LENGTH);
	      var didAlter = MakeRef(DID_ALTER);
	      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
	      if (!didAlter.value) {
	        return map;
	      }
	      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
	    }
	    if (map.__ownerID) {
	      map.size = newSize;
	      map._root = newRoot;
	      map.__hash = undefined;
	      map.__altered = true;
	      return map;
	    }
	    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
	  }
	
	  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (!node) {
	      if (value === NOT_SET) {
	        return node;
	      }
	      SetRef(didAlter);
	      SetRef(didChangeSize);
	      return new ValueNode(ownerID, keyHash, [key, value]);
	    }
	    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
	  }
	
	  function isLeafNode(node) {
	    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
	  }
	
	  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
	    if (node.keyHash === keyHash) {
	      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
	    }
	
	    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
	    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	
	    var newNode;
	    var nodes = idx1 === idx2 ?
	      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
	      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);
	
	    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
	  }
	
	  function createNodes(ownerID, entries, key, value) {
	    if (!ownerID) {
	      ownerID = new OwnerID();
	    }
	    var node = new ValueNode(ownerID, hash(key), [key, value]);
	    for (var ii = 0; ii < entries.length; ii++) {
	      var entry = entries[ii];
	      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
	    }
	    return node;
	  }
	
	  function packNodes(ownerID, nodes, count, excluding) {
	    var bitmap = 0;
	    var packedII = 0;
	    var packedNodes = new Array(count);
	    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
	      var node = nodes[ii];
	      if (node !== undefined && ii !== excluding) {
	        bitmap |= bit;
	        packedNodes[packedII++] = node;
	      }
	    }
	    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
	  }
	
	  function expandNodes(ownerID, nodes, bitmap, including, node) {
	    var count = 0;
	    var expandedNodes = new Array(SIZE);
	    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
	      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
	    }
	    expandedNodes[including] = node;
	    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
	  }
	
	  function mergeIntoMapWith(map, merger, iterables) {
	    var iters = [];
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = KeyedIterable(value);
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    return mergeIntoCollectionWith(map, merger, iters);
	  }
	
	  function deepMerger(merger) {
	    return function(existing, value, key) 
	      {return existing && existing.mergeDeepWith && isIterable(value) ?
	        existing.mergeDeepWith(merger, value) :
	        merger ? merger(existing, value, key) : value};
	  }
	
	  function mergeIntoCollectionWith(collection, merger, iters) {
	    iters = iters.filter(function(x ) {return x.size !== 0});
	    if (iters.length === 0) {
	      return collection;
	    }
	    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
	      return collection.constructor(iters[0]);
	    }
	    return collection.withMutations(function(collection ) {
	      var mergeIntoMap = merger ?
	        function(value, key)  {
	          collection.update(key, NOT_SET, function(existing )
	            {return existing === NOT_SET ? value : merger(existing, value, key)}
	          );
	        } :
	        function(value, key)  {
	          collection.set(key, value);
	        }
	      for (var ii = 0; ii < iters.length; ii++) {
	        iters[ii].forEach(mergeIntoMap);
	      }
	    });
	  }
	
	  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
	    var isNotSet = existing === NOT_SET;
	    var step = keyPathIter.next();
	    if (step.done) {
	      var existingValue = isNotSet ? notSetValue : existing;
	      var newValue = updater(existingValue);
	      return newValue === existingValue ? existing : newValue;
	    }
	    invariant(
	      isNotSet || (existing && existing.set),
	      'invalid keyPath'
	    );
	    var key = step.value;
	    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
	    var nextUpdated = updateInDeepMap(
	      nextExisting,
	      keyPathIter,
	      notSetValue,
	      updater
	    );
	    return nextUpdated === nextExisting ? existing :
	      nextUpdated === NOT_SET ? existing.remove(key) :
	      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
	  }
	
	  function popCount(x) {
	    x = x - ((x >> 1) & 0x55555555);
	    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
	    x = (x + (x >> 4)) & 0x0f0f0f0f;
	    x = x + (x >> 8);
	    x = x + (x >> 16);
	    return x & 0x7f;
	  }
	
	  function setIn(array, idx, val, canEdit) {
	    var newArray = canEdit ? array : arrCopy(array);
	    newArray[idx] = val;
	    return newArray;
	  }
	
	  function spliceIn(array, idx, val, canEdit) {
	    var newLen = array.length + 1;
	    if (canEdit && idx + 1 === newLen) {
	      array[idx] = val;
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        newArray[ii] = val;
	        after = -1;
	      } else {
	        newArray[ii] = array[ii + after];
	      }
	    }
	    return newArray;
	  }
	
	  function spliceOut(array, idx, canEdit) {
	    var newLen = array.length - 1;
	    if (canEdit && idx === newLen) {
	      array.pop();
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        after = 1;
	      }
	      newArray[ii] = array[ii + after];
	    }
	    return newArray;
	  }
	
	  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
	  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
	  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
	
	  createClass(List, IndexedCollection);
	
	    // @pragma Construction
	
	    function List(value) {
	      var empty = emptyList();
	      if (value === null || value === undefined) {
	        return empty;
	      }
	      if (isList(value)) {
	        return value;
	      }
	      var iter = IndexedIterable(value);
	      var size = iter.size;
	      if (size === 0) {
	        return empty;
	      }
	      assertNotInfinite(size);
	      if (size > 0 && size < SIZE) {
	        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
	      }
	      return empty.withMutations(function(list ) {
	        list.setSize(size);
	        iter.forEach(function(v, i)  {return list.set(i, v)});
	      });
	    }
	
	    List.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    List.prototype.toString = function() {
	      return this.__toString('List [', ']');
	    };
	
	    // @pragma Access
	
	    List.prototype.get = function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      if (index >= 0 && index < this.size) {
	        index += this._origin;
	        var node = listNodeFor(this, index);
	        return node && node.array[index & MASK];
	      }
	      return notSetValue;
	    };
	
	    // @pragma Modification
	
	    List.prototype.set = function(index, value) {
	      return updateList(this, index, value);
	    };
	
	    List.prototype.remove = function(index) {
	      return !this.has(index) ? this :
	        index === 0 ? this.shift() :
	        index === this.size - 1 ? this.pop() :
	        this.splice(index, 1);
	    };
	
	    List.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = this._origin = this._capacity = 0;
	        this._level = SHIFT;
	        this._root = this._tail = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyList();
	    };
	
	    List.prototype.push = function(/*...values*/) {
	      var values = arguments;
	      var oldSize = this.size;
	      return this.withMutations(function(list ) {
	        setListBounds(list, 0, oldSize + values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(oldSize + ii, values[ii]);
	        }
	      });
	    };
	
	    List.prototype.pop = function() {
	      return setListBounds(this, 0, -1);
	    };
	
	    List.prototype.unshift = function(/*...values*/) {
	      var values = arguments;
	      return this.withMutations(function(list ) {
	        setListBounds(list, -values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(ii, values[ii]);
	        }
	      });
	    };
	
	    List.prototype.shift = function() {
	      return setListBounds(this, 1);
	    };
	
	    // @pragma Composition
	
	    List.prototype.merge = function(/*...iters*/) {
	      return mergeIntoListWith(this, undefined, arguments);
	    };
	
	    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, merger, iters);
	    };
	
	    List.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoListWith(this, deepMerger(undefined), arguments);
	    };
	
	    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, deepMerger(merger), iters);
	    };
	
	    List.prototype.setSize = function(size) {
	      return setListBounds(this, 0, size);
	    };
	
	    // @pragma Iteration
	
	    List.prototype.slice = function(begin, end) {
	      var size = this.size;
	      if (wholeSlice(begin, end, size)) {
	        return this;
	      }
	      return setListBounds(
	        this,
	        resolveBegin(begin, size),
	        resolveEnd(end, size)
	      );
	    };
	
	    List.prototype.__iterator = function(type, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      return new src_Iterator__Iterator(function()  {
	        var value = values();
	        return value === DONE ?
	          iteratorDone() :
	          iteratorValue(type, index++, value);
	      });
	    };
	
	    List.prototype.__iterate = function(fn, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      var value;
	      while ((value = values()) !== DONE) {
	        if (fn(value, index++, this) === false) {
	          break;
	        }
	      }
	      return index;
	    };
	
	    List.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        return this;
	      }
	      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
	    };
	
	
	  function isList(maybeList) {
	    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
	  }
	
	  List.isList = isList;
	
	  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';
	
	  var ListPrototype = List.prototype;
	  ListPrototype[IS_LIST_SENTINEL] = true;
	  ListPrototype[DELETE] = ListPrototype.remove;
	  ListPrototype.setIn = MapPrototype.setIn;
	  ListPrototype.deleteIn =
	  ListPrototype.removeIn = MapPrototype.removeIn;
	  ListPrototype.update = MapPrototype.update;
	  ListPrototype.updateIn = MapPrototype.updateIn;
	  ListPrototype.mergeIn = MapPrototype.mergeIn;
	  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  ListPrototype.withMutations = MapPrototype.withMutations;
	  ListPrototype.asMutable = MapPrototype.asMutable;
	  ListPrototype.asImmutable = MapPrototype.asImmutable;
	  ListPrototype.wasAltered = MapPrototype.wasAltered;
	
	
	
	    function VNode(array, ownerID) {
	      this.array = array;
	      this.ownerID = ownerID;
	    }
	
	    // TODO: seems like these methods are very similar
	
	    VNode.prototype.removeBefore = function(ownerID, level, index) {
	      if (index === level ? 1 << level : 0 || this.array.length === 0) {
	        return this;
	      }
	      var originIndex = (index >>> level) & MASK;
	      if (originIndex >= this.array.length) {
	        return new VNode([], ownerID);
	      }
	      var removingFirst = originIndex === 0;
	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[originIndex];
	        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && removingFirst) {
	          return this;
	        }
	      }
	      if (removingFirst && !newChild) {
	        return this;
	      }
	      var editable = editableVNode(this, ownerID);
	      if (!removingFirst) {
	        for (var ii = 0; ii < originIndex; ii++) {
	          editable.array[ii] = undefined;
	        }
	      }
	      if (newChild) {
	        editable.array[originIndex] = newChild;
	      }
	      return editable;
	    };
	
	    VNode.prototype.removeAfter = function(ownerID, level, index) {
	      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
	        return this;
	      }
	      var sizeIndex = ((index - 1) >>> level) & MASK;
	      if (sizeIndex >= this.array.length) {
	        return this;
	      }
	
	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[sizeIndex];
	        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
	          return this;
	        }
	      }
	
	      var editable = editableVNode(this, ownerID);
	      editable.array.splice(sizeIndex + 1);
	      if (newChild) {
	        editable.array[sizeIndex] = newChild;
	      }
	      return editable;
	    };
	
	
	
	  var DONE = {};
	
	  function iterateList(list, reverse) {
	    var left = list._origin;
	    var right = list._capacity;
	    var tailPos = getTailOffset(right);
	    var tail = list._tail;
	
	    return iterateNodeOrLeaf(list._root, list._level, 0);
	
	    function iterateNodeOrLeaf(node, level, offset) {
	      return level === 0 ?
	        iterateLeaf(node, offset) :
	        iterateNode(node, level, offset);
	    }
	
	    function iterateLeaf(node, offset) {
	      var array = offset === tailPos ? tail && tail.array : node && node.array;
	      var from = offset > left ? 0 : left - offset;
	      var to = right - offset;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        if (from === to) {
	          return DONE;
	        }
	        var idx = reverse ? --to : from++;
	        return array && array[idx];
	      };
	    }
	
	    function iterateNode(node, level, offset) {
	      var values;
	      var array = node && node.array;
	      var from = offset > left ? 0 : (left - offset) >> level;
	      var to = ((right - offset) >> level) + 1;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        do {
	          if (values) {
	            var value = values();
	            if (value !== DONE) {
	              return value;
	            }
	            values = null;
	          }
	          if (from === to) {
	            return DONE;
	          }
	          var idx = reverse ? --to : from++;
	          values = iterateNodeOrLeaf(
	            array && array[idx], level - SHIFT, offset + (idx << level)
	          );
	        } while (true);
	      };
	    }
	  }
	
	  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
	    var list = Object.create(ListPrototype);
	    list.size = capacity - origin;
	    list._origin = origin;
	    list._capacity = capacity;
	    list._level = level;
	    list._root = root;
	    list._tail = tail;
	    list.__ownerID = ownerID;
	    list.__hash = hash;
	    list.__altered = false;
	    return list;
	  }
	
	  var EMPTY_LIST;
	  function emptyList() {
	    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
	  }
	
	  function updateList(list, index, value) {
	    index = wrapIndex(list, index);
	
	    if (index !== index) {
	      return list;
	    }
	
	    if (index >= list.size || index < 0) {
	      return list.withMutations(function(list ) {
	        index < 0 ?
	          setListBounds(list, index).set(0, value) :
	          setListBounds(list, 0, index + 1).set(index, value)
	      });
	    }
	
	    index += list._origin;
	
	    var newTail = list._tail;
	    var newRoot = list._root;
	    var didAlter = MakeRef(DID_ALTER);
	    if (index >= getTailOffset(list._capacity)) {
	      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
	    } else {
	      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
	    }
	
	    if (!didAlter.value) {
	      return list;
	    }
	
	    if (list.__ownerID) {
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
	  }
	
	  function updateVNode(node, ownerID, level, index, value, didAlter) {
	    var idx = (index >>> level) & MASK;
	    var nodeHas = node && idx < node.array.length;
	    if (!nodeHas && value === undefined) {
	      return node;
	    }
	
	    var newNode;
	
	    if (level > 0) {
	      var lowerNode = node && node.array[idx];
	      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
	      if (newLowerNode === lowerNode) {
	        return node;
	      }
	      newNode = editableVNode(node, ownerID);
	      newNode.array[idx] = newLowerNode;
	      return newNode;
	    }
	
	    if (nodeHas && node.array[idx] === value) {
	      return node;
	    }
	
	    SetRef(didAlter);
	
	    newNode = editableVNode(node, ownerID);
	    if (value === undefined && idx === newNode.array.length - 1) {
	      newNode.array.pop();
	    } else {
	      newNode.array[idx] = value;
	    }
	    return newNode;
	  }
	
	  function editableVNode(node, ownerID) {
	    if (ownerID && node && ownerID === node.ownerID) {
	      return node;
	    }
	    return new VNode(node ? node.array.slice() : [], ownerID);
	  }
	
	  function listNodeFor(list, rawIndex) {
	    if (rawIndex >= getTailOffset(list._capacity)) {
	      return list._tail;
	    }
	    if (rawIndex < 1 << (list._level + SHIFT)) {
	      var node = list._root;
	      var level = list._level;
	      while (node && level > 0) {
	        node = node.array[(rawIndex >>> level) & MASK];
	        level -= SHIFT;
	      }
	      return node;
	    }
	  }
	
	  function setListBounds(list, begin, end) {
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      end = end | 0;
	    }
	    var owner = list.__ownerID || new OwnerID();
	    var oldOrigin = list._origin;
	    var oldCapacity = list._capacity;
	    var newOrigin = oldOrigin + begin;
	    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
	    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
	      return list;
	    }
	
	    // If it's going to end after it starts, it's empty.
	    if (newOrigin >= newCapacity) {
	      return list.clear();
	    }
	
	    var newLevel = list._level;
	    var newRoot = list._root;
	
	    // New origin might need creating a higher root.
	    var offsetShift = 0;
	    while (newOrigin + offsetShift < 0) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
	      newLevel += SHIFT;
	      offsetShift += 1 << newLevel;
	    }
	    if (offsetShift) {
	      newOrigin += offsetShift;
	      oldOrigin += offsetShift;
	      newCapacity += offsetShift;
	      oldCapacity += offsetShift;
	    }
	
	    var oldTailOffset = getTailOffset(oldCapacity);
	    var newTailOffset = getTailOffset(newCapacity);
	
	    // New size might need creating a higher root.
	    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
	      newLevel += SHIFT;
	    }
	
	    // Locate or create the new tail.
	    var oldTail = list._tail;
	    var newTail = newTailOffset < oldTailOffset ?
	      listNodeFor(list, newCapacity - 1) :
	      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
	
	    // Merge Tail into tree.
	    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
	      newRoot = editableVNode(newRoot, owner);
	      var node = newRoot;
	      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
	        var idx = (oldTailOffset >>> level) & MASK;
	        node = node.array[idx] = editableVNode(node.array[idx], owner);
	      }
	      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
	    }
	
	    // If the size has been reduced, there's a chance the tail needs to be trimmed.
	    if (newCapacity < oldCapacity) {
	      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
	    }
	
	    // If the new origin is within the tail, then we do not need a root.
	    if (newOrigin >= newTailOffset) {
	      newOrigin -= newTailOffset;
	      newCapacity -= newTailOffset;
	      newLevel = SHIFT;
	      newRoot = null;
	      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
	
	    // Otherwise, if the root has been trimmed, garbage collect.
	    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
	      offsetShift = 0;
	
	      // Identify the new top root node of the subtree of the old root.
	      while (newRoot) {
	        var beginIndex = (newOrigin >>> newLevel) & MASK;
	        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
	          break;
	        }
	        if (beginIndex) {
	          offsetShift += (1 << newLevel) * beginIndex;
	        }
	        newLevel -= SHIFT;
	        newRoot = newRoot.array[beginIndex];
	      }
	
	      // Trim the new sides of the new root.
	      if (newRoot && newOrigin > oldOrigin) {
	        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
	      }
	      if (newRoot && newTailOffset < oldTailOffset) {
	        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
	      }
	      if (offsetShift) {
	        newOrigin -= offsetShift;
	        newCapacity -= offsetShift;
	      }
	    }
	
	    if (list.__ownerID) {
	      list.size = newCapacity - newOrigin;
	      list._origin = newOrigin;
	      list._capacity = newCapacity;
	      list._level = newLevel;
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
	  }
	
	  function mergeIntoListWith(list, merger, iterables) {
	    var iters = [];
	    var maxSize = 0;
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = IndexedIterable(value);
	      if (iter.size > maxSize) {
	        maxSize = iter.size;
	      }
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    if (maxSize > list.size) {
	      list = list.setSize(maxSize);
	    }
	    return mergeIntoCollectionWith(list, merger, iters);
	  }
	
	  function getTailOffset(size) {
	    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
	  }
	
	  createClass(OrderedMap, src_Map__Map);
	
	    // @pragma Construction
	
	    function OrderedMap(value) {
	      return value === null || value === undefined ? emptyOrderedMap() :
	        isOrderedMap(value) ? value :
	        emptyOrderedMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }
	
	    OrderedMap.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    OrderedMap.prototype.toString = function() {
	      return this.__toString('OrderedMap {', '}');
	    };
	
	    // @pragma Access
	
	    OrderedMap.prototype.get = function(k, notSetValue) {
	      var index = this._map.get(k);
	      return index !== undefined ? this._list.get(index)[1] : notSetValue;
	    };
	
	    // @pragma Modification
	
	    OrderedMap.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._map.clear();
	        this._list.clear();
	        return this;
	      }
	      return emptyOrderedMap();
	    };
	
	    OrderedMap.prototype.set = function(k, v) {
	      return updateOrderedMap(this, k, v);
	    };
	
	    OrderedMap.prototype.remove = function(k) {
	      return updateOrderedMap(this, k, NOT_SET);
	    };
	
	    OrderedMap.prototype.wasAltered = function() {
	      return this._map.wasAltered() || this._list.wasAltered();
	    };
	
	    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._list.__iterate(
	        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
	        reverse
	      );
	    };
	
	    OrderedMap.prototype.__iterator = function(type, reverse) {
	      return this._list.fromEntrySeq().__iterator(type, reverse);
	    };
	
	    OrderedMap.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      var newList = this._list.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        this._list = newList;
	        return this;
	      }
	      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
	    };
	
	
	  function isOrderedMap(maybeOrderedMap) {
	    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
	  }
	
	  OrderedMap.isOrderedMap = isOrderedMap;
	
	  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
	  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
	
	
	
	  function makeOrderedMap(map, list, ownerID, hash) {
	    var omap = Object.create(OrderedMap.prototype);
	    omap.size = map ? map.size : 0;
	    omap._map = map;
	    omap._list = list;
	    omap.__ownerID = ownerID;
	    omap.__hash = hash;
	    return omap;
	  }
	
	  var EMPTY_ORDERED_MAP;
	  function emptyOrderedMap() {
	    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
	  }
	
	  function updateOrderedMap(omap, k, v) {
	    var map = omap._map;
	    var list = omap._list;
	    var i = map.get(k);
	    var has = i !== undefined;
	    var newMap;
	    var newList;
	    if (v === NOT_SET) { // removed
	      if (!has) {
	        return omap;
	      }
	      if (list.size >= SIZE && list.size >= map.size * 2) {
	        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
	        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
	        if (omap.__ownerID) {
	          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
	        }
	      } else {
	        newMap = map.remove(k);
	        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
	      }
	    } else {
	      if (has) {
	        if (v === list.get(i)[1]) {
	          return omap;
	        }
	        newMap = map;
	        newList = list.set(i, [k, v]);
	      } else {
	        newMap = map.set(k, list.size);
	        newList = list.set(list.size, [k, v]);
	      }
	    }
	    if (omap.__ownerID) {
	      omap.size = newMap.size;
	      omap._map = newMap;
	      omap._list = newList;
	      omap.__hash = undefined;
	      return omap;
	    }
	    return makeOrderedMap(newMap, newList);
	  }
	
	  createClass(Stack, IndexedCollection);
	
	    // @pragma Construction
	
	    function Stack(value) {
	      return value === null || value === undefined ? emptyStack() :
	        isStack(value) ? value :
	        emptyStack().unshiftAll(value);
	    }
	
	    Stack.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    Stack.prototype.toString = function() {
	      return this.__toString('Stack [', ']');
	    };
	
	    // @pragma Access
	
	    Stack.prototype.get = function(index, notSetValue) {
	      var head = this._head;
	      index = wrapIndex(this, index);
	      while (head && index--) {
	        head = head.next;
	      }
	      return head ? head.value : notSetValue;
	    };
	
	    Stack.prototype.peek = function() {
	      return this._head && this._head.value;
	    };
	
	    // @pragma Modification
	
	    Stack.prototype.push = function(/*...values*/) {
	      if (arguments.length === 0) {
	        return this;
	      }
	      var newSize = this.size + arguments.length;
	      var head = this._head;
	      for (var ii = arguments.length - 1; ii >= 0; ii--) {
	        head = {
	          value: arguments[ii],
	          next: head
	        };
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };
	
	    Stack.prototype.pushAll = function(iter) {
	      iter = IndexedIterable(iter);
	      if (iter.size === 0) {
	        return this;
	      }
	      assertNotInfinite(iter.size);
	      var newSize = this.size;
	      var head = this._head;
	      iter.reverse().forEach(function(value ) {
	        newSize++;
	        head = {
	          value: value,
	          next: head
	        };
	      });
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };
	
	    Stack.prototype.pop = function() {
	      return this.slice(1);
	    };
	
	    Stack.prototype.unshift = function(/*...values*/) {
	      return this.push.apply(this, arguments);
	    };
	
	    Stack.prototype.unshiftAll = function(iter) {
	      return this.pushAll(iter);
	    };
	
	    Stack.prototype.shift = function() {
	      return this.pop.apply(this, arguments);
	    };
	
	    Stack.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._head = undefined;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyStack();
	    };
	
	    Stack.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      var resolvedBegin = resolveBegin(begin, this.size);
	      var resolvedEnd = resolveEnd(end, this.size);
	      if (resolvedEnd !== this.size) {
	        // super.slice(begin, end);
	        return IndexedCollection.prototype.slice.call(this, begin, end);
	      }
	      var newSize = this.size - resolvedBegin;
	      var head = this._head;
	      while (resolvedBegin--) {
	        head = head.next;
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };
	
	    // @pragma Mutability
	
	    Stack.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeStack(this.size, this._head, ownerID, this.__hash);
	    };
	
	    // @pragma Iteration
	
	    Stack.prototype.__iterate = function(fn, reverse) {
	      if (reverse) {
	        return this.reverse().__iterate(fn);
	      }
	      var iterations = 0;
	      var node = this._head;
	      while (node) {
	        if (fn(node.value, iterations++, this) === false) {
	          break;
	        }
	        node = node.next;
	      }
	      return iterations;
	    };
	
	    Stack.prototype.__iterator = function(type, reverse) {
	      if (reverse) {
	        return this.reverse().__iterator(type);
	      }
	      var iterations = 0;
	      var node = this._head;
	      return new src_Iterator__Iterator(function()  {
	        if (node) {
	          var value = node.value;
	          node = node.next;
	          return iteratorValue(type, iterations++, value);
	        }
	        return iteratorDone();
	      });
	    };
	
	
	  function isStack(maybeStack) {
	    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
	  }
	
	  Stack.isStack = isStack;
	
	  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';
	
	  var StackPrototype = Stack.prototype;
	  StackPrototype[IS_STACK_SENTINEL] = true;
	  StackPrototype.withMutations = MapPrototype.withMutations;
	  StackPrototype.asMutable = MapPrototype.asMutable;
	  StackPrototype.asImmutable = MapPrototype.asImmutable;
	  StackPrototype.wasAltered = MapPrototype.wasAltered;
	
	
	  function makeStack(size, head, ownerID, hash) {
	    var map = Object.create(StackPrototype);
	    map.size = size;
	    map._head = head;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }
	
	  var EMPTY_STACK;
	  function emptyStack() {
	    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
	  }
	
	  createClass(src_Set__Set, SetCollection);
	
	    // @pragma Construction
	
	    function src_Set__Set(value) {
	      return value === null || value === undefined ? emptySet() :
	        isSet(value) && !isOrdered(value) ? value :
	        emptySet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }
	
	    src_Set__Set.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    src_Set__Set.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };
	
	    src_Set__Set.prototype.toString = function() {
	      return this.__toString('Set {', '}');
	    };
	
	    // @pragma Access
	
	    src_Set__Set.prototype.has = function(value) {
	      return this._map.has(value);
	    };
	
	    // @pragma Modification
	
	    src_Set__Set.prototype.add = function(value) {
	      return updateSet(this, this._map.set(value, true));
	    };
	
	    src_Set__Set.prototype.remove = function(value) {
	      return updateSet(this, this._map.remove(value));
	    };
	
	    src_Set__Set.prototype.clear = function() {
	      return updateSet(this, this._map.clear());
	    };
	
	    // @pragma Composition
	
	    src_Set__Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
	      iters = iters.filter(function(x ) {return x.size !== 0});
	      if (iters.length === 0) {
	        return this;
	      }
	      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
	        return this.constructor(iters[0]);
	      }
	      return this.withMutations(function(set ) {
	        for (var ii = 0; ii < iters.length; ii++) {
	          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
	        }
	      });
	    };
	
	    src_Set__Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (!iters.every(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };
	
	    src_Set__Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (iters.some(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };
	
	    src_Set__Set.prototype.merge = function() {
	      return this.union.apply(this, arguments);
	    };
	
	    src_Set__Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return this.union.apply(this, iters);
	    };
	
	    src_Set__Set.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator));
	    };
	
	    src_Set__Set.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator, mapper));
	    };
	
	    src_Set__Set.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };
	
	    src_Set__Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
	    };
	
	    src_Set__Set.prototype.__iterator = function(type, reverse) {
	      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
	    };
	
	    src_Set__Set.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return this.__make(newMap, ownerID);
	    };
	
	
	  function isSet(maybeSet) {
	    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
	  }
	
	  src_Set__Set.isSet = isSet;
	
	  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';
	
	  var SetPrototype = src_Set__Set.prototype;
	  SetPrototype[IS_SET_SENTINEL] = true;
	  SetPrototype[DELETE] = SetPrototype.remove;
	  SetPrototype.mergeDeep = SetPrototype.merge;
	  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
	  SetPrototype.withMutations = MapPrototype.withMutations;
	  SetPrototype.asMutable = MapPrototype.asMutable;
	  SetPrototype.asImmutable = MapPrototype.asImmutable;
	
	  SetPrototype.__empty = emptySet;
	  SetPrototype.__make = makeSet;
	
	  function updateSet(set, newMap) {
	    if (set.__ownerID) {
	      set.size = newMap.size;
	      set._map = newMap;
	      return set;
	    }
	    return newMap === set._map ? set :
	      newMap.size === 0 ? set.__empty() :
	      set.__make(newMap);
	  }
	
	  function makeSet(map, ownerID) {
	    var set = Object.create(SetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }
	
	  var EMPTY_SET;
	  function emptySet() {
	    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
	  }
	
	  createClass(OrderedSet, src_Set__Set);
	
	    // @pragma Construction
	
	    function OrderedSet(value) {
	      return value === null || value === undefined ? emptyOrderedSet() :
	        isOrderedSet(value) ? value :
	        emptyOrderedSet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }
	
	    OrderedSet.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    OrderedSet.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };
	
	    OrderedSet.prototype.toString = function() {
	      return this.__toString('OrderedSet {', '}');
	    };
	
	
	  function isOrderedSet(maybeOrderedSet) {
	    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
	  }
	
	  OrderedSet.isOrderedSet = isOrderedSet;
	
	  var OrderedSetPrototype = OrderedSet.prototype;
	  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;
	
	  OrderedSetPrototype.__empty = emptyOrderedSet;
	  OrderedSetPrototype.__make = makeOrderedSet;
	
	  function makeOrderedSet(map, ownerID) {
	    var set = Object.create(OrderedSetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }
	
	  var EMPTY_ORDERED_SET;
	  function emptyOrderedSet() {
	    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
	  }
	
	  createClass(Record, KeyedCollection);
	
	    function Record(defaultValues, name) {
	      var hasInitialized;
	
	      var RecordType = function Record(values) {
	        if (values instanceof RecordType) {
	          return values;
	        }
	        if (!(this instanceof RecordType)) {
	          return new RecordType(values);
	        }
	        if (!hasInitialized) {
	          hasInitialized = true;
	          var keys = Object.keys(defaultValues);
	          setProps(RecordTypePrototype, keys);
	          RecordTypePrototype.size = keys.length;
	          RecordTypePrototype._name = name;
	          RecordTypePrototype._keys = keys;
	          RecordTypePrototype._defaultValues = defaultValues;
	        }
	        this._map = src_Map__Map(values);
	      };
	
	      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
	      RecordTypePrototype.constructor = RecordType;
	
	      return RecordType;
	    }
	
	    Record.prototype.toString = function() {
	      return this.__toString(recordName(this) + ' {', '}');
	    };
	
	    // @pragma Access
	
	    Record.prototype.has = function(k) {
	      return this._defaultValues.hasOwnProperty(k);
	    };
	
	    Record.prototype.get = function(k, notSetValue) {
	      if (!this.has(k)) {
	        return notSetValue;
	      }
	      var defaultVal = this._defaultValues[k];
	      return this._map ? this._map.get(k, defaultVal) : defaultVal;
	    };
	
	    // @pragma Modification
	
	    Record.prototype.clear = function() {
	      if (this.__ownerID) {
	        this._map && this._map.clear();
	        return this;
	      }
	      var RecordType = this.constructor;
	      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
	    };
	
	    Record.prototype.set = function(k, v) {
	      if (!this.has(k)) {
	        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
	      }
	      var newMap = this._map && this._map.set(k, v);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };
	
	    Record.prototype.remove = function(k) {
	      if (!this.has(k)) {
	        return this;
	      }
	      var newMap = this._map && this._map.remove(k);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };
	
	    Record.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };
	
	    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
	    };
	
	    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
	    };
	
	    Record.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map && this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return makeRecord(this, newMap, ownerID);
	    };
	
	
	  var RecordPrototype = Record.prototype;
	  RecordPrototype[DELETE] = RecordPrototype.remove;
	  RecordPrototype.deleteIn =
	  RecordPrototype.removeIn = MapPrototype.removeIn;
	  RecordPrototype.merge = MapPrototype.merge;
	  RecordPrototype.mergeWith = MapPrototype.mergeWith;
	  RecordPrototype.mergeIn = MapPrototype.mergeIn;
	  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
	  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
	  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  RecordPrototype.setIn = MapPrototype.setIn;
	  RecordPrototype.update = MapPrototype.update;
	  RecordPrototype.updateIn = MapPrototype.updateIn;
	  RecordPrototype.withMutations = MapPrototype.withMutations;
	  RecordPrototype.asMutable = MapPrototype.asMutable;
	  RecordPrototype.asImmutable = MapPrototype.asImmutable;
	
	
	  function makeRecord(likeRecord, map, ownerID) {
	    var record = Object.create(Object.getPrototypeOf(likeRecord));
	    record._map = map;
	    record.__ownerID = ownerID;
	    return record;
	  }
	
	  function recordName(record) {
	    return record._name || record.constructor.name || 'Record';
	  }
	
	  function setProps(prototype, names) {
	    try {
	      names.forEach(setProp.bind(undefined, prototype));
	    } catch (error) {
	      // Object.defineProperty failed. Probably IE8.
	    }
	  }
	
	  function setProp(prototype, name) {
	    Object.defineProperty(prototype, name, {
	      get: function() {
	        return this.get(name);
	      },
	      set: function(value) {
	        invariant(this.__ownerID, 'Cannot set on an immutable record.');
	        this.set(name, value);
	      }
	    });
	  }
	
	  function deepEqual(a, b) {
	    if (a === b) {
	      return true;
	    }
	
	    if (
	      !isIterable(b) ||
	      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
	      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
	      isKeyed(a) !== isKeyed(b) ||
	      isIndexed(a) !== isIndexed(b) ||
	      isOrdered(a) !== isOrdered(b)
	    ) {
	      return false;
	    }
	
	    if (a.size === 0 && b.size === 0) {
	      return true;
	    }
	
	    var notAssociative = !isAssociative(a);
	
	    if (isOrdered(a)) {
	      var entries = a.entries();
	      return b.every(function(v, k)  {
	        var entry = entries.next().value;
	        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
	      }) && entries.next().done;
	    }
	
	    var flipped = false;
	
	    if (a.size === undefined) {
	      if (b.size === undefined) {
	        if (typeof a.cacheResult === 'function') {
	          a.cacheResult();
	        }
	      } else {
	        flipped = true;
	        var _ = a;
	        a = b;
	        b = _;
	      }
	    }
	
	    var allEqual = true;
	    var bSize = b.__iterate(function(v, k)  {
	      if (notAssociative ? !a.has(v) :
	          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
	        allEqual = false;
	        return false;
	      }
	    });
	
	    return allEqual && a.size === bSize;
	  }
	
	  createClass(Range, IndexedSeq);
	
	    function Range(start, end, step) {
	      if (!(this instanceof Range)) {
	        return new Range(start, end, step);
	      }
	      invariant(step !== 0, 'Cannot step a Range by 0');
	      start = start || 0;
	      if (end === undefined) {
	        end = Infinity;
	      }
	      step = step === undefined ? 1 : Math.abs(step);
	      if (end < start) {
	        step = -step;
	      }
	      this._start = start;
	      this._end = end;
	      this._step = step;
	      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
	      if (this.size === 0) {
	        if (EMPTY_RANGE) {
	          return EMPTY_RANGE;
	        }
	        EMPTY_RANGE = this;
	      }
	    }
	
	    Range.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Range []';
	      }
	      return 'Range [ ' +
	        this._start + '...' + this._end +
	        (this._step > 1 ? ' by ' + this._step : '') +
	      ' ]';
	    };
	
	    Range.prototype.get = function(index, notSetValue) {
	      return this.has(index) ?
	        this._start + wrapIndex(this, index) * this._step :
	        notSetValue;
	    };
	
	    Range.prototype.includes = function(searchValue) {
	      var possibleIndex = (searchValue - this._start) / this._step;
	      return possibleIndex >= 0 &&
	        possibleIndex < this.size &&
	        possibleIndex === Math.floor(possibleIndex);
	    };
	
	    Range.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      begin = resolveBegin(begin, this.size);
	      end = resolveEnd(end, this.size);
	      if (end <= begin) {
	        return new Range(0, 0);
	      }
	      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
	    };
	
	    Range.prototype.indexOf = function(searchValue) {
	      var offsetValue = searchValue - this._start;
	      if (offsetValue % this._step === 0) {
	        var index = offsetValue / this._step;
	        if (index >= 0 && index < this.size) {
	          return index
	        }
	      }
	      return -1;
	    };
	
	    Range.prototype.lastIndexOf = function(searchValue) {
	      return this.indexOf(searchValue);
	    };
	
	    Range.prototype.__iterate = function(fn, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(value, ii, this) === false) {
	          return ii + 1;
	        }
	        value += reverse ? -step : step;
	      }
	      return ii;
	    };
	
	    Range.prototype.__iterator = function(type, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      var ii = 0;
	      return new src_Iterator__Iterator(function()  {
	        var v = value;
	        value += reverse ? -step : step;
	        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
	      });
	    };
	
	    Range.prototype.equals = function(other) {
	      return other instanceof Range ?
	        this._start === other._start &&
	        this._end === other._end &&
	        this._step === other._step :
	        deepEqual(this, other);
	    };
	
	
	  var EMPTY_RANGE;
	
	  createClass(Repeat, IndexedSeq);
	
	    function Repeat(value, times) {
	      if (!(this instanceof Repeat)) {
	        return new Repeat(value, times);
	      }
	      this._value = value;
	      this.size = times === undefined ? Infinity : Math.max(0, times);
	      if (this.size === 0) {
	        if (EMPTY_REPEAT) {
	          return EMPTY_REPEAT;
	        }
	        EMPTY_REPEAT = this;
	      }
	    }
	
	    Repeat.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Repeat []';
	      }
	      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
	    };
	
	    Repeat.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._value : notSetValue;
	    };
	
	    Repeat.prototype.includes = function(searchValue) {
	      return is(this._value, searchValue);
	    };
	
	    Repeat.prototype.slice = function(begin, end) {
	      var size = this.size;
	      return wholeSlice(begin, end, size) ? this :
	        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
	    };
	
	    Repeat.prototype.reverse = function() {
	      return this;
	    };
	
	    Repeat.prototype.indexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return 0;
	      }
	      return -1;
	    };
	
	    Repeat.prototype.lastIndexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return this.size;
	      }
	      return -1;
	    };
	
	    Repeat.prototype.__iterate = function(fn, reverse) {
	      for (var ii = 0; ii < this.size; ii++) {
	        if (fn(this._value, ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };
	
	    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      var ii = 0;
	      return new src_Iterator__Iterator(function() 
	        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
	      );
	    };
	
	    Repeat.prototype.equals = function(other) {
	      return other instanceof Repeat ?
	        is(this._value, other._value) :
	        deepEqual(other);
	    };
	
	
	  var EMPTY_REPEAT;
	
	  /**
	   * Contributes additional methods to a constructor
	   */
	  function mixin(ctor, methods) {
	    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
	    Object.keys(methods).forEach(keyCopier);
	    Object.getOwnPropertySymbols &&
	      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
	    return ctor;
	  }
	
	  Iterable.Iterator = src_Iterator__Iterator;
	
	  mixin(Iterable, {
	
	    // ### Conversion to other types
	
	    toArray: function() {
	      assertNotInfinite(this.size);
	      var array = new Array(this.size || 0);
	      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
	      return array;
	    },
	
	    toIndexedSeq: function() {
	      return new ToIndexedSequence(this);
	    },
	
	    toJS: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
	      ).__toJS();
	    },
	
	    toJSON: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
	      ).__toJS();
	    },
	
	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, true);
	    },
	
	    toMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return src_Map__Map(this.toKeyedSeq());
	    },
	
	    toObject: function() {
	      assertNotInfinite(this.size);
	      var object = {};
	      this.__iterate(function(v, k)  { object[k] = v; });
	      return object;
	    },
	
	    toOrderedMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedMap(this.toKeyedSeq());
	    },
	
	    toOrderedSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	    toSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return src_Set__Set(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	    toSetSeq: function() {
	      return new ToSetSequence(this);
	    },
	
	    toSeq: function() {
	      return isIndexed(this) ? this.toIndexedSeq() :
	        isKeyed(this) ? this.toKeyedSeq() :
	        this.toSetSeq();
	    },
	
	    toStack: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Stack(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	    toList: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return List(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	
	    // ### Common JavaScript methods and properties
	
	    toString: function() {
	      return '[Iterable]';
	    },
	
	    __toString: function(head, tail) {
	      if (this.size === 0) {
	        return head + tail;
	      }
	      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
	    },
	
	
	    // ### ES6 Collection methods (ES6 Array and Map)
	
	    concat: function() {var values = SLICE$0.call(arguments, 0);
	      return reify(this, concatFactory(this, values));
	    },
	
	    includes: function(searchValue) {
	      return this.some(function(value ) {return is(value, searchValue)});
	    },
	
	    entries: function() {
	      return this.__iterator(ITERATE_ENTRIES);
	    },
	
	    every: function(predicate, context) {
	      assertNotInfinite(this.size);
	      var returnValue = true;
	      this.__iterate(function(v, k, c)  {
	        if (!predicate.call(context, v, k, c)) {
	          returnValue = false;
	          return false;
	        }
	      });
	      return returnValue;
	    },
	
	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, true));
	    },
	
	    find: function(predicate, context, notSetValue) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[1] : notSetValue;
	    },
	
	    findEntry: function(predicate, context) {
	      var found;
	      this.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          found = [k, v];
	          return false;
	        }
	      });
	      return found;
	    },
	
	    findLastEntry: function(predicate, context) {
	      return this.toSeq().reverse().findEntry(predicate, context);
	    },
	
	    forEach: function(sideEffect, context) {
	      assertNotInfinite(this.size);
	      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
	    },
	
	    join: function(separator) {
	      assertNotInfinite(this.size);
	      separator = separator !== undefined ? '' + separator : ',';
	      var joined = '';
	      var isFirst = true;
	      this.__iterate(function(v ) {
	        isFirst ? (isFirst = false) : (joined += separator);
	        joined += v !== null && v !== undefined ? v.toString() : '';
	      });
	      return joined;
	    },
	
	    keys: function() {
	      return this.__iterator(ITERATE_KEYS);
	    },
	
	    map: function(mapper, context) {
	      return reify(this, mapFactory(this, mapper, context));
	    },
	
	    reduce: function(reducer, initialReduction, context) {
	      assertNotInfinite(this.size);
	      var reduction;
	      var useFirst;
	      if (arguments.length < 2) {
	        useFirst = true;
	      } else {
	        reduction = initialReduction;
	      }
	      this.__iterate(function(v, k, c)  {
	        if (useFirst) {
	          useFirst = false;
	          reduction = v;
	        } else {
	          reduction = reducer.call(context, reduction, v, k, c);
	        }
	      });
	      return reduction;
	    },
	
	    reduceRight: function(reducer, initialReduction, context) {
	      var reversed = this.toKeyedSeq().reverse();
	      return reversed.reduce.apply(reversed, arguments);
	    },
	
	    reverse: function() {
	      return reify(this, reverseFactory(this, true));
	    },
	
	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, true));
	    },
	
	    some: function(predicate, context) {
	      return !this.every(not(predicate), context);
	    },
	
	    sort: function(comparator) {
	      return reify(this, sortFactory(this, comparator));
	    },
	
	    values: function() {
	      return this.__iterator(ITERATE_VALUES);
	    },
	
	
	    // ### More sequential methods
	
	    butLast: function() {
	      return this.slice(0, -1);
	    },
	
	    isEmpty: function() {
	      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
	    },
	
	    count: function(predicate, context) {
	      return ensureSize(
	        predicate ? this.toSeq().filter(predicate, context) : this
	      );
	    },
	
	    countBy: function(grouper, context) {
	      return countByFactory(this, grouper, context);
	    },
	
	    equals: function(other) {
	      return deepEqual(this, other);
	    },
	
	    entrySeq: function() {
	      var iterable = this;
	      if (iterable._cache) {
	        // We cache as an entries array, so we can just return the cache!
	        return new ArraySeq(iterable._cache);
	      }
	      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
	      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
	      return entriesSequence;
	    },
	
	    filterNot: function(predicate, context) {
	      return this.filter(not(predicate), context);
	    },
	
	    findLast: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
	    },
	
	    first: function() {
	      return this.find(returnTrue);
	    },
	
	    flatMap: function(mapper, context) {
	      return reify(this, flatMapFactory(this, mapper, context));
	    },
	
	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, true));
	    },
	
	    fromEntrySeq: function() {
	      return new FromEntriesSequence(this);
	    },
	
	    get: function(searchKey, notSetValue) {
	      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
	    },
	
	    getIn: function(searchKeyPath, notSetValue) {
	      var nested = this;
	      // Note: in an ES6 environment, we would prefer:
	      // for (var key of searchKeyPath) {
	      var iter = forceIterator(searchKeyPath);
	      var step;
	      while (!(step = iter.next()).done) {
	        var key = step.value;
	        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
	        if (nested === NOT_SET) {
	          return notSetValue;
	        }
	      }
	      return nested;
	    },
	
	    groupBy: function(grouper, context) {
	      return groupByFactory(this, grouper, context);
	    },
	
	    has: function(searchKey) {
	      return this.get(searchKey, NOT_SET) !== NOT_SET;
	    },
	
	    hasIn: function(searchKeyPath) {
	      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
	    },
	
	    isSubset: function(iter) {
	      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
	      return this.every(function(value ) {return iter.includes(value)});
	    },
	
	    isSuperset: function(iter) {
	      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
	      return iter.isSubset(this);
	    },
	
	    keySeq: function() {
	      return this.toSeq().map(keyMapper).toIndexedSeq();
	    },
	
	    last: function() {
	      return this.toSeq().reverse().first();
	    },
	
	    max: function(comparator) {
	      return maxFactory(this, comparator);
	    },
	
	    maxBy: function(mapper, comparator) {
	      return maxFactory(this, comparator, mapper);
	    },
	
	    min: function(comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
	    },
	
	    minBy: function(mapper, comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
	    },
	
	    rest: function() {
	      return this.slice(1);
	    },
	
	    skip: function(amount) {
	      return this.slice(Math.max(0, amount));
	    },
	
	    skipLast: function(amount) {
	      return reify(this, this.toSeq().reverse().skip(amount).reverse());
	    },
	
	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, true));
	    },
	
	    skipUntil: function(predicate, context) {
	      return this.skipWhile(not(predicate), context);
	    },
	
	    sortBy: function(mapper, comparator) {
	      return reify(this, sortFactory(this, comparator, mapper));
	    },
	
	    take: function(amount) {
	      return this.slice(0, Math.max(0, amount));
	    },
	
	    takeLast: function(amount) {
	      return reify(this, this.toSeq().reverse().take(amount).reverse());
	    },
	
	    takeWhile: function(predicate, context) {
	      return reify(this, takeWhileFactory(this, predicate, context));
	    },
	
	    takeUntil: function(predicate, context) {
	      return this.takeWhile(not(predicate), context);
	    },
	
	    valueSeq: function() {
	      return this.toIndexedSeq();
	    },
	
	
	    // ### Hashable Object
	
	    hashCode: function() {
	      return this.__hash || (this.__hash = hashIterable(this));
	    }
	
	
	    // ### Internal
	
	    // abstract __iterate(fn, reverse)
	
	    // abstract __iterator(type, reverse)
	  });
	
	  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
	
	  var IterablePrototype = Iterable.prototype;
	  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
	  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
	  IterablePrototype.__toJS = IterablePrototype.toArray;
	  IterablePrototype.__toStringMapper = quoteString;
	  IterablePrototype.inspect =
	  IterablePrototype.toSource = function() { return this.toString(); };
	  IterablePrototype.chain = IterablePrototype.flatMap;
	  IterablePrototype.contains = IterablePrototype.includes;
	
	  // Temporary warning about using length
	  (function () {
	    try {
	      Object.defineProperty(IterablePrototype, 'length', {
	        get: function () {
	          if (!Iterable.noLengthWarning) {
	            var stack;
	            try {
	              throw new Error();
	            } catch (error) {
	              stack = error.stack;
	            }
	            if (stack.indexOf('_wrapObject') === -1) {
	              console && console.warn && console.warn(
	                'iterable.length has been deprecated, '+
	                'use iterable.size or iterable.count(). '+
	                'This warning will become a silent error in a future version. ' +
	                stack
	              );
	              return this.size;
	            }
	          }
	        }
	      });
	    } catch (e) {}
	  })();
	
	
	
	  mixin(KeyedIterable, {
	
	    // ### More sequential methods
	
	    flip: function() {
	      return reify(this, flipFactory(this));
	    },
	
	    findKey: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry && entry[0];
	    },
	
	    findLastKey: function(predicate, context) {
	      return this.toSeq().reverse().findKey(predicate, context);
	    },
	
	    keyOf: function(searchValue) {
	      return this.findKey(function(value ) {return is(value, searchValue)});
	    },
	
	    lastKeyOf: function(searchValue) {
	      return this.findLastKey(function(value ) {return is(value, searchValue)});
	    },
	
	    mapEntries: function(mapper, context) {var this$0 = this;
	      var iterations = 0;
	      return reify(this,
	        this.toSeq().map(
	          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
	        ).fromEntrySeq()
	      );
	    },
	
	    mapKeys: function(mapper, context) {var this$0 = this;
	      return reify(this,
	        this.toSeq().flip().map(
	          function(k, v)  {return mapper.call(context, k, v, this$0)}
	        ).flip()
	      );
	    }
	
	  });
	
	  var KeyedIterablePrototype = KeyedIterable.prototype;
	  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
	  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
	  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
	  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};
	
	
	
	  mixin(IndexedIterable, {
	
	    // ### Conversion to other types
	
	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, false);
	    },
	
	
	    // ### ES6 Collection methods (ES6 Array and Map)
	
	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, false));
	    },
	
	    findIndex: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },
	
	    indexOf: function(searchValue) {
	      var key = this.toKeyedSeq().keyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },
	
	    lastIndexOf: function(searchValue) {
	      return this.toSeq().reverse().indexOf(searchValue);
	    },
	
	    reverse: function() {
	      return reify(this, reverseFactory(this, false));
	    },
	
	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, false));
	    },
	
	    splice: function(index, removeNum /*, ...values*/) {
	      var numArgs = arguments.length;
	      removeNum = Math.max(removeNum | 0, 0);
	      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
	        return this;
	      }
	      // If index is negative, it should resolve relative to the size of the
	      // collection. However size may be expensive to compute if not cached, so
	      // only call count() if the number is in fact negative.
	      index = resolveBegin(index, index < 0 ? this.count() : this.size);
	      var spliced = this.slice(0, index);
	      return reify(
	        this,
	        numArgs === 1 ?
	          spliced :
	          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
	      );
	    },
	
	
	    // ### More collection methods
	
	    findLastIndex: function(predicate, context) {
	      var key = this.toKeyedSeq().findLastKey(predicate, context);
	      return key === undefined ? -1 : key;
	    },
	
	    first: function() {
	      return this.get(0);
	    },
	
	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, false));
	    },
	
	    get: function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      return (index < 0 || (this.size === Infinity ||
	          (this.size !== undefined && index > this.size))) ?
	        notSetValue :
	        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
	    },
	
	    has: function(index) {
	      index = wrapIndex(this, index);
	      return index >= 0 && (this.size !== undefined ?
	        this.size === Infinity || index < this.size :
	        this.indexOf(index) !== -1
	      );
	    },
	
	    interpose: function(separator) {
	      return reify(this, interposeFactory(this, separator));
	    },
	
	    interleave: function(/*...iterables*/) {
	      var iterables = [this].concat(arrCopy(arguments));
	      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
	      var interleaved = zipped.flatten(true);
	      if (zipped.size) {
	        interleaved.size = zipped.size * iterables.length;
	      }
	      return reify(this, interleaved);
	    },
	
	    last: function() {
	      return this.get(-1);
	    },
	
	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, false));
	    },
	
	    zip: function(/*, ...iterables */) {
	      var iterables = [this].concat(arrCopy(arguments));
	      return reify(this, zipWithFactory(this, defaultZipper, iterables));
	    },
	
	    zipWith: function(zipper/*, ...iterables */) {
	      var iterables = arrCopy(arguments);
	      iterables[0] = this;
	      return reify(this, zipWithFactory(this, zipper, iterables));
	    }
	
	  });
	
	  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
	  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;
	
	
	
	  mixin(SetIterable, {
	
	    // ### ES6 Collection methods (ES6 Array and Map)
	
	    get: function(value, notSetValue) {
	      return this.has(value) ? value : notSetValue;
	    },
	
	    includes: function(value) {
	      return this.has(value);
	    },
	
	
	    // ### More sequential methods
	
	    keySeq: function() {
	      return this.valueSeq();
	    }
	
	  });
	
	  SetIterable.prototype.has = IterablePrototype.includes;
	
	
	  // Mixin subclasses
	
	  mixin(KeyedSeq, KeyedIterable.prototype);
	  mixin(IndexedSeq, IndexedIterable.prototype);
	  mixin(SetSeq, SetIterable.prototype);
	
	  mixin(KeyedCollection, KeyedIterable.prototype);
	  mixin(IndexedCollection, IndexedIterable.prototype);
	  mixin(SetCollection, SetIterable.prototype);
	
	
	  // #pragma Helper functions
	
	  function keyMapper(v, k) {
	    return k;
	  }
	
	  function entryMapper(v, k) {
	    return [k, v];
	  }
	
	  function not(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    }
	  }
	
	  function neg(predicate) {
	    return function() {
	      return -predicate.apply(this, arguments);
	    }
	  }
	
	  function quoteString(value) {
	    return typeof value === 'string' ? JSON.stringify(value) : value;
	  }
	
	  function defaultZipper() {
	    return arrCopy(arguments);
	  }
	
	  function defaultNegComparator(a, b) {
	    return a < b ? 1 : a > b ? -1 : 0;
	  }
	
	  function hashIterable(iterable) {
	    if (iterable.size === Infinity) {
	      return 0;
	    }
	    var ordered = isOrdered(iterable);
	    var keyed = isKeyed(iterable);
	    var h = ordered ? 1 : 0;
	    var size = iterable.__iterate(
	      keyed ?
	        ordered ?
	          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
	          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
	        ordered ?
	          function(v ) { h = 31 * h + hash(v) | 0; } :
	          function(v ) { h = h + hash(v) | 0; }
	    );
	    return murmurHashOfSize(size, h);
	  }
	
	  function murmurHashOfSize(size, h) {
	    h = src_Math__imul(h, 0xCC9E2D51);
	    h = src_Math__imul(h << 15 | h >>> -15, 0x1B873593);
	    h = src_Math__imul(h << 13 | h >>> -13, 5);
	    h = (h + 0xE6546B64 | 0) ^ size;
	    h = src_Math__imul(h ^ h >>> 16, 0x85EBCA6B);
	    h = src_Math__imul(h ^ h >>> 13, 0xC2B2AE35);
	    h = smi(h ^ h >>> 16);
	    return h;
	  }
	
	  function hashMerge(a, b) {
	    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
	  }
	
	  var Immutable = {
	
	    Iterable: Iterable,
	
	    Seq: Seq,
	    Collection: Collection,
	    Map: src_Map__Map,
	    OrderedMap: OrderedMap,
	    List: List,
	    Stack: Stack,
	    Set: src_Set__Set,
	    OrderedSet: OrderedSet,
	
	    Record: Record,
	    Range: Range,
	    Repeat: Repeat,
	
	    is: is,
	    fromJS: fromJS
	
	  };
	
	  return Immutable;
	
	}));

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * @providesModule ReactNavigatorBreadcrumbNavigationBar
	 */
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _ReactNavigatorBreadcrumbNavigationBarStyles = __webpack_require__(272);
	
	var _ReactNavigatorBreadcrumbNavigationBarStyles2 = _interopRequireDefault(_ReactNavigatorBreadcrumbNavigationBarStyles);
	
	var _ReactNavigatorNavigationBarStylesAndroid = __webpack_require__(277);
	
	var _ReactNavigatorNavigationBarStylesAndroid2 = _interopRequireDefault(_ReactNavigatorNavigationBarStylesAndroid);
	
	var _ReactNavigatorNavigationBarStylesIOS = __webpack_require__(273);
	
	var _ReactNavigatorNavigationBarStylesIOS2 = _interopRequireDefault(_ReactNavigatorNavigationBarStylesIOS);
	
	var _ReactPlatform = __webpack_require__(278);
	
	var _ReactPlatform2 = _interopRequireDefault(_ReactPlatform);
	
	var _ReactStyleSheet = __webpack_require__(154);
	
	var _ReactStyleSheet2 = _interopRequireDefault(_ReactStyleSheet);
	
	var _ReactView = __webpack_require__(164);
	
	var _ReactView2 = _interopRequireDefault(_ReactView);
	
	var _ReactSetNativeProps = __webpack_require__(279);
	
	var _ReactSetNativeProps2 = _interopRequireDefault(_ReactSetNativeProps);
	
	var _immutable = __webpack_require__(270);
	
	var _fbjsLibInvariant = __webpack_require__(231);
	
	var _fbjsLibInvariant2 = _interopRequireDefault(_fbjsLibInvariant);
	
	var Interpolators = _ReactNavigatorBreadcrumbNavigationBarStyles2['default'].Interpolators;
	var NavigatorNavigationBarStyles = _ReactPlatform2['default'].OS === 'android' ? _ReactNavigatorNavigationBarStylesAndroid2['default'] : _ReactNavigatorNavigationBarStylesIOS2['default'];
	
	/**
	 * Reusable props objects.
	 */
	var CRUMB_PROPS = Interpolators.map(function () {
	  return { style: {} };
	});
	var ICON_PROPS = Interpolators.map(function () {
	  return { style: {} };
	});
	var SEPARATOR_PROPS = Interpolators.map(function () {
	  return { style: {} };
	});
	var TITLE_PROPS = Interpolators.map(function () {
	  return { style: {} };
	});
	var RIGHT_BUTTON_PROPS = Interpolators.map(function () {
	  return { style: {} };
	});
	
	var navStatePresentedIndex = function navStatePresentedIndex(navState) {
	  if (navState.presentedIndex !== undefined) {
	    return navState.presentedIndex;
	  }
	  // TODO: rename `observedTopOfStack` to `presentedIndex` in `NavigatorIOS`
	  return navState.observedTopOfStack;
	};
	
	/**
	 * The first route is initially rendered using a different style than all
	 * future routes.
	 *
	 * @param {number} index Index of breadcrumb.
	 * @return {object} Style config for initial rendering of index.
	 */
	var initStyle = function initStyle(index, presentedIndex) {
	  return index === presentedIndex ? _ReactNavigatorBreadcrumbNavigationBarStyles2['default'].Center[index] : index < presentedIndex ? _ReactNavigatorBreadcrumbNavigationBarStyles2['default'].Left[index] : _ReactNavigatorBreadcrumbNavigationBarStyles2['default'].Right[index];
	};
	
	var NavigatorBreadcrumbNavigationBar = _react2['default'].createClass({
	  displayName: 'NavigatorBreadcrumbNavigationBar',
	
	  propTypes: {
	    navigator: _react.PropTypes.shape({
	      push: _react.PropTypes.func,
	      pop: _react.PropTypes.func,
	      replace: _react.PropTypes.func,
	      popToRoute: _react.PropTypes.func,
	      popToTop: _react.PropTypes.func
	    }),
	    routeMapper: _react.PropTypes.shape({
	      rightContentForRoute: _react.PropTypes.func,
	      titleContentForRoute: _react.PropTypes.func,
	      iconForRoute: _react.PropTypes.func
	    }),
	    navState: _react2['default'].PropTypes.shape({
	      routeStack: _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.object),
	      presentedIndex: _react2['default'].PropTypes.number
	    }),
	    style: _ReactView2['default'].propTypes.style
	  },
	
	  statics: {
	    Styles: _ReactNavigatorBreadcrumbNavigationBarStyles2['default']
	  },
	
	  _updateIndexProgress: function _updateIndexProgress(progress, index, fromIndex, toIndex) {
	    var amount = toIndex > fromIndex ? progress : 1 - progress;
	    var oldDistToCenter = index - fromIndex;
	    var newDistToCenter = index - toIndex;
	    var interpolate;
	    (0, _fbjsLibInvariant2['default'])(Interpolators[index], 'Cannot find breadcrumb interpolators for ' + index);
	    if (oldDistToCenter > 0 && newDistToCenter === 0 || newDistToCenter > 0 && oldDistToCenter === 0) {
	      interpolate = Interpolators[index].RightToCenter;
	    } else if (oldDistToCenter < 0 && newDistToCenter === 0 || newDistToCenter < 0 && oldDistToCenter === 0) {
	      interpolate = Interpolators[index].CenterToLeft;
	    } else if (oldDistToCenter === newDistToCenter) {
	      interpolate = Interpolators[index].RightToCenter;
	    } else {
	      interpolate = Interpolators[index].RightToLeft;
	    }
	
	    if (interpolate.Crumb(CRUMB_PROPS[index].style, amount)) {
	      this._setPropsIfExists('crumb_' + index, CRUMB_PROPS[index]);
	    }
	    if (interpolate.Icon(ICON_PROPS[index].style, amount)) {
	      this._setPropsIfExists('icon_' + index, ICON_PROPS[index]);
	    }
	    if (interpolate.Separator(SEPARATOR_PROPS[index].style, amount)) {
	      this._setPropsIfExists('separator_' + index, SEPARATOR_PROPS[index]);
	    }
	    if (interpolate.Title(TITLE_PROPS[index].style, amount)) {
	      this._setPropsIfExists('title_' + index, TITLE_PROPS[index]);
	    }
	    var right = this.refs['right_' + index];
	    if (right && interpolate.RightItem(RIGHT_BUTTON_PROPS[index].style, amount)) {
	      (0, _ReactSetNativeProps2['default'])(right, RIGHT_BUTTON_PROPS[index]);
	    }
	  },
	
	  updateProgress: function updateProgress(progress, fromIndex, toIndex) {
	    var max = Math.max(fromIndex, toIndex);
	    var min = Math.min(fromIndex, toIndex);
	    for (var index = min; index <= max; index++) {
	      this._updateIndexProgress(progress, index, fromIndex, toIndex);
	    }
	  },
	
	  onAnimationStart: function onAnimationStart(fromIndex, toIndex) {
	    var max = Math.max(fromIndex, toIndex);
	    var min = Math.min(fromIndex, toIndex);
	    for (var index = min; index <= max; index++) {
	      this._setRenderViewsToHardwareTextureAndroid(index, true);
	    }
	  },
	
	  onAnimationEnd: function onAnimationEnd() {
	    var max = this.props.navState.routeStack.length - 1;
	    for (var index = 0; index <= max; index++) {
	      this._setRenderViewsToHardwareTextureAndroid(index, false);
	    }
	  },
	
	  _setRenderViewsToHardwareTextureAndroid: function _setRenderViewsToHardwareTextureAndroid(index, renderToHardwareTexture) {
	    var props = {
	      renderToHardwareTextureAndroid: renderToHardwareTexture
	    };
	
	    this._setPropsIfExists('icon_' + index, props);
	    this._setPropsIfExists('separator_' + index, props);
	    this._setPropsIfExists('title_' + index, props);
	    this._setPropsIfExists('right_' + index, props);
	  },
	
	  componentWillMount: function componentWillMount() {
	    this._descriptors = {
	      crumb: new _immutable.Map(),
	      title: new _immutable.Map(),
	      right: new _immutable.Map()
	    };
	  },
	
	  render: function render() {
	    var navState = this.props.navState;
	    var icons = navState && navState.routeStack.map(this._getBreadcrumb);
	    var titles = navState.routeStack.map(this._getTitle);
	    var buttons = navState.routeStack.map(this._getRightButton);
	    return _react2['default'].createElement(
	      _ReactView2['default'],
	      { style: [styles.breadCrumbContainer, this.props.style] },
	      titles,
	      icons,
	      buttons
	    );
	  },
	
	  _getBreadcrumb: function _getBreadcrumb(route, index) {
	    if (this._descriptors.crumb.has(route)) {
	      return this._descriptors.crumb.get(route);
	    }
	
	    var navBarRouteMapper = this.props.routeMapper;
	    var firstStyles = initStyle(index, navStatePresentedIndex(this.props.navState));
	
	    var breadcrumbDescriptor = _react2['default'].createElement(
	      _ReactView2['default'],
	      { ref: 'crumb_' + index, style: firstStyles.Crumb },
	      _react2['default'].createElement(
	        _ReactView2['default'],
	        { ref: 'icon_' + index, style: firstStyles.Icon },
	        navBarRouteMapper.iconForRoute(route, this.props.navigator)
	      ),
	      _react2['default'].createElement(
	        _ReactView2['default'],
	        { ref: 'separator_' + index, style: firstStyles.Separator },
	        navBarRouteMapper.separatorForRoute(route, this.props.navigator)
	      )
	    );
	
	    this._descriptors.crumb = this._descriptors.crumb.set(route, breadcrumbDescriptor);
	    return breadcrumbDescriptor;
	  },
	
	  _getTitle: function _getTitle(route, index) {
	    if (this._descriptors.title.has(route)) {
	      return this._descriptors.title.get(route);
	    }
	
	    var titleContent = this.props.routeMapper.titleContentForRoute(this.props.navState.routeStack[index], this.props.navigator);
	    var firstStyles = initStyle(index, navStatePresentedIndex(this.props.navState));
	
	    var titleDescriptor = _react2['default'].createElement(
	      _ReactView2['default'],
	      { ref: 'title_' + index, style: firstStyles.Title },
	      titleContent
	    );
	    this._descriptors.title = this._descriptors.title.set(route, titleDescriptor);
	    return titleDescriptor;
	  },
	
	  _getRightButton: function _getRightButton(route, index) {
	    if (this._descriptors.right.has(route)) {
	      return this._descriptors.right.get(route);
	    }
	    var rightContent = this.props.routeMapper.rightContentForRoute(this.props.navState.routeStack[index], this.props.navigator);
	    if (!rightContent) {
	      this._descriptors.right = this._descriptors.right.set(route, null);
	      return null;
	    }
	    var firstStyles = initStyle(index, navStatePresentedIndex(this.props.navState));
	    var rightButtonDescriptor = _react2['default'].createElement(
	      _ReactView2['default'],
	      { ref: 'right_' + index, style: firstStyles.RightItem },
	      rightContent
	    );
	    this._descriptors.right = this._descriptors.right.set(route, rightButtonDescriptor);
	    return rightButtonDescriptor;
	  },
	
	  _setPropsIfExists: function _setPropsIfExists(ref, props) {
	    var ref = this.refs[ref];
	    // ref && ref.setNativeProps(props);
	    ref && (0, _ReactSetNativeProps2['default'])(ref, props);
	  }
	});
	
	var styles = _ReactStyleSheet2['default'].create({
	  breadCrumbContainer: {
	    overflow: 'hidden',
	    position: 'absolute',
	    height: NavigatorNavigationBarStyles.General.TotalNavHeight,
	    top: 0,
	    left: 0,
	    right: 0
	  }
	});
	
	module.exports = NavigatorBreadcrumbNavigationBar;

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * @providesModule ReactNavigatorBreadcrumbNavigationBarStyles
	 */
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _ReactDimensions = __webpack_require__(247);
	
	var _ReactDimensions2 = _interopRequireDefault(_ReactDimensions);
	
	var _ReactNavigatorNavigationBarStylesIOS = __webpack_require__(273);
	
	var _ReactNavigatorNavigationBarStylesIOS2 = _interopRequireDefault(_ReactNavigatorNavigationBarStylesIOS);
	
	var _polyfillsBuildStyleInterpolator = __webpack_require__(274);
	
	var _polyfillsBuildStyleInterpolator2 = _interopRequireDefault(_polyfillsBuildStyleInterpolator);
	
	var _polyfillsMerge = __webpack_require__(276);
	
	var _polyfillsMerge2 = _interopRequireDefault(_polyfillsMerge);
	
	var SCREEN_WIDTH = _ReactDimensions2['default'].get('window').width;
	var STATUS_BAR_HEIGHT = _ReactNavigatorNavigationBarStylesIOS2['default'].General.StatusBarHeight;
	var NAV_BAR_HEIGHT = _ReactNavigatorNavigationBarStylesIOS2['default'].General.NavBarHeight;
	
	var SPACING = 4;
	var ICON_WIDTH = 40;
	var SEPARATOR_WIDTH = 9;
	var CRUMB_WIDTH = ICON_WIDTH + SEPARATOR_WIDTH;
	
	var OPACITY_RATIO = 100;
	var ICON_INACTIVE_OPACITY = 0.6;
	var MAX_BREADCRUMBS = 10;
	
	var CRUMB_BASE = {
	  position: 'absolute',
	  flexDirection: 'row',
	  top: STATUS_BAR_HEIGHT,
	  width: CRUMB_WIDTH,
	  height: NAV_BAR_HEIGHT,
	  backgroundColor: 'transparent'
	};
	
	var ICON_BASE = {
	  width: ICON_WIDTH,
	  height: NAV_BAR_HEIGHT
	};
	
	var SEPARATOR_BASE = {
	  width: SEPARATOR_WIDTH,
	  height: NAV_BAR_HEIGHT
	};
	
	var TITLE_BASE = {
	  position: 'absolute',
	  top: STATUS_BAR_HEIGHT,
	  height: NAV_BAR_HEIGHT,
	  backgroundColor: 'transparent'
	};
	
	// For first title styles, make sure first title is centered
	var FIRST_TITLE_BASE = (0, _polyfillsMerge2['default'])(TITLE_BASE, {
	  left: 0,
	  right: 0,
	  alignItems: 'center',
	  height: NAV_BAR_HEIGHT
	});
	
	var RIGHT_BUTTON_BASE = {
	  position: 'absolute',
	  top: STATUS_BAR_HEIGHT,
	  right: SPACING,
	  overflow: 'hidden',
	  opacity: 1,
	  height: NAV_BAR_HEIGHT,
	  backgroundColor: 'transparent'
	};
	
	/**
	 * Precompute crumb styles so that they don't need to be recomputed on every
	 * interaction.
	 */
	var LEFT = [];
	var CENTER = [];
	var RIGHT = [];
	for (var i = 0; i < MAX_BREADCRUMBS; i++) {
	  var crumbLeft = CRUMB_WIDTH * i + SPACING;
	  LEFT[i] = {
	    Crumb: (0, _polyfillsMerge2['default'])(CRUMB_BASE, { left: crumbLeft }),
	    Icon: (0, _polyfillsMerge2['default'])(ICON_BASE, { opacity: ICON_INACTIVE_OPACITY }),
	    Separator: (0, _polyfillsMerge2['default'])(SEPARATOR_BASE, { opacity: 1 }),
	    Title: (0, _polyfillsMerge2['default'])(TITLE_BASE, { left: crumbLeft, opacity: 0 }),
	    RightItem: (0, _polyfillsMerge2['default'])(RIGHT_BUTTON_BASE, { opacity: 0 })
	  };
	  CENTER[i] = {
	    Crumb: (0, _polyfillsMerge2['default'])(CRUMB_BASE, { left: crumbLeft }),
	    Icon: (0, _polyfillsMerge2['default'])(ICON_BASE, { opacity: 1 }),
	    Separator: (0, _polyfillsMerge2['default'])(SEPARATOR_BASE, { opacity: 0 }),
	    Title: (0, _polyfillsMerge2['default'])(TITLE_BASE, {
	      left: crumbLeft + ICON_WIDTH,
	      opacity: 1
	    }),
	    RightItem: (0, _polyfillsMerge2['default'])(RIGHT_BUTTON_BASE, { opacity: 1 })
	  };
	  var crumbRight = SCREEN_WIDTH - 100;
	  RIGHT[i] = {
	    Crumb: (0, _polyfillsMerge2['default'])(CRUMB_BASE, { left: crumbRight }),
	    Icon: (0, _polyfillsMerge2['default'])(ICON_BASE, { opacity: 0 }),
	    Separator: (0, _polyfillsMerge2['default'])(SEPARATOR_BASE, { opacity: 0 }),
	    Title: (0, _polyfillsMerge2['default'])(TITLE_BASE, {
	      left: crumbRight + ICON_WIDTH,
	      opacity: 0
	    }),
	    RightItem: (0, _polyfillsMerge2['default'])(RIGHT_BUTTON_BASE, { opacity: 0 })
	  };
	}
	
	// Special case the CENTER state of the first scene.
	CENTER[0] = {
	  Crumb: (0, _polyfillsMerge2['default'])(CRUMB_BASE, { left: SCREEN_WIDTH / 4 }),
	  Icon: (0, _polyfillsMerge2['default'])(ICON_BASE, { opacity: 0 }),
	  Separator: (0, _polyfillsMerge2['default'])(SEPARATOR_BASE, { opacity: 0 }),
	  Title: (0, _polyfillsMerge2['default'])(FIRST_TITLE_BASE, { opacity: 1 }),
	  RightItem: CENTER[0].RightItem
	};
	LEFT[0].Title = (0, _polyfillsMerge2['default'])(FIRST_TITLE_BASE, { left: -SCREEN_WIDTH / 4, opacity: 0 });
	RIGHT[0].Title = (0, _polyfillsMerge2['default'])(FIRST_TITLE_BASE, { opacity: 0 });
	
	var buildIndexSceneInterpolator = function buildIndexSceneInterpolator(startStyles, endStyles) {
	  return {
	    Crumb: (0, _polyfillsBuildStyleInterpolator2['default'])({
	      left: {
	        type: 'linear',
	        from: startStyles.Crumb.left,
	        to: endStyles.Crumb.left,
	        min: 0,
	        max: 1,
	        extrapolate: true
	      }
	    }),
	    Icon: (0, _polyfillsBuildStyleInterpolator2['default'])({
	      opacity: {
	        type: 'linear',
	        from: startStyles.Icon.opacity,
	        to: endStyles.Icon.opacity,
	        min: 0,
	        max: 1
	      }
	    }),
	    Separator: (0, _polyfillsBuildStyleInterpolator2['default'])({
	      opacity: {
	        type: 'linear',
	        from: startStyles.Separator.opacity,
	        to: endStyles.Separator.opacity,
	        min: 0,
	        max: 1
	      }
	    }),
	    Title: (0, _polyfillsBuildStyleInterpolator2['default'])({
	      opacity: {
	        type: 'linear',
	        from: startStyles.Title.opacity,
	        to: endStyles.Title.opacity,
	        min: 0,
	        max: 1
	      },
	      left: {
	        type: 'linear',
	        from: startStyles.Title.left,
	        to: endStyles.Title.left,
	        min: 0,
	        max: 1,
	        extrapolate: true
	      }
	    }),
	    RightItem: (0, _polyfillsBuildStyleInterpolator2['default'])({
	      opacity: {
	        type: 'linear',
	        from: startStyles.RightItem.opacity,
	        to: endStyles.RightItem.opacity,
	        min: 0,
	        max: 1,
	        round: OPACITY_RATIO
	      }
	    })
	  };
	};
	
	var Interpolators = CENTER.map(function (_, ii) {
	  return {
	    // Animating *into* the center stage from the right
	    RightToCenter: buildIndexSceneInterpolator(RIGHT[ii], CENTER[ii]),
	    // Animating out of the center stage, to the left
	    CenterToLeft: buildIndexSceneInterpolator(CENTER[ii], LEFT[ii]),
	    // Both stages (animating *past* the center stage)
	    RightToLeft: buildIndexSceneInterpolator(RIGHT[ii], LEFT[ii])
	  };
	});
	
	/**
	 * Contains constants that are used in constructing both `StyleSheet`s and
	 * inline styles during transitions.
	 */
	module.exports = {
	  Interpolators: Interpolators,
	  Left: LEFT,
	  Center: CENTER,
	  Right: RIGHT,
	  IconWidth: ICON_WIDTH,
	  IconHeight: NAV_BAR_HEIGHT,
	  SeparatorWidth: SEPARATOR_WIDTH,
	  SeparatorHeight: NAV_BAR_HEIGHT
	};

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * @providesModule ReactNavigatorNavigationBarStylesIOS
	 */
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _ReactDimensions = __webpack_require__(247);
	
	var _ReactDimensions2 = _interopRequireDefault(_ReactDimensions);
	
	var _polyfillsBuildStyleInterpolator = __webpack_require__(274);
	
	var _polyfillsBuildStyleInterpolator2 = _interopRequireDefault(_polyfillsBuildStyleInterpolator);
	
	var _polyfillsMerge = __webpack_require__(276);
	
	var _polyfillsMerge2 = _interopRequireDefault(_polyfillsMerge);
	
	var SCREEN_WIDTH = _ReactDimensions2['default'].get('window').width;
	var NAV_BAR_HEIGHT = 44;
	var STATUS_BAR_HEIGHT = 20;
	var NAV_HEIGHT = NAV_BAR_HEIGHT + STATUS_BAR_HEIGHT;
	
	var BASE_STYLES = {
	  Title: {
	    position: 'absolute',
	    top: STATUS_BAR_HEIGHT,
	    left: 0,
	    right: 0,
	    alignItems: 'center',
	    height: NAV_BAR_HEIGHT,
	    backgroundColor: 'transparent'
	  },
	  LeftButton: {
	    position: 'absolute',
	    top: STATUS_BAR_HEIGHT,
	    left: 0,
	    overflow: 'hidden',
	    opacity: 1,
	    height: NAV_BAR_HEIGHT,
	    backgroundColor: 'transparent'
	  },
	  RightButton: {
	    position: 'absolute',
	    top: STATUS_BAR_HEIGHT,
	    right: 0,
	    overflow: 'hidden',
	    opacity: 1,
	    alignItems: 'flex-end',
	    height: NAV_BAR_HEIGHT,
	    backgroundColor: 'transparent'
	  }
	};
	
	// There are 3 stages: left, center, right. All previous navigation
	// items are in the left stage. The current navigation item is in the
	// center stage. All upcoming navigation items are in the right stage.
	// Another way to think of the stages is in terms of transitions. When
	// we move forward in the navigation stack, we perform a
	// right-to-center transition on the new navigation item and a
	// center-to-left transition on the current navigation item.
	var Stages = {
	  Left: {
	    Title: (0, _polyfillsMerge2['default'])(BASE_STYLES.Title, { left: -SCREEN_WIDTH / 2, opacity: 0 }),
	    LeftButton: (0, _polyfillsMerge2['default'])(BASE_STYLES.LeftButton, { left: -SCREEN_WIDTH / 3, opacity: 1 }),
	    RightButton: (0, _polyfillsMerge2['default'])(BASE_STYLES.RightButton, { left: SCREEN_WIDTH / 3, opacity: 0 })
	  },
	  Center: {
	    Title: (0, _polyfillsMerge2['default'])(BASE_STYLES.Title, { left: 0, opacity: 1 }),
	    LeftButton: (0, _polyfillsMerge2['default'])(BASE_STYLES.LeftButton, { left: 0, opacity: 1 }),
	    RightButton: (0, _polyfillsMerge2['default'])(BASE_STYLES.RightButton, { left: 2 * SCREEN_WIDTH / 3 - 0, opacity: 1 })
	  },
	  Right: {
	    Title: (0, _polyfillsMerge2['default'])(BASE_STYLES.Title, { left: SCREEN_WIDTH / 2, opacity: 0 }),
	    LeftButton: (0, _polyfillsMerge2['default'])(BASE_STYLES.LeftButton, { left: 0, opacity: 0 }),
	    RightButton: (0, _polyfillsMerge2['default'])(BASE_STYLES.RightButton, { left: SCREEN_WIDTH, opacity: 0 })
	  }
	};
	
	var opacityRatio = 100;
	
	function buildSceneInterpolators(startStyles, endStyles) {
	  return {
	    Title: (0, _polyfillsBuildStyleInterpolator2['default'])({
	      opacity: {
	        type: 'linear',
	        from: startStyles.Title.opacity,
	        to: endStyles.Title.opacity,
	        min: 0,
	        max: 1
	      },
	      left: {
	        type: 'linear',
	        from: startStyles.Title.left,
	        to: endStyles.Title.left,
	        min: 0,
	        max: 1,
	        extrapolate: true
	      }
	    }),
	    LeftButton: (0, _polyfillsBuildStyleInterpolator2['default'])({
	      opacity: {
	        type: 'linear',
	        from: startStyles.LeftButton.opacity,
	        to: endStyles.LeftButton.opacity,
	        min: 0,
	        max: 1,
	        round: opacityRatio
	      },
	      left: {
	        type: 'linear',
	        from: startStyles.LeftButton.left,
	        to: endStyles.LeftButton.left,
	        min: 0,
	        max: 1
	      }
	    }),
	    RightButton: (0, _polyfillsBuildStyleInterpolator2['default'])({
	      opacity: {
	        type: 'linear',
	        from: startStyles.RightButton.opacity,
	        to: endStyles.RightButton.opacity,
	        min: 0,
	        max: 1,
	        round: opacityRatio
	      },
	      left: {
	        type: 'linear',
	        from: startStyles.RightButton.left,
	        to: endStyles.RightButton.left,
	        min: 0,
	        max: 1,
	        extrapolate: true
	      }
	    })
	  };
	}
	
	var Interpolators = {
	  // Animating *into* the center stage from the right
	  RightToCenter: buildSceneInterpolators(Stages.Right, Stages.Center),
	  // Animating out of the center stage, to the left
	  CenterToLeft: buildSceneInterpolators(Stages.Center, Stages.Left),
	  // Both stages (animating *past* the center stage)
	  RightToLeft: buildSceneInterpolators(Stages.Right, Stages.Left)
	};
	
	module.exports = {
	  General: {
	    NavBarHeight: NAV_BAR_HEIGHT,
	    StatusBarHeight: STATUS_BAR_HEIGHT,
	    TotalNavHeight: NAV_HEIGHT
	  },
	  Interpolators: Interpolators,
	  Stages: Stages
	};

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * @providesModule ReactBuildStyleInterpolator
	 */
	
	/**
	 * Cannot "use strict" because we must use eval in this file.
	 */
	/* eslint-disable global-strict */
	
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _fbjsLibKeyOf = __webpack_require__(275);
	
	var _fbjsLibKeyOf2 = _interopRequireDefault(_fbjsLibKeyOf);
	
	var X_DIM = (0, _fbjsLibKeyOf2['default'])({ x: null });
	var Y_DIM = (0, _fbjsLibKeyOf2['default'])({ y: null });
	var Z_DIM = (0, _fbjsLibKeyOf2['default'])({ z: null });
	var W_DIM = (0, _fbjsLibKeyOf2['default'])({ w: null });
	
	var TRANSFORM_ROTATE_NAME = (0, _fbjsLibKeyOf2['default'])({ transformRotateRadians: null });
	
	var ShouldAllocateReusableOperationVars = {
	  transformRotateRadians: true,
	  transformScale: true,
	  transformTranslate: true
	};
	
	var InitialOperationField = {
	  transformRotateRadians: [0, 0, 0, 1],
	  transformTranslate: [0, 0, 0],
	  transformScale: [1, 1, 1]
	};
	
	/**
	 * Creates a highly specialized animation function that may be evaluated every
	 * frame. For example:
	 *
	 *    var ToTheLeft = {
	 *      opacity: {
	 *        from: 1,
	 *        to: 0.7,
	 *        min: 0,
	 *        max: 1,
	 *        type: 'linear',
	 *        extrapolate: false,
	 *        round: 100,
	 *      },
	 *      left: {
	 *        from: 0,
	 *        to: -SCREEN_WIDTH * 0.3,
	 *        min: 0,
	 *        max: 1,
	 *        type: 'linear',
	 *        extrapolate: true,
	 *        round: PixelRatio.get(),
	 *      },
	 *    };
	 *
	 *    var toTheLeft = buildStyleInterpolator(ToTheLeft);
	 *
	 *  Would returns a specialized function of the form:
	 *
	 *    function(result, value) {
	 *      var didChange = false;
	 *      var nextScalarVal;
	 *      var ratio;
	 *      ratio = (value - 0) / 1;
	 *      ratio = ratio > 1 ? 1 : (ratio < 0 ? 0 : ratio);
	 *      nextScalarVal = Math.round(100 * (1 * (1 - ratio) + 0.7 * ratio)) / 100;
	 *      if (!didChange) {
	 *        var prevVal = result.opacity;
	 *        result.opacity = nextScalarVal;
	 *        didChange = didChange  || (nextScalarVal !== prevVal);
	 *      } else {
	 *        result.opacity = nextScalarVal;
	 *      }
	 *      ratio = (value - 0) / 1;
	 *      nextScalarVal = Math.round(2 * (0 * (1 - ratio) + -30 * ratio)) / 2;
	 *      if (!didChange) {
	 *        var prevVal = result.left;
	 *        result.left = nextScalarVal;
	 *        didChange = didChange  || (nextScalarVal !== prevVal);
	 *      } else {
	 *        result.left = nextScalarVal;
	 *      }
	 *      return didChange;
	 *    }
	 */
	
	var ARGUMENT_NAMES_RE = /([^\s,]+)/g;
	/**
	 * This is obviously a huge hack. Proper tooling would allow actual inlining.
	 * This only works in a few limited cases (where there is no function return
	 * value, and the function operates mutatively on parameters).
	 *
	 * Example:
	 *
	 *
	 *   var inlineMe(a, b) {
	 *      a = b + b;
	 *  };
	 *
	 *  inline(inlineMe, ['hi', 'bye']);  // "hi = bye + bye;"
	 *
	 * @param {function} func Any simple function whos arguments can be replaced via a regex.
	 * @param {array<string>} replaceWithArgs Corresponding names of variables
	 * within an environment, to replace `func` args with.
	 * @return {string} Resulting function body string.
	 */
	var inline = function inline(func, replaceWithArgs) {
	  var fnStr = func.toString();
	  var parameterNames = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES_RE) || [];
	  var replaceRegexStr = parameterNames.map(function (paramName) {
	    return '\\b' + paramName + '\\b';
	  }).join('|');
	  var replaceRegex = new RegExp(replaceRegexStr, 'g');
	  var fnBody = fnStr.substring(fnStr.indexOf('{') + 1, fnStr.lastIndexOf('}'));
	  var newFnBody = fnBody.replace(replaceRegex, function (parameterName) {
	    var indexInParameterNames = parameterNames.indexOf(parameterName);
	    var replacementName = replaceWithArgs[indexInParameterNames];
	    return replacementName;
	  });
	  return newFnBody.split('\n');
	};
	
	/**
	 * Simply a convenient way to inline functions using the function's toString
	 * method.
	 */
	var MatrixOps = {
	  unroll: function unroll(matVar, m0, m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11, m12, m13, m14, m15) {
	    m0 = matVar[0];
	    m1 = matVar[1];
	    m2 = matVar[2];
	    m3 = matVar[3];
	    m4 = matVar[4];
	    m5 = matVar[5];
	    m6 = matVar[6];
	    m7 = matVar[7];
	    m8 = matVar[8];
	    m9 = matVar[9];
	    m10 = matVar[10];
	    m11 = matVar[11];
	    m12 = matVar[12];
	    m13 = matVar[13];
	    m14 = matVar[14];
	    m15 = matVar[15];
	  },
	
	  matrixDiffers: function matrixDiffers(retVar, matVar, m0, m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11, m12, m13, m14, m15) {
	    retVar = retVar || m0 !== matVar[0] || m1 !== matVar[1] || m2 !== matVar[2] || m3 !== matVar[3] || m4 !== matVar[4] || m5 !== matVar[5] || m6 !== matVar[6] || m7 !== matVar[7] || m8 !== matVar[8] || m9 !== matVar[9] || m10 !== matVar[10] || m11 !== matVar[11] || m12 !== matVar[12] || m13 !== matVar[13] || m14 !== matVar[14] || m15 !== matVar[15];
	  },
	
	  transformScale: function transformScale(matVar, opVar) {
	    // Scaling matVar by opVar
	    var x = opVar[0];
	    var y = opVar[1];
	    var z = opVar[2];
	    matVar[0] = matVar[0] * x;
	    matVar[1] = matVar[1] * x;
	    matVar[2] = matVar[2] * x;
	    matVar[3] = matVar[3] * x;
	    matVar[4] = matVar[4] * y;
	    matVar[5] = matVar[5] * y;
	    matVar[6] = matVar[6] * y;
	    matVar[7] = matVar[7] * y;
	    matVar[8] = matVar[8] * z;
	    matVar[9] = matVar[9] * z;
	    matVar[10] = matVar[10] * z;
	    matVar[11] = matVar[11] * z;
	    matVar[12] = matVar[12];
	    matVar[13] = matVar[13];
	    matVar[14] = matVar[14];
	    matVar[15] = matVar[15];
	  },
	
	  /**
	   * All of these matrix transforms are not general purpose utilities, and are
	   * only suitable for being inlined for the use of building up interpolators.
	   */
	  transformTranslate: function transformTranslate(matVar, opVar) {
	    // Translating matVar by opVar
	    var x = opVar[0];
	    var y = opVar[1];
	    var z = opVar[2];
	    matVar[12] = matVar[0] * x + matVar[4] * y + matVar[8] * z + matVar[12];
	    matVar[13] = matVar[1] * x + matVar[5] * y + matVar[9] * z + matVar[13];
	    matVar[14] = matVar[2] * x + matVar[6] * y + matVar[10] * z + matVar[14];
	    matVar[15] = matVar[3] * x + matVar[7] * y + matVar[11] * z + matVar[15];
	  },
	
	  /**
	   * @param {array} matVar Both the input, and the output matrix.
	   * @param {quaternion specification} q Four element array describing rotation.
	   */
	  transformRotateRadians: function transformRotateRadians(matVar, q) {
	    // Rotating matVar by q
	    var xQuat = q[0],
	        yQuat = q[1],
	        zQuat = q[2],
	        wQuat = q[3];
	    var x2Quat = xQuat + xQuat;
	    var y2Quat = yQuat + yQuat;
	    var z2Quat = zQuat + zQuat;
	    var xxQuat = xQuat * x2Quat;
	    var xyQuat = xQuat * y2Quat;
	    var xzQuat = xQuat * z2Quat;
	    var yyQuat = yQuat * y2Quat;
	    var yzQuat = yQuat * z2Quat;
	    var zzQuat = zQuat * z2Quat;
	    var wxQuat = wQuat * x2Quat;
	    var wyQuat = wQuat * y2Quat;
	    var wzQuat = wQuat * z2Quat;
	    // Step 1: Inlines the construction of a quaternion matrix (`quatMat`)
	    var quatMat0 = 1 - (yyQuat + zzQuat);
	    var quatMat1 = xyQuat + wzQuat;
	    var quatMat2 = xzQuat - wyQuat;
	    var quatMat4 = xyQuat - wzQuat;
	    var quatMat5 = 1 - (xxQuat + zzQuat);
	    var quatMat6 = yzQuat + wxQuat;
	    var quatMat8 = xzQuat + wyQuat;
	    var quatMat9 = yzQuat - wxQuat;
	    var quatMat10 = 1 - (xxQuat + yyQuat);
	    // quatMat3/7/11/12/13/14 = 0, quatMat15 = 1
	
	    // Step 2: Inlines multiplication, takes advantage of constant quatMat cells
	    var a00 = matVar[0];
	    var a01 = matVar[1];
	    var a02 = matVar[2];
	    var a03 = matVar[3];
	    var a10 = matVar[4];
	    var a11 = matVar[5];
	    var a12 = matVar[6];
	    var a13 = matVar[7];
	    var a20 = matVar[8];
	    var a21 = matVar[9];
	    var a22 = matVar[10];
	    var a23 = matVar[11];
	
	    var b0 = quatMat0,
	        b1 = quatMat1,
	        b2 = quatMat2;
	    matVar[0] = b0 * a00 + b1 * a10 + b2 * a20;
	    matVar[1] = b0 * a01 + b1 * a11 + b2 * a21;
	    matVar[2] = b0 * a02 + b1 * a12 + b2 * a22;
	    matVar[3] = b0 * a03 + b1 * a13 + b2 * a23;
	    b0 = quatMat4;b1 = quatMat5;b2 = quatMat6;
	    matVar[4] = b0 * a00 + b1 * a10 + b2 * a20;
	    matVar[5] = b0 * a01 + b1 * a11 + b2 * a21;
	    matVar[6] = b0 * a02 + b1 * a12 + b2 * a22;
	    matVar[7] = b0 * a03 + b1 * a13 + b2 * a23;
	    b0 = quatMat8;b1 = quatMat9;b2 = quatMat10;
	    matVar[8] = b0 * a00 + b1 * a10 + b2 * a20;
	    matVar[9] = b0 * a01 + b1 * a11 + b2 * a21;
	    matVar[10] = b0 * a02 + b1 * a12 + b2 * a22;
	    matVar[11] = b0 * a03 + b1 * a13 + b2 * a23;
	  }
	};
	
	// Optimized version of general operation applications that can be used when
	// the target matrix is known to be the identity matrix.
	var MatrixOpsInitial = {
	  transformScale: function transformScale(matVar, opVar) {
	    // Scaling matVar known to be identity by opVar
	    matVar[0] = opVar[0];
	    matVar[1] = 0;
	    matVar[2] = 0;
	    matVar[3] = 0;
	    matVar[4] = 0;
	    matVar[5] = opVar[1];
	    matVar[6] = 0;
	    matVar[7] = 0;
	    matVar[8] = 0;
	    matVar[9] = 0;
	    matVar[10] = opVar[2];
	    matVar[11] = 0;
	    matVar[12] = 0;
	    matVar[13] = 0;
	    matVar[14] = 0;
	    matVar[15] = 1;
	  },
	
	  transformTranslate: function transformTranslate(matVar, opVar) {
	    // Translating matVar known to be identity by opVar';
	    matVar[0] = 1;
	    matVar[1] = 0;
	    matVar[2] = 0;
	    matVar[3] = 0;
	    matVar[4] = 0;
	    matVar[5] = 1;
	    matVar[6] = 0;
	    matVar[7] = 0;
	    matVar[8] = 0;
	    matVar[9] = 0;
	    matVar[10] = 1;
	    matVar[11] = 0;
	    matVar[12] = opVar[0];
	    matVar[13] = opVar[1];
	    matVar[14] = opVar[2];
	    matVar[15] = 1;
	  },
	
	  /**
	   * @param {array} matVar Both the input, and the output matrix - assumed to be
	   * identity.
	   * @param {quaternion specification} q Four element array describing rotation.
	   */
	  transformRotateRadians: function transformRotateRadians(matVar, q) {
	
	    // Rotating matVar which is known to be identity by q
	    var xQuat = q[0],
	        yQuat = q[1],
	        zQuat = q[2],
	        wQuat = q[3];
	    var x2Quat = xQuat + xQuat;
	    var y2Quat = yQuat + yQuat;
	    var z2Quat = zQuat + zQuat;
	    var xxQuat = xQuat * x2Quat;
	    var xyQuat = xQuat * y2Quat;
	    var xzQuat = xQuat * z2Quat;
	    var yyQuat = yQuat * y2Quat;
	    var yzQuat = yQuat * z2Quat;
	    var zzQuat = zQuat * z2Quat;
	    var wxQuat = wQuat * x2Quat;
	    var wyQuat = wQuat * y2Quat;
	    var wzQuat = wQuat * z2Quat;
	    // Step 1: Inlines the construction of a quaternion matrix (`quatMat`)
	    var quatMat0 = 1 - (yyQuat + zzQuat);
	    var quatMat1 = xyQuat + wzQuat;
	    var quatMat2 = xzQuat - wyQuat;
	    var quatMat4 = xyQuat - wzQuat;
	    var quatMat5 = 1 - (xxQuat + zzQuat);
	    var quatMat6 = yzQuat + wxQuat;
	    var quatMat8 = xzQuat + wyQuat;
	    var quatMat9 = yzQuat - wxQuat;
	    var quatMat10 = 1 - (xxQuat + yyQuat);
	    // quatMat3/7/11/12/13/14 = 0, quatMat15 = 1
	
	    // Step 2: Inlines the multiplication with identity matrix.
	    var b0 = quatMat0,
	        b1 = quatMat1,
	        b2 = quatMat2;
	    matVar[0] = b0;
	    matVar[1] = b1;
	    matVar[2] = b2;
	    matVar[3] = 0;
	    b0 = quatMat4;b1 = quatMat5;b2 = quatMat6;
	    matVar[4] = b0;
	    matVar[5] = b1;
	    matVar[6] = b2;
	    matVar[7] = 0;
	    b0 = quatMat8;b1 = quatMat9;b2 = quatMat10;
	    matVar[8] = b0;
	    matVar[9] = b1;
	    matVar[10] = b2;
	    matVar[11] = 0;
	    matVar[12] = 0;
	    matVar[13] = 0;
	    matVar[14] = 0;
	    matVar[15] = 1;
	  }
	};
	
	var setNextValAndDetectChange = function setNextValAndDetectChange(name, tmpVarName) {
	  return '  if (!didChange) {\n' + '    var prevVal = result.' + name + ';\n' + '    result.' + name + ' = ' + tmpVarName + ';\n' + '    didChange = didChange  || (' + tmpVarName + ' !== prevVal);\n' + '  } else {\n' + '    result.' + name + ' = ' + tmpVarName + ';\n' + '  }\n';
	};
	
	var computeNextValLinear = function computeNextValLinear(anim, from, to, tmpVarName) {
	  var hasRoundRatio = ('round' in anim);
	  var roundRatio = anim.round;
	  var fn = '  ratio = (value - ' + anim.min + ') / ' + (anim.max - anim.min) + ';\n';
	  if (!anim.extrapolate) {
	    fn += '  ratio = ratio > 1 ? 1 : (ratio < 0 ? 0 : ratio);\n';
	  }
	
	  var roundOpen = hasRoundRatio ? 'Math.round(' + roundRatio + ' * ' : '';
	  var roundClose = hasRoundRatio ? ') / ' + roundRatio : '';
	  fn += '  ' + tmpVarName + ' = ' + roundOpen + '(' + from + ' * (1 - ratio) + ' + to + ' * ratio)' + roundClose + ';\n';
	  return fn;
	};
	
	var computeNextValLinearScalar = function computeNextValLinearScalar(anim) {
	  return computeNextValLinear(anim, anim.from, anim.to, 'nextScalarVal');
	};
	
	var computeNextValConstant = function computeNextValConstant(anim) {
	  var constantExpression = JSON.stringify(anim.value);
	  return '  nextScalarVal = ' + constantExpression + ';\n';
	};
	
	var computeNextValStep = function computeNextValStep(anim) {
	  return '  nextScalarVal = value >= ' + (anim.threshold + ' ? ' + anim.to + ' : ' + anim.from) + ';\n';
	};
	
	var computeNextValIdentity = function computeNextValIdentity(anim) {
	  return '  nextScalarVal = value;\n';
	};
	
	var operationVar = function operationVar(name) {
	  return name + 'ReuseOp';
	};
	
	var createReusableOperationVars = function createReusableOperationVars(anims) {
	  var ret = '';
	  for (var name in anims) {
	    if (ShouldAllocateReusableOperationVars[name]) {
	      ret += 'var ' + operationVar(name) + ' = [];\n';
	    }
	  }
	  return ret;
	};
	
	var newlines = function newlines(statements) {
	  return '\n' + statements.join('\n') + '\n';
	};
	
	/**
	 * @param {Animation} anim Configuration entry.
	 * @param {key} dimension Key to examine in `from`/`to`.
	 * @param {number} index Field in operationVar to set.
	 * @return {string} Code that sets the operation variable's field.
	 */
	var computeNextMatrixOperationField = function computeNextMatrixOperationField(anim, name, dimension, index) {
	  var fieldAccess = operationVar(name) + '[' + index + ']';
	  if (anim.from[dimension] !== undefined && anim.to[dimension] !== undefined) {
	    return '  ' + anim.from[dimension] !== anim.to[dimension] ? computeNextValLinear(anim, anim.from[dimension], anim.to[dimension], fieldAccess) : fieldAccess + ' = ' + anim.from[dimension] + ';';
	  } else {
	    return '  ' + fieldAccess + ' = ' + InitialOperationField[name][index] + ';';
	  }
	};
	
	var unrolledVars = [];
	for (var varIndex = 0; varIndex < 16; varIndex++) {
	  unrolledVars.push('m' + varIndex);
	}
	var setNextMatrixAndDetectChange = function setNextMatrixAndDetectChange(orderedMatrixOperations) {
	  var fn = ['  var transformMatrix = result.transformMatrix !== undefined ? ' + 'result.transformMatrix : (result.transformMatrix = []);'];
	  fn.push.apply(fn, inline(MatrixOps.unroll, ['transformMatrix'].concat(unrolledVars)));
	  for (var i = 0; i < orderedMatrixOperations.length; i++) {
	    var opName = orderedMatrixOperations[i];
	    if (i === 0) {
	      fn.push.apply(fn, inline(MatrixOpsInitial[opName], ['transformMatrix', operationVar(opName)]));
	    } else {
	      fn.push.apply(fn, inline(MatrixOps[opName], ['transformMatrix', operationVar(opName)]));
	    }
	  }
	  fn.push.apply(fn, inline(MatrixOps.matrixDiffers, ['didChange', 'transformMatrix'].concat(unrolledVars)));
	  return fn;
	};
	
	var InterpolateMatrix = {
	  transformTranslate: true,
	  transformRotateRadians: true,
	  transformScale: true
	};
	
	var createFunctionString = function createFunctionString(anims) {
	  // We must track the order they appear in so transforms are applied in the
	  // correct order.
	  var orderedMatrixOperations = [];
	
	  // Wrapping function allows the final function to contain state (for
	  // caching).
	  var fn = 'return (function() {\n';
	  fn += createReusableOperationVars(anims);
	  fn += 'return function(result, value) {\n';
	  fn += '  var didChange = false;\n';
	  fn += '  var nextScalarVal;\n';
	  fn += '  var ratio;\n';
	
	  for (var name in anims) {
	    var anim = anims[name];
	    if (anim.type === 'linear') {
	      if (InterpolateMatrix[name]) {
	        orderedMatrixOperations.push(name);
	        var setOperations = [computeNextMatrixOperationField(anim, name, X_DIM, 0), computeNextMatrixOperationField(anim, name, Y_DIM, 1), computeNextMatrixOperationField(anim, name, Z_DIM, 2)];
	        if (name === TRANSFORM_ROTATE_NAME) {
	          setOperations.push(computeNextMatrixOperationField(anim, name, W_DIM, 3));
	        }
	        fn += newlines(setOperations);
	      } else {
	        fn += computeNextValLinearScalar(anim, 'nextScalarVal');
	        fn += setNextValAndDetectChange(name, 'nextScalarVal');
	      }
	    } else if (anim.type === 'constant') {
	      fn += computeNextValConstant(anim);
	      fn += setNextValAndDetectChange(name, 'nextScalarVal');
	    } else if (anim.type === 'step') {
	      fn += computeNextValStep(anim);
	      fn += setNextValAndDetectChange(name, 'nextScalarVal');
	    } else if (anim.type === 'identity') {
	      fn += computeNextValIdentity(anim);
	      fn += setNextValAndDetectChange(name, 'nextScalarVal');
	    }
	  }
	  if (orderedMatrixOperations.length) {
	    fn += newlines(setNextMatrixAndDetectChange(orderedMatrixOperations));
	  }
	  fn += '  return didChange;\n';
	  fn += '};\n';
	  fn += '})()';
	  return fn;
	};
	
	/**
	 * @param {object} anims Animation configuration by style property name.
	 * @return {function} Function accepting style object, that mutates that style
	 * object and returns a boolean describing if any update was actually applied.
	 */
	var buildStyleInterpolator = function buildStyleInterpolator(anims) {
	  return Function(createFunctionString(anims))();
	};
	
	module.exports = buildStyleInterpolator;

/***/ },
/* 275 */
79,
/* 276 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 */
	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function merge(one, two) {
	  return _extends({}, one, two);
	}
	
	module.exports = merge;

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * @providesModule ReactNavigatorNavigationBarStylesAndroid
	 */
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _polyfillsBuildStyleInterpolator = __webpack_require__(274);
	
	var _polyfillsBuildStyleInterpolator2 = _interopRequireDefault(_polyfillsBuildStyleInterpolator);
	
	var _polyfillsMerge = __webpack_require__(276);
	
	var _polyfillsMerge2 = _interopRequireDefault(_polyfillsMerge);
	
	// Android Material Design
	var NAV_BAR_HEIGHT = 56;
	var TITLE_LEFT = 72;
	var BUTTON_SIZE = 24;
	var TOUCH_TARGT_SIZE = 48;
	var BUTTON_HORIZONTAL_MARGIN = 16;
	
	var BUTTON_EFFECTIVE_MARGIN = BUTTON_HORIZONTAL_MARGIN - (TOUCH_TARGT_SIZE - BUTTON_SIZE) / 2;
	var NAV_ELEMENT_HEIGHT = NAV_BAR_HEIGHT;
	
	var BASE_STYLES = {
	  Title: {
	    position: 'absolute',
	    bottom: 0,
	    left: 0,
	    right: 0,
	    alignItems: 'flex-start',
	    height: NAV_ELEMENT_HEIGHT,
	    backgroundColor: 'transparent',
	    marginLeft: TITLE_LEFT
	  },
	  LeftButton: {
	    position: 'absolute',
	    top: 0,
	    left: BUTTON_EFFECTIVE_MARGIN,
	    overflow: 'hidden',
	    height: NAV_ELEMENT_HEIGHT,
	    backgroundColor: 'transparent'
	  },
	  RightButton: {
	    position: 'absolute',
	    top: 0,
	    right: BUTTON_EFFECTIVE_MARGIN,
	    overflow: 'hidden',
	    alignItems: 'flex-end',
	    height: NAV_ELEMENT_HEIGHT,
	    backgroundColor: 'transparent'
	  }
	};
	
	// There are 3 stages: left, center, right. All previous navigation
	// items are in the left stage. The current navigation item is in the
	// center stage. All upcoming navigation items are in the right stage.
	// Another way to think of the stages is in terms of transitions. When
	// we move forward in the navigation stack, we perform a
	// right-to-center transition on the new navigation item and a
	// center-to-left transition on the current navigation item.
	var Stages = {
	  Left: {
	    Title: (0, _polyfillsMerge2['default'])(BASE_STYLES.Title, { opacity: 0 }),
	    LeftButton: (0, _polyfillsMerge2['default'])(BASE_STYLES.LeftButton, { opacity: 0 }),
	    RightButton: (0, _polyfillsMerge2['default'])(BASE_STYLES.RightButton, { opacity: 0 })
	  },
	  Center: {
	    Title: (0, _polyfillsMerge2['default'])(BASE_STYLES.Title, { opacity: 1 }),
	    LeftButton: (0, _polyfillsMerge2['default'])(BASE_STYLES.LeftButton, { opacity: 1 }),
	    RightButton: (0, _polyfillsMerge2['default'])(BASE_STYLES.RightButton, { opacity: 1 })
	  },
	  Right: {
	    Title: (0, _polyfillsMerge2['default'])(BASE_STYLES.Title, { opacity: 0 }),
	    LeftButton: (0, _polyfillsMerge2['default'])(BASE_STYLES.LeftButton, { opacity: 0 }),
	    RightButton: (0, _polyfillsMerge2['default'])(BASE_STYLES.RightButton, { opacity: 0 })
	  }
	};
	
	var opacityRatio = 100;
	
	function buildSceneInterpolators(startStyles, endStyles) {
	  return {
	    Title: (0, _polyfillsBuildStyleInterpolator2['default'])({
	      opacity: {
	        type: 'linear',
	        from: startStyles.Title.opacity,
	        to: endStyles.Title.opacity,
	        min: 0,
	        max: 1
	      },
	      left: {
	        type: 'linear',
	        from: startStyles.Title.left,
	        to: endStyles.Title.left,
	        min: 0,
	        max: 1,
	        extrapolate: true
	      }
	    }),
	    LeftButton: (0, _polyfillsBuildStyleInterpolator2['default'])({
	      opacity: {
	        type: 'linear',
	        from: startStyles.LeftButton.opacity,
	        to: endStyles.LeftButton.opacity,
	        min: 0,
	        max: 1,
	        round: opacityRatio
	      },
	      left: {
	        type: 'linear',
	        from: startStyles.LeftButton.left,
	        to: endStyles.LeftButton.left,
	        min: 0,
	        max: 1
	      }
	    }),
	    RightButton: (0, _polyfillsBuildStyleInterpolator2['default'])({
	      opacity: {
	        type: 'linear',
	        from: startStyles.RightButton.opacity,
	        to: endStyles.RightButton.opacity,
	        min: 0,
	        max: 1,
	        round: opacityRatio
	      },
	      left: {
	        type: 'linear',
	        from: startStyles.RightButton.left,
	        to: endStyles.RightButton.left,
	        min: 0,
	        max: 1,
	        extrapolate: true
	      }
	    })
	  };
	}
	
	var Interpolators = {
	  // Animating *into* the center stage from the right
	  RightToCenter: buildSceneInterpolators(Stages.Right, Stages.Center),
	  // Animating out of the center stage, to the left
	  CenterToLeft: buildSceneInterpolators(Stages.Center, Stages.Left),
	  // Both stages (animating *past* the center stage)
	  RightToLeft: buildSceneInterpolators(Stages.Right, Stages.Left)
	};
	
	module.exports = {
	  General: {
	    NavBarHeight: NAV_BAR_HEIGHT,
	    StatusBarHeight: 0,
	    TotalNavHeight: NAV_BAR_HEIGHT
	  },
	  Interpolators: Interpolators,
	  Stages: Stages
	};

/***/ },
/* 278 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * @providesModule ReactPlatform
	 */
	
	'use strict';
	
	var Platform = {
	  OS: 'winjs'
	};
	
	module.exports = Platform;

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * @providesModule ReactSetNativeProps
	 */
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(166);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _CSSProperty = __webpack_require__(158);
	
	var _CSSProperty2 = _interopRequireDefault(_CSSProperty);
	
	function convertTransform(style) {
	  var result = {};
	  var transform = '';
	
	  for (var k in style) {
	    if (k === 'transformMatrix') {
	      transform += 'matrix3d(' + style[k].join(',') + ') ';
	    } else if (k === 'translateX' || k === 'translateY' || k === 'translateZ') {
	      var v = style[k];
	      if (typeof v === 'number') v += 'px';
	      transform += k + '(' + v + ') ';
	    } else if (k === 'scaleX' || k === 'scaleY' || k === 'scaleZ') {
	      transform += k + '(' + style[k] + ') ';
	    } else {
	      var val = style[k];
	
	      if (!_CSSProperty2['default'].isUnitlessNumber[k] && typeof val == 'number') {
	        val += 'px';
	      }
	
	      result[k] = val;
	    }
	  }
	
	  if (transform) {
	    result.transform = transform;
	  }
	
	  return result;
	}
	
	function setNativeProps(ref, props) {
	  var node = _reactDom2['default'].findDOMNode(ref);
	  var style = props.style;
	
	  if (style) {
	    style = convertTransform(style);
	    for (var k in style) {
	      node.style[k] = style[k];
	    }
	  }
	}
	
	module.exports = setNativeProps;

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * @providesModule ReactNavigatorNavigationBar
	 */
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _ReactNavigatorNavigationBarStylesAndroid = __webpack_require__(277);
	
	var _ReactNavigatorNavigationBarStylesAndroid2 = _interopRequireDefault(_ReactNavigatorNavigationBarStylesAndroid);
	
	var _ReactNavigatorNavigationBarStylesIOS = __webpack_require__(273);
	
	var _ReactNavigatorNavigationBarStylesIOS2 = _interopRequireDefault(_ReactNavigatorNavigationBarStylesIOS);
	
	var _ReactStyleSheet = __webpack_require__(154);
	
	var _ReactStyleSheet2 = _interopRequireDefault(_ReactStyleSheet);
	
	var _ReactStyleSheet3 = _interopRequireDefault(_ReactStyleSheet);
	
	var _ReactView = __webpack_require__(164);
	
	var _ReactView2 = _interopRequireDefault(_ReactView);
	
	var _ReactSetNativeProps = __webpack_require__(279);
	
	var _ReactSetNativeProps2 = _interopRequireDefault(_ReactSetNativeProps);
	
	var _immutable = __webpack_require__(270);
	
	var COMPONENT_NAMES = ['Title', 'LeftButton', 'RightButton'];
	
	var NavigatorNavigationBarStyles = _ReactStyleSheet2['default'].OS === 'android' ? _ReactNavigatorNavigationBarStylesAndroid2['default'] : _ReactNavigatorNavigationBarStylesIOS2['default'];
	
	var navStatePresentedIndex = function navStatePresentedIndex(navState) {
	  if (navState.presentedIndex !== undefined) {
	    return navState.presentedIndex;
	  }
	  // TODO: rename `observedTopOfStack` to `presentedIndex` in `NavigatorIOS`
	  return navState.observedTopOfStack;
	};
	
	var NavigatorNavigationBar = _react2['default'].createClass({
	  displayName: 'NavigatorNavigationBar',
	
	  propTypes: {
	    navigator: _react.PropTypes.object,
	    routeMapper: _react.PropTypes.shape({
	      Title: _react.PropTypes.func.isRequired,
	      LeftButton: _react.PropTypes.func.isRequired,
	      RightButton: _react.PropTypes.func.isRequired
	    }).isRequired,
	    navState: _react.PropTypes.shape({
	      routeStack: _react.PropTypes.arrayOf(_react.PropTypes.object),
	      presentedIndex: _react.PropTypes.number
	    }),
	    navigationStyles: _react.PropTypes.object,
	    style: _ReactView2['default'].propTypes.style
	  },
	
	  statics: {
	    Styles: NavigatorNavigationBarStyles,
	    StylesAndroid: _ReactNavigatorNavigationBarStylesAndroid2['default'],
	    StylesIOS: _ReactNavigatorNavigationBarStylesIOS2['default']
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      navigationStyles: NavigatorNavigationBarStyles
	    };
	  },
	
	  componentWillMount: function componentWillMount() {
	    var _this = this;
	
	    this._components = {};
	    this._descriptors = {};
	
	    COMPONENT_NAMES.forEach(function (componentName) {
	      _this._components[componentName] = new _immutable.Map();
	      _this._descriptors[componentName] = new _immutable.Map();
	    });
	  },
	
	  _getReusableProps: function _getReusableProps(
	  /* string */componentName,
	  /* number */index) /* object */{
	    if (!this._reusableProps) {
	      this._reusableProps = {};
	    }
	    var propStack = this._reusableProps[componentName];
	    if (!propStack) {
	      propStack = this._reusableProps[componentName] = [];
	    }
	    var props = propStack[index];
	    if (!props) {
	      props = propStack[index] = { style: {} };
	    }
	    return props;
	  },
	
	  _updateIndexProgress: function _updateIndexProgress(
	  /* number */progress,
	  /* number */index,
	  /* number */fromIndex,
	  /* number */toIndex) {
	    var amount = toIndex > fromIndex ? progress : 1 - progress;
	    var oldDistToCenter = index - fromIndex;
	    var newDistToCenter = index - toIndex;
	    var interpolate;
	    if (oldDistToCenter > 0 && newDistToCenter === 0 || newDistToCenter > 0 && oldDistToCenter === 0) {
	      interpolate = this.props.navigationStyles.Interpolators.RightToCenter;
	    } else if (oldDistToCenter < 0 && newDistToCenter === 0 || newDistToCenter < 0 && oldDistToCenter === 0) {
	      interpolate = this.props.navigationStyles.Interpolators.CenterToLeft;
	    } else if (oldDistToCenter === newDistToCenter) {
	      interpolate = this.props.navigationStyles.Interpolators.RightToCenter;
	    } else {
	      interpolate = this.props.navigationStyles.Interpolators.RightToLeft;
	    }
	
	    COMPONENT_NAMES.forEach(function (componentName) {
	      var component = this._components[componentName].get(this.props.navState.routeStack[index]);
	      var props = this._getReusableProps(componentName, index);
	      if (component && interpolate[componentName](props.style, amount)) {
	        (0, _ReactSetNativeProps2['default'])(component, props);
	      }
	    }, this);
	  },
	
	  updateProgress: function updateProgress(
	  /* number */progress,
	  /* number */fromIndex,
	  /* number */toIndex) {
	    var max = Math.max(fromIndex, toIndex);
	    var min = Math.min(fromIndex, toIndex);
	    for (var index = min; index <= max; index++) {
	      this._updateIndexProgress(progress, index, fromIndex, toIndex);
	    }
	  },
	
	  render: function render() {
	    var navBarStyle = {
	      height: this.props.navigationStyles.General.TotalNavHeight
	    };
	    var navState = this.props.navState;
	    var components = COMPONENT_NAMES.map(function (componentName) {
	      return navState.routeStack.map(this._getComponent.bind(this, componentName));
	    }, this);
	
	    return _react2['default'].createElement(
	      _ReactView2['default'],
	      { style: [styles.navBarContainer, navBarStyle, this.props.style] },
	      components
	    );
	  },
	
	  _getComponent: function _getComponent(
	  /* string */componentName,
	  /* object */route,
	  /* number */index) /* ?Object */{
	    var _this2 = this;
	
	    if (this._descriptors[componentName].includes(route)) {
	      return this._descriptors[componentName].get(route);
	    }
	
	    var rendered = null;
	
	    var content = this.props.routeMapper[componentName](this.props.navState.routeStack[index], this.props.navigator, index, this.props.navState);
	    if (!content) {
	      return null;
	    }
	
	    var initialStage = index === navStatePresentedIndex(this.props.navState) ? this.props.navigationStyles.Stages.Center : this.props.navigationStyles.Stages.Left;
	    rendered = _react2['default'].createElement(
	      _ReactView2['default'],
	      {
	        ref: function (ref) {
	          _this2._components[componentName] = _this2._components[componentName].set(route, ref);
	        },
	        style: initialStage[componentName] },
	      content
	    );
	
	    this._descriptors[componentName] = this._descriptors[componentName].set(route, rendered);
	    return rendered;
	  }
	
	});
	
	var styles = _ReactStyleSheet3['default'].create({
	  navBarContainer: {
	    position: 'absolute',
	    top: 0,
	    left: 0,
	    right: 0,
	    backgroundColor: 'transparent'
	  }
	});
	
	module.exports = NavigatorNavigationBar;

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * @providesModule ReactNavigatorSceneConfigs
	 */
	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _ReactDimensions = __webpack_require__(247);
	
	var _ReactDimensions2 = _interopRequireDefault(_ReactDimensions);
	
	var _ReactPixelRatio = __webpack_require__(282);
	
	var _ReactPixelRatio2 = _interopRequireDefault(_ReactPixelRatio);
	
	var _polyfillsBuildStyleInterpolator = __webpack_require__(274);
	
	var _polyfillsBuildStyleInterpolator2 = _interopRequireDefault(_polyfillsBuildStyleInterpolator);
	
	var SCREEN_WIDTH = _ReactDimensions2['default'].get('window').width;
	var SCREEN_HEIGHT = _ReactDimensions2['default'].get('window').height;
	
	var FadeToTheLeft = {
	  // Rotate *requires* you to break out each individual component of
	  // rotation (x, y, z, w)
	  transformTranslate: {
	    from: { x: 0, y: 0, z: 0 },
	    to: { x: -Math.round(_ReactDimensions2['default'].get('window').width * 0.3), y: 0, z: 0 },
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: true,
	    round: _ReactPixelRatio2['default'].get()
	  },
	  // Uncomment to try rotation:
	  // Quick guide to reasoning about rotations:
	  // http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-17-quaternions/#Quaternions
	  // transformRotateRadians: {
	  //   from: {x: 0, y: 0, z: 0, w: 1},
	  //   to: {x: 0, y: 0, z: -0.47, w: 0.87},
	  //   min: 0,
	  //   max: 1,
	  //   type: 'linear',
	  //   extrapolate: true
	  // },
	  transformScale: {
	    from: { x: 1, y: 1, z: 1 },
	    to: { x: 0.95, y: 0.95, z: 1 },
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: true
	  },
	  opacity: {
	    from: 1,
	    to: 0.3,
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: false,
	    round: 100
	  },
	  translateX: {
	    from: 0,
	    to: -Math.round(_ReactDimensions2['default'].get('window').width * 0.3),
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: true,
	    round: _ReactPixelRatio2['default'].get()
	  },
	  scaleX: {
	    from: 1,
	    to: 0.95,
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: true
	  },
	  scaleY: {
	    from: 1,
	    to: 0.95,
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: true
	  }
	};
	
	var FadeToTheRight = _extends({}, FadeToTheLeft, {
	  transformTranslate: {
	    from: { x: 0, y: 0, z: 0 },
	    to: { x: Math.round(SCREEN_WIDTH * 0.3), y: 0, z: 0 }
	  },
	  translateX: {
	    from: 0,
	    to: Math.round(SCREEN_WIDTH * 0.3)
	  }
	});
	
	var FadeIn = {
	  opacity: {
	    from: 0,
	    to: 1,
	    min: 0.5,
	    max: 1,
	    type: 'linear',
	    extrapolate: false,
	    round: 100
	  }
	};
	
	var FadeOut = {
	  opacity: {
	    from: 1,
	    to: 0,
	    min: 0,
	    max: 0.5,
	    type: 'linear',
	    extrapolate: false,
	    round: 100
	  }
	};
	
	var ToTheLeft = {
	  transformTranslate: {
	    from: { x: 0, y: 0, z: 0 },
	    to: { x: -_ReactDimensions2['default'].get('window').width, y: 0, z: 0 },
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: true,
	    round: _ReactPixelRatio2['default'].get()
	  },
	  opacity: {
	    value: 1.0,
	    type: 'constant'
	  },
	
	  translateX: {
	    from: 0,
	    to: -_ReactDimensions2['default'].get('window').width,
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: true,
	    round: _ReactPixelRatio2['default'].get()
	  }
	};
	
	var ToTheUp = {
	  transformTranslate: {
	    from: { x: 0, y: 0, z: 0 },
	    to: { x: 0, y: -_ReactDimensions2['default'].get('window').height, z: 0 },
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: true,
	    round: _ReactPixelRatio2['default'].get()
	  },
	  opacity: {
	    value: 1.0,
	    type: 'constant'
	  },
	  translateY: {
	    from: 0,
	    to: -_ReactDimensions2['default'].get('window').height,
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: true,
	    round: _ReactPixelRatio2['default'].get()
	  }
	};
	
	var ToTheDown = {
	  transformTranslate: {
	    from: { x: 0, y: 0, z: 0 },
	    to: { x: 0, y: _ReactDimensions2['default'].get('window').height, z: 0 },
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: true,
	    round: _ReactPixelRatio2['default'].get()
	  },
	  opacity: {
	    value: 1.0,
	    type: 'constant'
	  },
	  translateY: {
	    from: 0,
	    to: _ReactDimensions2['default'].get('window').height,
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: true,
	    round: _ReactPixelRatio2['default'].get()
	  }
	};
	
	var FromTheRight = {
	  opacity: {
	    value: 1.0,
	    type: 'constant'
	  },
	
	  transformTranslate: {
	    from: { x: _ReactDimensions2['default'].get('window').width, y: 0, z: 0 },
	    to: { x: 0, y: 0, z: 0 },
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: true,
	    round: _ReactPixelRatio2['default'].get()
	  },
	
	  translateX: {
	    from: _ReactDimensions2['default'].get('window').width,
	    to: 0,
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: true,
	    round: _ReactPixelRatio2['default'].get()
	  },
	
	  scaleX: {
	    value: 1,
	    type: 'constant'
	  },
	  scaleY: {
	    value: 1,
	    type: 'constant'
	  }
	};
	
	var FromTheLeft = _extends({}, FromTheRight, {
	  transformTranslate: {
	    from: { x: -SCREEN_WIDTH, y: 0, z: 0 },
	    to: { x: 0, y: 0, z: 0 },
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: true,
	    round: _ReactPixelRatio2['default'].get()
	  },
	  translateX: {
	    from: -SCREEN_WIDTH,
	    to: 0,
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: true,
	    round: _ReactPixelRatio2['default'].get()
	  }
	});
	
	var FromTheDown = _extends({}, FromTheRight, {
	  transformTranslate: {
	    from: { y: SCREEN_HEIGHT, x: 0, z: 0 },
	    to: { x: 0, y: 0, z: 0 },
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: true,
	    round: _ReactPixelRatio2['default'].get()
	  },
	  translateY: {
	    from: SCREEN_HEIGHT,
	    to: 0,
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: true,
	    round: _ReactPixelRatio2['default'].get()
	  }
	});
	
	var FromTheTop = _extends({}, FromTheRight, {
	  transformTranslate: {
	    from: { y: -SCREEN_HEIGHT, x: 0, z: 0 },
	    to: { x: 0, y: 0, z: 0 },
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: true,
	    round: _ReactPixelRatio2['default'].get()
	  },
	  translateY: {
	    from: -SCREEN_HEIGHT,
	    to: 0,
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: true,
	    round: _ReactPixelRatio2['default'].get()
	  }
	});
	
	var ToTheBack = {
	  // Rotate *requires* you to break out each individual component of
	  // rotation (x, y, z, w)
	  transformTranslate: {
	    from: { x: 0, y: 0, z: 0 },
	    to: { x: 0, y: 0, z: 0 },
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: true,
	    round: _ReactPixelRatio2['default'].get()
	  },
	  transformScale: {
	    from: { x: 1, y: 1, z: 1 },
	    to: { x: 0.95, y: 0.95, z: 1 },
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: true
	  },
	  opacity: {
	    from: 1,
	    to: 0.3,
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: false,
	    round: 100
	  },
	  scaleX: {
	    from: 1,
	    to: 0.95,
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: true
	  },
	  scaleY: {
	    from: 1,
	    to: 0.95,
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: true
	  }
	};
	
	var FromTheFront = {
	  opacity: {
	    value: 1.0,
	    type: 'constant'
	  },
	
	  transformTranslate: {
	    from: { x: 0, y: _ReactDimensions2['default'].get('window').height, z: 0 },
	    to: { x: 0, y: 0, z: 0 },
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: true,
	    round: _ReactPixelRatio2['default'].get()
	  },
	  translateY: {
	    from: _ReactDimensions2['default'].get('window').height,
	    to: 0,
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: true,
	    round: _ReactPixelRatio2['default'].get()
	  },
	  scaleX: {
	    value: 1,
	    type: 'constant'
	  },
	  scaleY: {
	    value: 1,
	    type: 'constant'
	  }
	};
	
	var ToTheBackAndroid = {
	  opacity: {
	    value: 1,
	    type: 'constant'
	  }
	};
	
	var FromTheFrontAndroid = {
	  opacity: {
	    from: 0,
	    to: 1,
	    min: 0.5,
	    max: 1,
	    type: 'linear',
	    extrapolate: false,
	    round: 100
	  },
	  transformTranslate: {
	    from: { x: 0, y: 100, z: 0 },
	    to: { x: 0, y: 0, z: 0 },
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: true,
	    round: _ReactPixelRatio2['default'].get()
	  },
	  translateY: {
	    from: 100,
	    to: 0,
	    min: 0,
	    max: 1,
	    type: 'linear',
	    extrapolate: true,
	    round: _ReactPixelRatio2['default'].get()
	  }
	};
	
	var BaseOverswipeConfig = {
	  frictionConstant: 1,
	  frictionByDistance: 1.5
	};
	
	var BaseLeftToRightGesture = {
	
	  // If the gesture can end and restart during one continuous touch
	  isDetachable: false,
	
	  // How far the swipe must drag to start transitioning
	  gestureDetectMovement: 2,
	
	  // Amplitude of release velocity that is considered still
	  notMoving: 0.3,
	
	  // Fraction of directional move required.
	  directionRatio: 0.66,
	
	  // Velocity to transition with when the gesture release was "not moving"
	  snapVelocity: 2,
	
	  // Region that can trigger swipe. iOS default is 30px from the left edge
	  edgeHitWidth: 30,
	
	  // Ratio of gesture completion when non-velocity release will cause action
	  stillCompletionRatio: 3 / 5,
	
	  fullDistance: SCREEN_WIDTH,
	
	  direction: 'left-to-right'
	
	};
	
	var BaseRightToLeftGesture = _extends({}, BaseLeftToRightGesture, {
	  direction: 'right-to-left'
	});
	
	var BaseDownUpGesture = _extends({}, BaseLeftToRightGesture, {
	  fullDistance: SCREEN_HEIGHT,
	  direction: 'down-to-up'
	});
	
	var BaseUpDownGesture = _extends({}, BaseLeftToRightGesture, {
	  fullDistance: SCREEN_HEIGHT,
	  direction: 'up-to-down'
	});
	
	var BaseConfig = {
	  // A list of all gestures that are enabled on this scene
	  gestures: {
	    pop: BaseLeftToRightGesture
	  },
	
	  // Rebound spring parameters when transitioning FROM this scene
	  springFriction: 26,
	  springTension: 200,
	
	  // Velocity to start at when transitioning without gesture
	  defaultTransitionVelocity: 1.5,
	
	  // Animation interpolators for horizontal transitioning:
	  animationInterpolators: {
	    into: (0, _polyfillsBuildStyleInterpolator2['default'])(FromTheRight),
	    out: (0, _polyfillsBuildStyleInterpolator2['default'])(FadeToTheLeft)
	  }
	};
	
	var NavigatorSceneConfigs = {
	  PushFromRight: _extends({}, BaseConfig),
	
	  // We will want to customize this soon
	  FloatFromRight: _extends({}, BaseConfig),
	
	  // We will want to customize this soon
	  FloatFromLeft: _extends({}, BaseConfig, {
	    animationInterpolators: {
	      into: (0, _polyfillsBuildStyleInterpolator2['default'])(FromTheLeft),
	      out: (0, _polyfillsBuildStyleInterpolator2['default'])(FadeToTheRight)
	    }
	  }),
	  FloatFromBottom: _extends({}, BaseConfig, {
	    gestures: {
	      pop: _extends({}, BaseLeftToRightGesture, {
	        edgeHitWidth: 150,
	        direction: 'top-to-bottom',
	        fullDistance: SCREEN_HEIGHT
	      })
	    },
	    animationInterpolators: {
	      into: (0, _polyfillsBuildStyleInterpolator2['default'])(FromTheFront),
	      out: (0, _polyfillsBuildStyleInterpolator2['default'])(ToTheBack)
	    }
	  }),
	  FloatFromBottomAndroid: _extends({}, BaseConfig, {
	    gestures: null,
	    defaultTransitionVelocity: 3,
	    springFriction: 20,
	    animationInterpolators: {
	      into: (0, _polyfillsBuildStyleInterpolator2['default'])(FromTheFrontAndroid),
	      out: (0, _polyfillsBuildStyleInterpolator2['default'])(ToTheBackAndroid)
	    }
	  }),
	  FadeAndroid: _extends({}, BaseConfig, {
	    gestures: null,
	    animationInterpolators: {
	      into: (0, _polyfillsBuildStyleInterpolator2['default'])(FadeIn),
	      out: (0, _polyfillsBuildStyleInterpolator2['default'])(FadeOut)
	    }
	  }),
	  HorizontalSwipeJump: _extends({}, BaseConfig, {
	    gestures: {
	      jumpBack: _extends({}, BaseLeftToRightGesture, {
	        overswipe: BaseOverswipeConfig,
	        edgeHitWidth: null,
	        isDetachable: true
	      }),
	      jumpForward: _extends({}, BaseRightToLeftGesture, {
	        overswipe: BaseOverswipeConfig,
	        edgeHitWidth: null,
	        isDetachable: true
	      })
	    },
	    animationInterpolators: {
	      into: (0, _polyfillsBuildStyleInterpolator2['default'])(FromTheRight),
	      out: (0, _polyfillsBuildStyleInterpolator2['default'])(ToTheLeft)
	    }
	  }),
	  VerticalUpSwipeJump: _extends({}, BaseConfig, {
	    gestures: {
	      jumpBack: _extends({}, BaseDownUpGesture, {
	        overswipe: BaseOverswipeConfig,
	        edgeHitWidth: null,
	        isDetachable: true
	      }),
	      jumpForward: _extends({}, BaseDownUpGesture, {
	        overswipe: BaseOverswipeConfig,
	        edgeHitWidth: null,
	        isDetachable: true
	      })
	    },
	    animationInterpolators: {
	      into: (0, _polyfillsBuildStyleInterpolator2['default'])(FromTheDown),
	      out: (0, _polyfillsBuildStyleInterpolator2['default'])(ToTheUp)
	    }
	  }),
	  VerticalDownSwipeJump: _extends({}, BaseConfig, {
	    gestures: {
	      jumpBack: _extends({}, BaseUpDownGesture, {
	        overswipe: BaseOverswipeConfig,
	        edgeHitWidth: null,
	        isDetachable: true
	      }),
	      jumpForward: _extends({}, BaseUpDownGesture, {
	        overswipe: BaseOverswipeConfig,
	        edgeHitWidth: null,
	        isDetachable: true
	      })
	    },
	    animationInterpolators: {
	      into: (0, _polyfillsBuildStyleInterpolator2['default'])(FromTheTop),
	      out: (0, _polyfillsBuildStyleInterpolator2['default'])(ToTheDown)
	    }
	  })
	};
	
	module.exports = NavigatorSceneConfigs;

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * @providesModule ReactPixelRatio
	 */
	'use strict';
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _ReactDimensions = __webpack_require__(247);
	
	var _ReactDimensions2 = _interopRequireDefault(_ReactDimensions);
	
	/**
	 * PixelRatio class gives access to the device pixel density.
	 *
	 * There are a few use cases for using PixelRatio:
	 *
	 * ### Displaying a line that's as thin as the device permits
	 *
	 * A width of 1 is actually pretty thick on devices with high pixel density
	 * (such as iPhone 4+ and many Android devices), we can make one that's
	 * thinner using a width of `1 / PixelRatio.get()`.
	 * It's a technique that works on all the devices independent of their
	 * pixel density.
	 *
	 * ```
	 * style={{ borderWidth: 1 / PixelRatio.get() }}
	 * ```
	 *
	 * ### Fetching a correctly sized image
	 *
	 * You should get a higher resolution image if you are on a high pixel density
	 * device. A good rule of thumb is to multiply the size of the image you display
	 * by the pixel ratio.
	 *
	 * ```
	 * var image = getImage({
	 *   width: PixelRatio.getPixelSizeForLayoutSize(200),
	 *   height: PixelRatio.getPixelSizeForLayoutSize(100),
	 * });
	 * <Image source={image} style={{width: 200, height: 100}} />
	 * ```
	 */
	
	var PixelRatio = (function () {
	  function PixelRatio() {
	    _classCallCheck(this, PixelRatio);
	  }
	
	  _createClass(PixelRatio, null, [{
	    key: 'get',
	
	    /**
	     * Returns the device pixel density. Some examples:
	     *
	     *   - PixelRatio.get() === 1
	     *     - mdpi Android devices (160 dpi)
	     *   - PixelRatio.get() === 1.5
	     *     - hdpi Android devices (240 dpi)
	     *   - PixelRatio.get() === 2
	     *     - iPhone 4, 4S
	     *     - iPhone 5, 5c, 5s
	     *     - iPhone 6
	     *     - xhdpi Android devices (320 dpi)
	     *   - PixelRatio.get() === 3
	     *     - iPhone 6 plus
	     *     - xxhdpi Android devices (480 dpi)
	     *   - PixelRatio.get() === 3.5
	     *     - Nexus 6
	     */
	    value: function get() {
	      return _ReactDimensions2['default'].get('window').scale;
	    }
	
	    /**
	     * Returns the scaling factor for font sizes. This is the ratio that is used to calculate the
	     * absolute font size, so any elements that heavily depend on that should use this to do
	     * calculations.
	     *
	     * If a font scale is not set, this returns the device pixel ratio.
	     *
	     * Currently this is only implemented on Android and reflects the user preference set in
	     * Settings > Display > Font size, on iOS it will always return the default pixel ratio.
	     * @platform android
	     */
	  }, {
	    key: 'getFontScale',
	    value: function getFontScale() {
	      return _ReactDimensions2['default'].get('window').fontScale || PixelRatio.get();
	    }
	
	    /**
	     * Converts a layout size (dp) to pixel size (px).
	     *
	     * Guaranteed to return an integer number.
	     */
	  }, {
	    key: 'getPixelSizeForLayoutSize',
	    value: function getPixelSizeForLayoutSize(layoutSize) {
	      return Math.round(layoutSize * PixelRatio.get());
	    }
	
	    // No-op for iOS, but used on the web. Should not be documented.
	  }, {
	    key: 'startDetecting',
	    value: function startDetecting() {}
	  }]);
	
	  return PixelRatio;
	})();
	
	module.exports = PixelRatio;

/***/ },
/* 283 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactSubscribable
	 * 
	 */
	'use strict';
	
	/**
	 * Subscribable provides a mixin for safely subscribing a component to an
	 * eventEmitter
	 *
	 * This will be replaced with the observe interface that will be coming soon to
	 * React Core
	 */
	
	var Subscribable = {};
	
	Subscribable.Mixin = {
	
	  componentWillMount: function componentWillMount() {
	    this._subscribableSubscriptions = [];
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    this._subscribableSubscriptions.forEach(function (subscription) {
	      return subscription.remove();
	    });
	    this._subscribableSubscriptions = null;
	  },
	
	  /**
	   * Special form of calling `addListener` that *guarantees* that a
	   * subscription *must* be tied to a component instance, and therefore will
	   * be cleaned up when the component is unmounted. It is impossible to create
	   * the subscription and pass it in - this method must be the one to create
	   * the subscription and therefore can guarantee it is retained in a way that
	   * will be cleaned up.
	   *
	   * @param {EventEmitter} eventEmitter emitter to subscribe to.
	   * @param {string} eventType Type of event to listen to.
	   * @param {function} listener Function to invoke when event occurs.
	   * @param {object} context Object to use as listener context.
	   */
	  addListenerOn: function addListenerOn(eventEmitter, eventType, listener, context) {
	    this._subscribableSubscriptions.push(eventEmitter.addListener(eventType, listener, context));
	  }
	};
	
	module.exports = Subscribable;

/***/ },
/* 284 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/*
	 *  Copyright (c) 2015-present, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	'use strict';
	
	var GLOBAL = typeof window === 'undefined' ? global : window;
	
	var setter = function(_setter, _clearer, array) {
	  return function(callback, delta) {
	    var id = _setter(function() {
	      _clearer.call(this, id);
	      callback.apply(this, arguments);
	    }.bind(this), delta);
	
	    if (!this[array]) {
	      this[array] = [id];
	    } else {
	      this[array].push(id);
	    }
	    return id;
	  };
	};
	
	var clearer = function(_clearer, array) {
	  return function(id) {
	    if (this[array]) {
	      var index = this[array].indexOf(id);
	      if (index !== -1) {
	        this[array].splice(index, 1);
	      }
	    }
	    _clearer(id);
	  };
	};
	
	var _timeouts = 'TimerMixin_timeouts';
	var _clearTimeout = clearer(GLOBAL.clearTimeout, _timeouts);
	var _setTimeout = setter(GLOBAL.setTimeout, _clearTimeout, _timeouts);
	
	var _intervals = 'TimerMixin_intervals';
	var _clearInterval = clearer(GLOBAL.clearInterval, _intervals);
	var _setInterval = setter(GLOBAL.setInterval, function() {/* noop */}, _intervals);
	
	var _immediates = 'TimerMixin_immediates';
	var _clearImmediate = clearer(GLOBAL.clearImmediate, _immediates);
	var _setImmediate = setter(GLOBAL.setImmediate, _clearImmediate, _immediates);
	
	var _rafs = 'TimerMixin_rafs';
	var _cancelAnimationFrame = clearer(GLOBAL.cancelAnimationFrame, _rafs);
	var _requestAnimationFrame = setter(GLOBAL.requestAnimationFrame, _cancelAnimationFrame, _rafs);
	
	var TimerMixin = {
	  componentWillUnmount: function() {
	    this[_timeouts] && this[_timeouts].forEach(this.clearTimeout);
	    this[_intervals] && this[_intervals].forEach(this.clearInterval);
	    this[_immediates] && this[_immediates].forEach(this.clearImmediate);
	    this[_rafs] && this[_rafs].forEach(this.cancelAnimationFrame);
	  },
	
	  setTimeout: _setTimeout,
	  clearTimeout: _clearTimeout,
	
	  setInterval: _setInterval,
	  clearInterval: _clearInterval,
	
	  setImmediate: _setImmediate,
	  clearImmediate: _clearImmediate,
	
	  requestAnimationFrame: _requestAnimationFrame,
	  cancelAnimationFrame: _cancelAnimationFrame,
	};
	
	module.exports = TimerMixin;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 285 */
/***/ function(module, exports) {

	/**
	 * @generated SignedSource<<ec51291ea6059cf23faa74f8644d17b1>>
	 *
	 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	 * !! This file is a check-in of a static_upstream project!      !!
	 * !!                                                            !!
	 * !! You should not modify this file directly. Instead:         !!
	 * !! 1) Use `fjs use-upstream` to temporarily replace this with !!
	 * !!    the latest version from upstream.                       !!
	 * !! 2) Make your changes, test them, etc.                      !!
	 * !! 3) Use `fjs push-upstream` to copy your changes back to    !!
	 * !!    static_upstream.                                        !!
	 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	 *
	 * @providesModule clamp
	 * @typechecks
	 */
	
	/**
	 * @param {number} value
	 * @param {number} min
	 * @param {number} max
	 * @return {number}
	 */
	"use strict";
	
	function clamp(min, value, max) {
	  if (value < min) {
	    return min;
	  }
	  if (value > max) {
	    return max;
	  }
	  return value;
	}
	
	module.exports = clamp;

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, setImmediate) {// Rebound
	// =======
	// **Rebound** is a simple library that models Spring dynamics for the
	// purpose of driving physical animations.
	//
	// Origin
	// ------
	// [Rebound](http://facebook.github.io/rebound) was originally written
	// in Java to provide a lightweight physics system for
	// [Home](https://play.google.com/store/apps/details?id=com.facebook.home) and
	// [Chat Heads](https://play.google.com/store/apps/details?id=com.facebook.orca)
	// on Android. It's now been adopted by several other Android
	// applications. This JavaScript port was written to provide a quick
	// way to demonstrate Rebound animations on the web for a
	// [conference talk](https://www.youtube.com/watch?v=s5kNm-DgyjY). Since then
	// the JavaScript version has been used to build some really nice interfaces.
	// Check out [brandonwalkin.com](http://brandonwalkin.com) for an
	// example.
	//
	// Overview
	// --------
	// The Library provides a SpringSystem for maintaining a set of Spring
	// objects and iterating those Springs through a physics solver loop
	// until equilibrium is achieved. The Spring class is the basic
	// animation driver provided by Rebound. By attaching a listener to
	// a Spring, you can observe its motion. The observer function is
	// notified of position changes on the spring as it solves for
	// equilibrium. These position updates can be mapped to an animation
	// range to drive animated property updates on your user interface
	// elements (translation, rotation, scale, etc).
	//
	// Example
	// -------
	// Here's a simple example. Pressing and releasing on the logo below
	// will cause it to scale up and down with a springy animation.
	//
	// <div style="text-align:center; margin-bottom:50px; margin-top:50px">
	//   <img
	//     src="http://facebook.github.io/rebound/images/rebound.png"
	//     id="logo"
	//   />
	// </div>
	// <script src="../rebound.min.js"></script>
	// <script>
	//
	// function scale(el, val) {
	//   el.style.mozTransform =
	//   el.style.msTransform =
	//   el.style.webkitTransform =
	//   el.style.transform = 'scale3d(' + val + ', ' + val + ', 1)';
	// }
	// var el = document.getElementById('logo');
	//
	// var springSystem = new rebound.SpringSystem();
	// var spring = springSystem.createSpring(50, 3);
	// spring.addListener({
	//   onSpringUpdate: function(spring) {
	//     var val = spring.getCurrentValue();
	//     val = rebound.MathUtil.mapValueInRange(val, 0, 1, 1, 0.5);
	//     scale(el, val);
	//   }
	// });
	//
	// el.addEventListener('mousedown', function() {
	//   spring.setEndValue(1);
	// });
	//
	// el.addEventListener('mouseout', function() {
	//   spring.setEndValue(0);
	// });
	//
	// el.addEventListener('mouseup', function() {
	//   spring.setEndValue(0);
	// });
	//
	// </script>
	//
	// Here's how it works.
	//
	// ```
	// // Get a reference to the logo element.
	// var el = document.getElementById('logo');
	//
	// // create a SpringSystem and a Spring with a bouncy config.
	// var springSystem = new rebound.SpringSystem();
	// var spring = springSystem.createSpring(50, 3);
	//
	// // Add a listener to the spring. Every time the physics
	// // solver updates the Spring's value onSpringUpdate will
	// // be called.
	// spring.addListener({
	//   onSpringUpdate: function(spring) {
	//     var val = spring.getCurrentValue();
	//     val = rebound.MathUtil
	//                  .mapValueInRange(val, 0, 1, 1, 0.5);
	//     scale(el, val);
	//   }
	// });
	//
	// // Listen for mouse down/up/out and toggle the
	// //springs endValue from 0 to 1.
	// el.addEventListener('mousedown', function() {
	//   spring.setEndValue(1);
	// });
	//
	// el.addEventListener('mouseout', function() {
	//   spring.setEndValue(0);
	// });
	//
	// el.addEventListener('mouseup', function() {
	//   spring.setEndValue(0);
	// });
	//
	// // Helper for scaling an element with css transforms.
	// function scale(el, val) {
	//   el.style.mozTransform =
	//   el.style.msTransform =
	//   el.style.webkitTransform =
	//   el.style.transform = 'scale3d(' +
	//     val + ', ' + val + ', 1)';
	// }
	// ```
	
	(function() {
	  var rebound = {};
	  var util = rebound.util = {};
	  var concat = Array.prototype.concat;
	  var slice = Array.prototype.slice;
	
	  // Bind a function to a context object.
	  util.bind = function bind(func, context) {
	    var args = slice.call(arguments, 2);
	    return function() {
	      func.apply(context, concat.call(args, slice.call(arguments)));
	    };
	  };
	
	  // Add all the properties in the source to the target.
	  util.extend = function extend(target, source) {
	    for (var key in source) {
	      if (source.hasOwnProperty(key)) {
	        target[key] = source[key];
	      }
	    }
	  };
	
	  // SpringSystem
	  // ------------
	  // **SpringSystem** is a set of Springs that all run on the same physics
	  // timing loop. To get started with a Rebound animation you first
	  // create a new SpringSystem and then add springs to it.
	  var SpringSystem = rebound.SpringSystem = function SpringSystem(looper) {
	    this._springRegistry = {};
	    this._activeSprings = [];
	    this.listeners = [];
	    this._idleSpringIndices = [];
	    this.looper = looper || new AnimationLooper();
	    this.looper.springSystem = this;
	  };
	
	  util.extend(SpringSystem.prototype, {
	
	    _springRegistry: null,
	
	    _isIdle: true,
	
	    _lastTimeMillis: -1,
	
	    _activeSprings: null,
	
	    listeners: null,
	
	    _idleSpringIndices: null,
	
	    // A SpringSystem is iterated by a looper. The looper is responsible
	    // for executing each frame as the SpringSystem is resolved to idle.
	    // There are three types of Loopers described below AnimationLooper,
	    // SimulationLooper, and SteppingSimulationLooper. AnimationLooper is
	    // the default as it is the most useful for common UI animations.
	    setLooper: function(looper) {
	      this.looper = looper;
	      looper.springSystem = this;
	    },
	
	    // Add a new spring to this SpringSystem. This Spring will now be solved for
	    // during the physics iteration loop. By default the spring will use the
	    // default Origami spring config with 40 tension and 7 friction, but you can
	    // also provide your own values here.
	    createSpring: function(tension, friction) {
	      var springConfig;
	      if (tension === undefined || friction === undefined) {
	        springConfig = SpringConfig.DEFAULT_ORIGAMI_SPRING_CONFIG;
	      } else {
	        springConfig =
	          SpringConfig.fromOrigamiTensionAndFriction(tension, friction);
	      }
	      return this.createSpringWithConfig(springConfig);
	    },
	
	    // Add a spring with a specified bounciness and speed. To replicate Origami
	    // compositions based on PopAnimation patches, use this factory method to
	    // create matching springs.
	    createSpringWithBouncinessAndSpeed: function(bounciness, speed) {
	      var springConfig;
	      if (bounciness === undefined || speed === undefined) {
	        springConfig = SpringConfig.DEFAULT_ORIGAMI_SPRING_CONFIG;
	      } else {
	        springConfig =
	          SpringConfig.fromBouncinessAndSpeed(bounciness, speed);
	      }
	      return this.createSpringWithConfig(springConfig);
	    },
	
	    // Add a spring with the provided SpringConfig.
	    createSpringWithConfig: function(springConfig) {
	      var spring = new Spring(this);
	      this.registerSpring(spring);
	      spring.setSpringConfig(springConfig);
	      return spring;
	    },
	
	    // You can check if a SpringSystem is idle or active by calling
	    // getIsIdle. If all of the Springs in the SpringSystem are at rest,
	    // i.e. the physics forces have reached equilibrium, then this
	    // method will return true.
	    getIsIdle: function() {
	      return this._isIdle;
	    },
	
	    // Retrieve a specific Spring from the SpringSystem by id. This
	    // can be useful for inspecting the state of a spring before
	    // or after an integration loop in the SpringSystem executes.
	    getSpringById: function (id) {
	      return this._springRegistry[id];
	    },
	
	    // Get a listing of all the springs registered with this
	    // SpringSystem.
	    getAllSprings: function() {
	      var vals = [];
	      for (var id in this._springRegistry) {
	        if (this._springRegistry.hasOwnProperty(id)) {
	          vals.push(this._springRegistry[id]);
	        }
	      }
	      return vals;
	    },
	
	    // registerSpring is called automatically as soon as you create
	    // a Spring with SpringSystem#createSpring. This method sets the
	    // spring up in the registry so that it can be solved in the
	    // solver loop.
	    registerSpring: function(spring) {
	      this._springRegistry[spring.getId()] = spring;
	    },
	
	    // Deregister a spring with this SpringSystem. The SpringSystem will
	    // no longer consider this Spring during its integration loop once
	    // this is called. This is normally done automatically for you when
	    // you call Spring#destroy.
	    deregisterSpring: function(spring) {
	      removeFirst(this._activeSprings, spring);
	      delete this._springRegistry[spring.getId()];
	    },
	
	    advance: function(time, deltaTime) {
	      while(this._idleSpringIndices.length > 0) this._idleSpringIndices.pop();
	      for (var i = 0, len = this._activeSprings.length; i < len; i++) {
	        var spring = this._activeSprings[i];
	        if (spring.systemShouldAdvance()) {
	          spring.advance(time / 1000.0, deltaTime / 1000.0);
	        } else {
	          this._idleSpringIndices.push(this._activeSprings.indexOf(spring));
	        }
	      }
	      while(this._idleSpringIndices.length > 0) {
	        var idx = this._idleSpringIndices.pop();
	        idx >= 0 && this._activeSprings.splice(idx, 1);
	      }
	    },
	
	    // This is our main solver loop called to move the simulation
	    // forward through time. Before each pass in the solver loop
	    // onBeforeIntegrate is called on an any listeners that have
	    // registered themeselves with the SpringSystem. This gives you
	    // an opportunity to apply any constraints or adjustments to
	    // the springs that should be enforced before each iteration
	    // loop. Next the advance method is called to move each Spring in
	    // the systemShouldAdvance forward to the current time. After the
	    // integration step runs in advance, onAfterIntegrate is called
	    // on any listeners that have registered themselves with the
	    // SpringSystem. This gives you an opportunity to run any post
	    // integration constraints or adjustments on the Springs in the
	    // SpringSystem.
	    loop: function(currentTimeMillis) {
	      var listener;
	      if (this._lastTimeMillis === -1) {
	        this._lastTimeMillis = currentTimeMillis -1;
	      }
	      var ellapsedMillis = currentTimeMillis - this._lastTimeMillis;
	      this._lastTimeMillis = currentTimeMillis;
	
	      var i = 0, len = this.listeners.length;
	      for (i = 0; i < len; i++) {
	        listener = this.listeners[i];
	        listener.onBeforeIntegrate && listener.onBeforeIntegrate(this);
	      }
	
	      this.advance(currentTimeMillis, ellapsedMillis);
	      if (this._activeSprings.length === 0) {
	        this._isIdle = true;
	        this._lastTimeMillis = -1;
	      }
	
	      for (i = 0; i < len; i++) {
	        listener = this.listeners[i];
	        listener.onAfterIntegrate && listener.onAfterIntegrate(this);
	      }
	
	      if (!this._isIdle) {
	        this.looper.run();
	      }
	    },
	
	    // activateSpring is used to notify the SpringSystem that a Spring
	    // has become displaced. The system responds by starting its solver
	    // loop up if it is currently idle.
	    activateSpring: function(springId) {
	      var spring = this._springRegistry[springId];
	      if (this._activeSprings.indexOf(spring) == -1) {
	        this._activeSprings.push(spring);
	      }
	      if (this.getIsIdle()) {
	        this._isIdle = false;
	        this.looper.run();
	      }
	    },
	
	    // Add a listener to the SpringSystem so that you can receive
	    // before/after integration notifications allowing Springs to be
	    // constrained or adjusted.
	    addListener: function(listener) {
	      this.listeners.push(listener);
	    },
	
	    // Remove a previously added listener on the SpringSystem.
	    removeListener: function(listener) {
	      removeFirst(this.listeners, listener);
	    },
	
	    // Remove all previously added listeners on the SpringSystem.
	    removeAllListeners: function() {
	      this.listeners = [];
	    }
	
	  });
	
	  // Spring
	  // ------
	  // **Spring** provides a model of a classical spring acting to
	  // resolve a body to equilibrium. Springs have configurable
	  // tension which is a force multipler on the displacement of the
	  // spring from its rest point or `endValue` as defined by [Hooke's
	  // law](http://en.wikipedia.org/wiki/Hooke's_law). Springs also have
	  // configurable friction, which ensures that they do not oscillate
	  // infinitely. When a Spring is displaced by updating it's resting
	  // or `currentValue`, the SpringSystems that contain that Spring
	  // will automatically start looping to solve for equilibrium. As each
	  // timestep passes, `SpringListener` objects attached to the Spring
	  // will be notified of the updates providing a way to drive an
	  // animation off of the spring's resolution curve.
	  var Spring = rebound.Spring = function Spring(springSystem) {
	    this._id = 's' + Spring._ID++;
	    this._springSystem = springSystem;
	    this.listeners = [];
	    this._currentState = new PhysicsState();
	    this._previousState = new PhysicsState();
	    this._tempState = new PhysicsState();
	  };
	
	  util.extend(Spring, {
	    _ID: 0,
	
	    MAX_DELTA_TIME_SEC: 0.064,
	
	    SOLVER_TIMESTEP_SEC: 0.001
	
	  });
	
	  util.extend(Spring.prototype, {
	
	    _id: 0,
	
	    _springConfig: null,
	
	    _overshootClampingEnabled: false,
	
	    _currentState: null,
	
	    _previousState: null,
	
	    _tempState: null,
	
	    _startValue: 0,
	
	    _endValue: 0,
	
	    _wasAtRest: true,
	
	    _restSpeedThreshold: 0.001,
	
	    _displacementFromRestThreshold: 0.001,
	
	    listeners: null,
	
	    _timeAccumulator: 0,
	
	    _springSystem: null,
	
	    // Remove a Spring from simulation and clear its listeners.
	    destroy: function() {
	      this.listeners = [];
	      this.frames = [];
	      this._springSystem.deregisterSpring(this);
	    },
	
	    // Get the id of the spring, which can be used to retrieve it from
	    // the SpringSystems it participates in later.
	    getId: function() {
	      return this._id;
	    },
	
	    // Set the configuration values for this Spring. A SpringConfig
	    // contains the tension and friction values used to solve for the
	    // equilibrium of the Spring in the physics loop.
	    setSpringConfig: function(springConfig) {
	      this._springConfig = springConfig;
	      return this;
	    },
	
	    // Retrieve the SpringConfig used by this Spring.
	    getSpringConfig: function() {
	      return this._springConfig;
	    },
	
	    // Set the current position of this Spring. Listeners will be updated
	    // with this value immediately. If the rest or `endValue` is not
	    // updated to match this value, then the spring will be dispalced and
	    // the SpringSystem will start to loop to restore the spring to the
	    // `endValue`.
	    //
	    // A common pattern is to move a Spring around without animation by
	    // calling.
	    //
	    // ```
	    // spring.setCurrentValue(n).setAtRest();
	    // ```
	    //
	    // This moves the Spring to a new position `n`, sets the endValue
	    // to `n`, and removes any velocity from the `Spring`. By doing
	    // this you can allow the `SpringListener` to manage the position
	    // of UI elements attached to the spring even when moving without
	    // animation. For example, when dragging an element you can
	    // update the position of an attached view through a spring
	    // by calling `spring.setCurrentValue(x)`. When
	    // the gesture ends you can update the Springs
	    // velocity and endValue
	    // `spring.setVelocity(gestureEndVelocity).setEndValue(flingTarget)`
	    // to cause it to naturally animate the UI element to the resting
	    // position taking into account existing velocity. The codepaths for
	    // synchronous movement and spring driven animation can
	    // be unified using this technique.
	    setCurrentValue: function(currentValue, skipSetAtRest) {
	      this._startValue = currentValue;
	      this._currentState.position = currentValue;
	      if (!skipSetAtRest) {
	        this.setAtRest();
	      }
	      this.notifyPositionUpdated(false, false);
	      return this;
	    },
	
	    // Get the position that the most recent animation started at. This
	    // can be useful for determining the number off oscillations that
	    // have occurred.
	    getStartValue: function() {
	      return this._startValue;
	    },
	
	    // Retrieve the current value of the Spring.
	    getCurrentValue: function() {
	      return this._currentState.position;
	    },
	
	    // Get the absolute distance of the Spring from it's resting endValue
	    // position.
	    getCurrentDisplacementDistance: function() {
	      return this.getDisplacementDistanceForState(this._currentState);
	    },
	
	    getDisplacementDistanceForState: function(state) {
	      return Math.abs(this._endValue - state.position);
	    },
	
	    // Set the endValue or resting position of the spring. If this
	    // value is different than the current value, the SpringSystem will
	    // be notified and will begin running its solver loop to resolve
	    // the Spring to equilibrium. Any listeners that are registered
	    // for onSpringEndStateChange will also be notified of this update
	    // immediately.
	    setEndValue: function(endValue) {
	      if (this._endValue == endValue && this.isAtRest())  {
	        return this;
	      }
	      this._startValue = this.getCurrentValue();
	      this._endValue = endValue;
	      this._springSystem.activateSpring(this.getId());
	      for (var i = 0, len = this.listeners.length; i < len; i++) {
	        var listener = this.listeners[i];
	        var onChange = listener.onSpringEndStateChange;
	        onChange && onChange(this);
	      }
	      return this;
	    },
	
	    // Retrieve the endValue or resting position of this spring.
	    getEndValue: function() {
	      return this._endValue;
	    },
	
	    // Set the current velocity of the Spring. As previously mentioned,
	    // this can be useful when you are performing a direct manipulation
	    // gesture. When a UI element is released you may call setVelocity
	    // on its animation Spring so that the Spring continues with the
	    // same velocity as the gesture ended with. The friction, tension,
	    // and displacement of the Spring will then govern its motion to
	    // return to rest on a natural feeling curve.
	    setVelocity: function(velocity) {
	      if (velocity === this._currentState.velocity) {
	        return this;
	      }
	      this._currentState.velocity = velocity;
	      this._springSystem.activateSpring(this.getId());
	      return this;
	    },
	
	    // Get the current velocity of the Spring.
	    getVelocity: function() {
	      return this._currentState.velocity;
	    },
	
	    // Set a threshold value for the movement speed of the Spring below
	    // which it will be considered to be not moving or resting.
	    setRestSpeedThreshold: function(restSpeedThreshold) {
	      this._restSpeedThreshold = restSpeedThreshold;
	      return this;
	    },
	
	    // Retrieve the rest speed threshold for this Spring.
	    getRestSpeedThreshold: function() {
	      return this._restSpeedThreshold;
	    },
	
	    // Set a threshold value for displacement below which the Spring
	    // will be considered to be not displaced i.e. at its resting
	    // `endValue`.
	    setRestDisplacementThreshold: function(displacementFromRestThreshold) {
	      this._displacementFromRestThreshold = displacementFromRestThreshold;
	    },
	
	    // Retrieve the rest displacement threshold for this spring.
	    getRestDisplacementThreshold: function() {
	      return this._displacementFromRestThreshold;
	    },
	
	    // Enable overshoot clamping. This means that the Spring will stop
	    // immediately when it reaches its resting position regardless of
	    // any existing momentum it may have. This can be useful for certain
	    // types of animations that should not oscillate such as a scale
	    // down to 0 or alpha fade.
	    setOvershootClampingEnabled: function(enabled) {
	      this._overshootClampingEnabled = enabled;
	      return this;
	    },
	
	    // Check if overshoot clamping is enabled for this spring.
	    isOvershootClampingEnabled: function() {
	      return this._overshootClampingEnabled;
	    },
	
	    // Check if the Spring has gone past its end point by comparing
	    // the direction it was moving in when it started to the current
	    // position and end value.
	    isOvershooting: function() {
	      var start = this._startValue;
	      var end = this._endValue;
	      return this._springConfig.tension > 0 &&
	       ((start < end && this.getCurrentValue() > end) ||
	       (start > end && this.getCurrentValue() < end));
	    },
	
	    // Spring.advance is the main solver method for the Spring. It takes
	    // the current time and delta since the last time step and performs
	    // an RK4 integration to get the new position and velocity state
	    // for the Spring based on the tension, friction, velocity, and
	    // displacement of the Spring.
	    advance: function(time, realDeltaTime) {
	      var isAtRest = this.isAtRest();
	
	      if (isAtRest && this._wasAtRest) {
	        return;
	      }
	
	      var adjustedDeltaTime = realDeltaTime;
	      if (realDeltaTime > Spring.MAX_DELTA_TIME_SEC) {
	        adjustedDeltaTime = Spring.MAX_DELTA_TIME_SEC;
	      }
	
	      this._timeAccumulator += adjustedDeltaTime;
	
	      var tension = this._springConfig.tension,
	          friction = this._springConfig.friction,
	
	          position = this._currentState.position,
	          velocity = this._currentState.velocity,
	          tempPosition = this._tempState.position,
	          tempVelocity = this._tempState.velocity,
	
	          aVelocity, aAcceleration,
	          bVelocity, bAcceleration,
	          cVelocity, cAcceleration,
	          dVelocity, dAcceleration,
	
	          dxdt, dvdt;
	
	      while(this._timeAccumulator >= Spring.SOLVER_TIMESTEP_SEC) {
	
	        this._timeAccumulator -= Spring.SOLVER_TIMESTEP_SEC;
	
	        if (this._timeAccumulator < Spring.SOLVER_TIMESTEP_SEC) {
	          this._previousState.position = position;
	          this._previousState.velocity = velocity;
	        }
	
	        aVelocity = velocity;
	        aAcceleration =
	          (tension * (this._endValue - tempPosition)) - friction * velocity;
	
	        tempPosition = position + aVelocity * Spring.SOLVER_TIMESTEP_SEC * 0.5;
	        tempVelocity =
	          velocity + aAcceleration * Spring.SOLVER_TIMESTEP_SEC * 0.5;
	        bVelocity = tempVelocity;
	        bAcceleration =
	          (tension * (this._endValue - tempPosition)) - friction * tempVelocity;
	
	        tempPosition = position + bVelocity * Spring.SOLVER_TIMESTEP_SEC * 0.5;
	        tempVelocity =
	          velocity + bAcceleration * Spring.SOLVER_TIMESTEP_SEC * 0.5;
	        cVelocity = tempVelocity;
	        cAcceleration =
	          (tension * (this._endValue - tempPosition)) - friction * tempVelocity;
	
	        tempPosition = position + cVelocity * Spring.SOLVER_TIMESTEP_SEC * 0.5;
	        tempVelocity =
	          velocity + cAcceleration * Spring.SOLVER_TIMESTEP_SEC * 0.5;
	        dVelocity = tempVelocity;
	        dAcceleration =
	          (tension * (this._endValue - tempPosition)) - friction * tempVelocity;
	
	        dxdt =
	          1.0/6.0 * (aVelocity + 2.0 * (bVelocity + cVelocity) + dVelocity);
	        dvdt = 1.0/6.0 * (
	          aAcceleration + 2.0 * (bAcceleration + cAcceleration) + dAcceleration
	        );
	
	        position += dxdt * Spring.SOLVER_TIMESTEP_SEC;
	        velocity += dvdt * Spring.SOLVER_TIMESTEP_SEC;
	      }
	
	      this._tempState.position = tempPosition;
	      this._tempState.velocity = tempVelocity;
	
	      this._currentState.position = position;
	      this._currentState.velocity = velocity;
	
	      if (this._timeAccumulator > 0) {
	        this._interpolate(this._timeAccumulator / Spring.SOLVER_TIMESTEP_SEC);
	      }
	
	      if (this.isAtRest() ||
	          this._overshootClampingEnabled && this.isOvershooting()) {
	
	        if (this._springConfig.tension > 0) {
	          this._startValue = this._endValue;
	          this._currentState.position = this._endValue;
	        } else {
	          this._endValue = this._currentState.position;
	          this._startValue = this._endValue;
	        }
	        this.setVelocity(0);
	        isAtRest = true;
	      }
	
	      var notifyActivate = false;
	      if (this._wasAtRest) {
	        this._wasAtRest = false;
	        notifyActivate = true;
	      }
	
	      var notifyAtRest = false;
	      if (isAtRest) {
	        this._wasAtRest = true;
	        notifyAtRest = true;
	      }
	
	      this.notifyPositionUpdated(notifyActivate, notifyAtRest);
	    },
	
	    notifyPositionUpdated: function(notifyActivate, notifyAtRest) {
	      for (var i = 0, len = this.listeners.length; i < len; i++) {
	        var listener = this.listeners[i];
	        if (notifyActivate && listener.onSpringActivate) {
	          listener.onSpringActivate(this);
	        }
	
	        if (listener.onSpringUpdate) {
	          listener.onSpringUpdate(this);
	        }
	
	        if (notifyAtRest && listener.onSpringAtRest) {
	          listener.onSpringAtRest(this);
	        }
	      }
	    },
	
	
	    // Check if the SpringSystem should advance. Springs are advanced
	    // a final frame after they reach equilibrium to ensure that the
	    // currentValue is exactly the requested endValue regardless of the
	    // displacement threshold.
	    systemShouldAdvance: function() {
	      return !this.isAtRest() || !this.wasAtRest();
	    },
	
	    wasAtRest: function() {
	      return this._wasAtRest;
	    },
	
	    // Check if the Spring is atRest meaning that it's currentValue and
	    // endValue are the same and that it has no velocity. The previously
	    // described thresholds for speed and displacement define the bounds
	    // of this equivalence check. If the Spring has 0 tension, then it will
	    // be considered at rest whenever its absolute velocity drops below the
	    // restSpeedThreshold.
	    isAtRest: function() {
	      return Math.abs(this._currentState.velocity) < this._restSpeedThreshold &&
	        (this.getDisplacementDistanceForState(this._currentState) <=
	          this._displacementFromRestThreshold ||
	        this._springConfig.tension === 0);
	    },
	
	    // Force the spring to be at rest at its current position. As
	    // described in the documentation for setCurrentValue, this method
	    // makes it easy to do synchronous non-animated updates to ui
	    // elements that are attached to springs via SpringListeners.
	    setAtRest: function() {
	      this._endValue = this._currentState.position;
	      this._tempState.position = this._currentState.position;
	      this._currentState.velocity = 0;
	      return this;
	    },
	
	    _interpolate: function(alpha) {
	      this._currentState.position = this._currentState.position *
	        alpha + this._previousState.position * (1 - alpha);
	      this._currentState.velocity = this._currentState.velocity *
	        alpha + this._previousState.velocity * (1 - alpha);
	    },
	
	    getListeners: function() {
	      return this.listeners;
	    },
	
	    addListener: function(newListener) {
	      this.listeners.push(newListener);
	      return this;
	    },
	
	    removeListener: function(listenerToRemove) {
	      removeFirst(this.listeners, listenerToRemove);
	      return this;
	    },
	
	    removeAllListeners: function() {
	      this.listeners = [];
	      return this;
	    },
	
	    currentValueIsApproximately: function(value) {
	      return Math.abs(this.getCurrentValue() - value) <=
	        this.getRestDisplacementThreshold();
	    }
	
	  });
	
	  // PhysicsState
	  // ------------
	  // **PhysicsState** consists of a position and velocity. A Spring uses
	  // this internally to keep track of its current and prior position and
	  // velocity values.
	  var PhysicsState = function PhysicsState() {};
	
	  util.extend(PhysicsState.prototype, {
	    position: 0,
	    velocity: 0
	  });
	
	  // SpringConfig
	  // ------------
	  // **SpringConfig** maintains a set of tension and friction constants
	  // for a Spring. You can use fromOrigamiTensionAndFriction to convert
	  // values from the [Origami](http://facebook.github.io/origami/)
	  // design tool directly to Rebound spring constants.
	  var SpringConfig = rebound.SpringConfig =
	    function SpringConfig(tension, friction) {
	      this.tension = tension;
	      this.friction = friction;
	    };
	
	  // Loopers
	  // -------
	  // **AnimationLooper** plays each frame of the SpringSystem on animation
	  // timing loop. This is the default type of looper for a new spring system
	  // as it is the most common when developing UI.
	  var AnimationLooper = rebound.AnimationLooper = function AnimationLooper() {
	    this.springSystem = null;
	    var _this = this;
	    var _run = function() {
	      _this.springSystem.loop(Date.now());
	    };
	
	    this.run = function() {
	      util.onFrame(_run);
	    };
	  };
	
	  // **SimulationLooper** resolves the SpringSystem to a resting state in a
	  // tight and blocking loop. This is useful for synchronously generating
	  // pre-recorded animations that can then be played on a timing loop later.
	  // Sometimes this lead to better performance to pre-record a single spring
	  // curve and use it to drive many animations; however, it can make dynamic
	  // response to user input a bit trickier to implement.
	  rebound.SimulationLooper = function SimulationLooper(timestep) {
	    this.springSystem = null;
	    var time = 0;
	    var running = false;
	    timestep=timestep || 16.667;
	
	    this.run = function() {
	      if (running) {
	        return;
	      }
	      running = true;
	      while(!this.springSystem.getIsIdle()) {
	        this.springSystem.loop(time+=timestep);
	      }
	      running = false;
	    };
	  };
	
	  // **SteppingSimulationLooper** resolves the SpringSystem one step at a
	  // time controlled by an outside loop. This is useful for testing and
	  // verifying the behavior of a SpringSystem or if you want to control your own
	  // timing loop for some reason e.g. slowing down or speeding up the
	  // simulation.
	  rebound.SteppingSimulationLooper = function(timestep) {
	    this.springSystem = null;
	    var time = 0;
	
	    // this.run is NOOP'd here to allow control from the outside using
	    // this.step.
	    this.run = function(){};
	
	    // Perform one step toward resolving the SpringSystem.
	    this.step = function(timestep) {
	      this.springSystem.loop(time+=timestep);
	    };
	  };
	
	  // Math for converting from
	  // [Origami](http://facebook.github.io/origami/) to
	  // [Rebound](http://facebook.github.io/rebound).
	  // You mostly don't need to worry about this, just use
	  // SpringConfig.fromOrigamiTensionAndFriction(v, v);
	  var OrigamiValueConverter = rebound.OrigamiValueConverter = {
	    tensionFromOrigamiValue: function(oValue) {
	      return (oValue - 30.0) * 3.62 + 194.0;
	    },
	
	    origamiValueFromTension: function(tension) {
	      return (tension - 194.0) / 3.62 + 30.0;
	    },
	
	    frictionFromOrigamiValue: function(oValue) {
	      return (oValue - 8.0) * 3.0 + 25.0;
	    },
	
	    origamiFromFriction: function(friction) {
	      return (friction - 25.0) / 3.0 + 8.0;
	    }
	  };
	
	  // BouncyConversion provides math for converting from Origami PopAnimation
	  // config values to regular Origami tension and friction values. If you are
	  // trying to replicate prototypes made with PopAnimation patches in Origami,
	  // then you should create your springs with
	  // SpringSystem.createSpringWithBouncinessAndSpeed, which uses this Math
	  // internally to create a spring to match the provided PopAnimation
	  // configuration from Origami.
	  var BouncyConversion = rebound.BouncyConversion = function(bounciness, speed){
	    this.bounciness = bounciness;
	    this.speed = speed;
	    var b = this.normalize(bounciness / 1.7, 0, 20.0);
	    b = this.projectNormal(b, 0.0, 0.8);
	    var s = this.normalize(speed / 1.7, 0, 20.0);
	    this.bouncyTension = this.projectNormal(s, 0.5, 200)
	    this.bouncyFriction = this.quadraticOutInterpolation(
	      b,
	      this.b3Nobounce(this.bouncyTension),
	      0.01);
	  }
	
	  util.extend(BouncyConversion.prototype, {
	
	    normalize: function(value, startValue, endValue) {
	      return (value - startValue) / (endValue - startValue);
	    },
	
	    projectNormal: function(n, start, end) {
	      return start + (n * (end - start));
	    },
	
	    linearInterpolation: function(t, start, end) {
	      return t * end + (1.0 - t) * start;
	    },
	
	    quadraticOutInterpolation: function(t, start, end) {
	      return this.linearInterpolation(2*t - t*t, start, end);
	    },
	
	    b3Friction1: function(x) {
	      return (0.0007 * Math.pow(x, 3)) -
	        (0.031 * Math.pow(x, 2)) + 0.64 * x + 1.28;
	    },
	
	    b3Friction2: function(x) {
	      return (0.000044 * Math.pow(x, 3)) -
	        (0.006 * Math.pow(x, 2)) + 0.36 * x + 2.;
	    },
	
	    b3Friction3: function(x) {
	      return (0.00000045 * Math.pow(x, 3)) -
	        (0.000332 * Math.pow(x, 2)) + 0.1078 * x + 5.84;
	    },
	
	    b3Nobounce: function(tension) {
	      var friction = 0;
	      if (tension <= 18) {
	        friction = this.b3Friction1(tension);
	      } else if (tension > 18 && tension <= 44) {
	        friction = this.b3Friction2(tension);
	      } else {
	        friction = this.b3Friction3(tension);
	      }
	      return friction;
	    }
	  });
	
	  util.extend(SpringConfig, {
	    // Convert an origami Spring tension and friction to Rebound spring
	    // constants. If you are prototyping a design with Origami, this
	    // makes it easy to make your springs behave exactly the same in
	    // Rebound.
	    fromOrigamiTensionAndFriction: function(tension, friction) {
	      return new SpringConfig(
	        OrigamiValueConverter.tensionFromOrigamiValue(tension),
	        OrigamiValueConverter.frictionFromOrigamiValue(friction));
	    },
	
	    // Convert an origami PopAnimation Spring bounciness and speed to Rebound
	    // spring constants. If you are using PopAnimation patches in Origami, this
	    // utility will provide springs that match your prototype.
	    fromBouncinessAndSpeed: function(bounciness, speed) {
	      var bouncyConversion = new rebound.BouncyConversion(bounciness, speed);
	      return this.fromOrigamiTensionAndFriction(
	        bouncyConversion.bouncyTension,
	        bouncyConversion.bouncyFriction);
	    },
	
	    // Create a SpringConfig with no tension or a coasting spring with some
	    // amount of Friction so that it does not coast infininitely.
	    coastingConfigWithOrigamiFriction: function(friction) {
	      return new SpringConfig(
	        0,
	        OrigamiValueConverter.frictionFromOrigamiValue(friction)
	      );
	    }
	  });
	
	  SpringConfig.DEFAULT_ORIGAMI_SPRING_CONFIG =
	    SpringConfig.fromOrigamiTensionAndFriction(40, 7);
	
	  util.extend(SpringConfig.prototype, {friction: 0, tension: 0});
	
	  // Here are a couple of function to convert colors between hex codes and RGB
	  // component values. These are handy when performing color
	  // tweening animations.
	  var colorCache = {};
	  util.hexToRGB = function(color) {
	    if (colorCache[color]) {
	      return colorCache[color];
	    }
	    color = color.replace('#', '');
	    if (color.length === 3) {
	      color = color[0] + color[0] + color[1] + color[1] + color[2] + color[2];
	    }
	    var parts = color.match(/.{2}/g);
	
	    var ret = {
	      r: parseInt(parts[0], 16),
	      g: parseInt(parts[1], 16),
	      b: parseInt(parts[2], 16)
	    };
	
	    colorCache[color] = ret;
	    return ret;
	  };
	
	  util.rgbToHex = function(r, g, b) {
	    r = r.toString(16);
	    g = g.toString(16);
	    b = b.toString(16);
	    r = r.length < 2 ? '0' + r : r;
	    g = g.length < 2 ? '0' + g : g;
	    b = b.length < 2 ? '0' + b : b;
	    return '#' + r + g + b;
	  };
	
	  var MathUtil = rebound.MathUtil = {
	    // This helper function does a linear interpolation of a value from
	    // one range to another. This can be very useful for converting the
	    // motion of a Spring to a range of UI property values. For example a
	    // spring moving from position 0 to 1 could be interpolated to move a
	    // view from pixel 300 to 350 and scale it from 0.5 to 1. The current
	    // position of the `Spring` just needs to be run through this method
	    // taking its input range in the _from_ parameters with the property
	    // animation range in the _to_ parameters.
	    mapValueInRange: function(value, fromLow, fromHigh, toLow, toHigh) {
	      var fromRangeSize = fromHigh - fromLow;
	      var toRangeSize = toHigh - toLow;
	      var valueScale = (value - fromLow) / fromRangeSize;
	      return toLow + (valueScale * toRangeSize);
	    },
	
	    // Interpolate two hex colors in a 0 - 1 range or optionally provide a
	    // custom range with fromLow,fromHight. The output will be in hex by default
	    // unless asRGB is true in which case it will be returned as an rgb string.
	    interpolateColor:
	      function(val, startColor, endColor, fromLow, fromHigh, asRGB) {
	      fromLow = fromLow === undefined ? 0 : fromLow;
	      fromHigh = fromHigh === undefined ? 1 : fromHigh;
	      startColor = util.hexToRGB(startColor);
	      endColor = util.hexToRGB(endColor);
	      var r = Math.floor(
	        util.mapValueInRange(val, fromLow, fromHigh, startColor.r, endColor.r)
	      );
	      var g = Math.floor(
	        util.mapValueInRange(val, fromLow, fromHigh, startColor.g, endColor.g)
	      );
	      var b = Math.floor(
	        util.mapValueInRange(val, fromLow, fromHigh, startColor.b, endColor.b)
	      );
	      if (asRGB) {
	        return 'rgb(' + r + ',' + g + ',' + b + ')';
	      } else {
	        return util.rgbToHex(r, g, b);
	      }
	    },
	
	    degreesToRadians: function(deg) {
	      return (deg * Math.PI) / 180;
	    },
	
	    radiansToDegrees: function(rad) {
	      return (rad * 180) / Math.PI;
	    }
	
	  }
	
	  util.extend(util, MathUtil);
	
	
	  // Utilities
	  // ---------
	  // Here are a few useful JavaScript utilities.
	
	  // Lop off the first occurence of the reference in the Array.
	  function removeFirst(array, item) {
	    var idx = array.indexOf(item);
	    idx != -1 && array.splice(idx, 1);
	  }
	
	  var _onFrame;
	  if (typeof window !== 'undefined') {
	    _onFrame = window.requestAnimationFrame ||
	      window.webkitRequestAnimationFrame ||
	      window.mozRequestAnimationFrame ||
	      window.msRequestAnimationFrame ||
	      window.oRequestAnimationFrame ||
	      function(callback) {
	        window.setTimeout(callback, 1000 / 60);
	      };
	  }
	  if (!_onFrame && typeof process !== 'undefined' && process.title === 'node') {
	    _onFrame = setImmediate;
	  }
	
	  // Cross browser/node timer functions.
	  util.onFrame = function onFrame(func) {
	    return _onFrame(func);
	  };
	
	  // Export the public api using exports for common js or the window for
	  // normal browser inclusion.
	  if (true) {
	    util.extend(exports, rebound);
	  } else if (typeof window != 'undefined') {
	    window.rebound = rebound;
	  }
	})();
	
	
	// Legal Stuff
	// -----------
	/**
	 *  Copyright (c) 2013, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(287), __webpack_require__(288).setImmediate))

/***/ },
/* 287 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(287).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
	
	  immediateIds[id] = true;
	
	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });
	
	  return id;
	};
	
	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(288).setImmediate, __webpack_require__(288).clearImmediate))

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(290);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _invariant = __webpack_require__(291);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Actions = __webpack_require__(292);
	
	var _ExecutionEnvironment = __webpack_require__(293);
	
	var _DOMUtils = __webpack_require__(294);
	
	var _DOMStateStorage = __webpack_require__(295);
	
	var _createDOMHistory = __webpack_require__(296);
	
	var _createDOMHistory2 = _interopRequireDefault(_createDOMHistory);
	
	function isAbsolutePath(path) {
	  return typeof path === 'string' && path.charAt(0) === '/';
	}
	
	function ensureSlash() {
	  var path = _DOMUtils.getHashPath();
	
	  if (isAbsolutePath(path)) return true;
	
	  _DOMUtils.replaceHashPath('/' + path);
	
	  return false;
	}
	
	function addQueryStringValueToPath(path, key, value) {
	  return path + (path.indexOf('?') === -1 ? '?' : '&') + (key + '=' + value);
	}
	
	function stripQueryStringValueFromPath(path, key) {
	  return path.replace(new RegExp('[?&]?' + key + '=[a-zA-Z0-9]+'), '');
	}
	
	function getQueryStringValueFromPath(path, key) {
	  var match = path.match(new RegExp('\\?.*?\\b' + key + '=(.+?)\\b'));
	  return match && match[1];
	}
	
	var DefaultQueryKey = '_k';
	
	function createHashHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  _invariant2['default'](_ExecutionEnvironment.canUseDOM, 'Hash history needs a DOM');
	
	  var queryKey = options.queryKey;
	
	  if (queryKey === undefined || !!queryKey) queryKey = typeof queryKey === 'string' ? queryKey : DefaultQueryKey;
	
	  function getCurrentLocation() {
	    var path = _DOMUtils.getHashPath();
	
	    var key = undefined,
	        state = undefined;
	    if (queryKey) {
	      key = getQueryStringValueFromPath(path, queryKey);
	      path = stripQueryStringValueFromPath(path, queryKey);
	
	      if (key) {
	        state = _DOMStateStorage.readState(key);
	      } else {
	        state = null;
	        key = history.createKey();
	        _DOMUtils.replaceHashPath(addQueryStringValueToPath(path, queryKey, key));
	      }
	    } else {
	      key = state = null;
	    }
	
	    return history.createLocation(path, state, undefined, key);
	  }
	
	  function startHashChangeListener(_ref) {
	    var transitionTo = _ref.transitionTo;
	
	    function hashChangeListener() {
	      if (!ensureSlash()) return; // Always make sure hashes are preceeded with a /.
	
	      transitionTo(getCurrentLocation());
	    }
	
	    ensureSlash();
	    _DOMUtils.addEventListener(window, 'hashchange', hashChangeListener);
	
	    return function () {
	      _DOMUtils.removeEventListener(window, 'hashchange', hashChangeListener);
	    };
	  }
	
	  function finishTransition(location) {
	    var basename = location.basename;
	    var pathname = location.pathname;
	    var search = location.search;
	    var state = location.state;
	    var action = location.action;
	    var key = location.key;
	
	    if (action === _Actions.POP) return; // Nothing to do.
	
	    var path = (basename || '') + pathname + search;
	
	    if (queryKey) path = addQueryStringValueToPath(path, queryKey, key);
	
	    if (path === _DOMUtils.getHashPath()) {
	      _warning2['default'](false, 'You cannot %s the same path using hash history', action);
	    } else {
	      if (queryKey) {
	        _DOMStateStorage.saveState(key, state);
	      } else {
	        // Drop key and state.
	        location.key = location.state = null;
	      }
	
	      if (action === _Actions.PUSH) {
	        window.location.hash = path;
	      } else {
	        // REPLACE
	        _DOMUtils.replaceHashPath(path);
	      }
	    }
	  }
	
	  var history = _createDOMHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: _DOMStateStorage.saveState
	  }));
	
	  var listenerCount = 0,
	      stopHashChangeListener = undefined;
	
	  function listenBefore(listener) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    var unlisten = history.listenBefore(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopHashChangeListener();
	    };
	  }
	
	  function listen(listener) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    var unlisten = history.listen(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopHashChangeListener();
	    };
	  }
	
	  function pushState(state, path) {
	    _warning2['default'](queryKey || state == null, 'You cannot use state without a queryKey it will be dropped');
	
	    history.pushState(state, path);
	  }
	
	  function replaceState(state, path) {
	    _warning2['default'](queryKey || state == null, 'You cannot use state without a queryKey it will be dropped');
	
	    history.replaceState(state, path);
	  }
	
	  var goIsSupportedWithoutReload = _DOMUtils.supportsGoWithoutReloadUsingHash();
	
	  function go(n) {
	    _warning2['default'](goIsSupportedWithoutReload, 'Hash history go(n) causes a full page reload in this browser');
	
	    history.go(n);
	  }
	
	  function createHref(path) {
	    return '#' + history.createHref(path);
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    history.registerTransitionHook(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    history.unregisterTransitionHook(hook);
	
	    if (--listenerCount === 0) stopHashChangeListener();
	  }
	
	  return _extends({}, history, {
	    listenBefore: listenBefore,
	    listen: listen,
	    pushState: pushState,
	    replaceState: replaceState,
	    go: go,
	    createHref: createHref,
	    registerTransitionHook: registerTransitionHook,
	    unregisterTransitionHook: unregisterTransitionHook
	  });
	}
	
	exports['default'] = createHashHistory;
	module.exports = exports['default'];

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = function() {};
	
	if (false) {
	  warning = function(condition, format, args) {
	    var len = arguments.length;
	    args = new Array(len > 2 ? len - 2 : 0);
	    for (var key = 2; key < len; key++) {
	      args[key - 2] = arguments[key];
	    }
	    if (format === undefined) {
	      throw new Error(
	        '`warning(condition, format, ...args)` requires a warning ' +
	        'message argument'
	      );
	    }
	
	    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
	      throw new Error(
	        'The warning format should be able to uniquely identify this ' +
	        'warning. Please, use a more descriptive format than: ' + format
	      );
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' +
	        format.replace(/%s/g, function() {
	          return args[argIndex++];
	        });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch(x) {}
	    }
	  };
	}
	
	module.exports = warning;


/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var invariant = function(condition, format, a, b, c, d, e, f) {
	  if (false) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error(
	        'Minified exception occurred; use the non-minified dev environment ' +
	        'for the full error message and additional helpful warnings.'
	      );
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(
	        format.replace(/%s/g, function() { return args[argIndex++]; })
	      );
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};
	
	module.exports = invariant;


/***/ },
/* 292 */
/***/ function(module, exports) {

	/**
	 * Indicates that navigation was caused by a call to history.push.
	 */
	'use strict';
	
	exports.__esModule = true;
	var PUSH = 'PUSH';
	
	exports.PUSH = PUSH;
	/**
	 * Indicates that navigation was caused by a call to history.replace.
	 */
	var REPLACE = 'REPLACE';
	
	exports.REPLACE = REPLACE;
	/**
	 * Indicates that navigation was caused by some other action such
	 * as using a browser's back/forward buttons and/or manually manipulating
	 * the URL in a browser's location bar. This is the default.
	 *
	 * See https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate
	 * for more information.
	 */
	var POP = 'POP';
	
	exports.POP = POP;
	exports['default'] = {
	  PUSH: PUSH,
	  REPLACE: REPLACE,
	  POP: POP
	};

/***/ },
/* 293 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	exports.canUseDOM = canUseDOM;

/***/ },
/* 294 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports.addEventListener = addEventListener;
	exports.removeEventListener = removeEventListener;
	exports.getHashPath = getHashPath;
	exports.replaceHashPath = replaceHashPath;
	exports.getWindowPath = getWindowPath;
	exports.go = go;
	exports.getUserConfirmation = getUserConfirmation;
	exports.supportsHistory = supportsHistory;
	exports.supportsGoWithoutReloadUsingHash = supportsGoWithoutReloadUsingHash;
	
	function addEventListener(node, event, listener) {
	  if (node.addEventListener) {
	    node.addEventListener(event, listener, false);
	  } else {
	    node.attachEvent('on' + event, listener);
	  }
	}
	
	function removeEventListener(node, event, listener) {
	  if (node.removeEventListener) {
	    node.removeEventListener(event, listener, false);
	  } else {
	    node.detachEvent('on' + event, listener);
	  }
	}
	
	function getHashPath() {
	  // We can't use window.location.hash here because it's not
	  // consistent across browsers - Firefox will pre-decode it!
	  return window.location.href.split('#')[1] || '';
	}
	
	function replaceHashPath(path) {
	  window.location.replace(window.location.pathname + window.location.search + '#' + path);
	}
	
	function getWindowPath() {
	  return window.location.pathname + window.location.search + window.location.hash;
	}
	
	function go(n) {
	  if (n) window.history.go(n);
	}
	
	function getUserConfirmation(message, callback) {
	  callback(window.confirm(message));
	}
	
	/**
	 * Returns true if the HTML5 history API is supported. Taken from modernizr.
	 *
	 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
	 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
	 * changed to avoid false negatives for Windows Phones: https://github.com/rackt/react-router/issues/586
	 */
	
	function supportsHistory() {
	  var ua = navigator.userAgent;
	  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
	    return false;
	  }
	  return window.history && 'pushState' in window.history;
	}
	
	/**
	 * Returns false if using go(n) with hash history causes a full page reload.
	 */
	
	function supportsGoWithoutReloadUsingHash() {
	  var ua = navigator.userAgent;
	  return ua.indexOf('Firefox') === -1;
	}

/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	/*eslint-disable no-empty */
	'use strict';
	
	exports.__esModule = true;
	exports.saveState = saveState;
	exports.readState = readState;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(290);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var KeyPrefix = '@@History/';
	var QuotaExceededError = 'QuotaExceededError';
	
	function createKey(key) {
	  return KeyPrefix + key;
	}
	
	function saveState(key, state) {
	  try {
	    window.sessionStorage.setItem(createKey(key), JSON.stringify(state));
	  } catch (error) {
	    if (error.name === QuotaExceededError || window.sessionStorage.length === 0) {
	      // Probably in Safari "private mode" where sessionStorage quota is 0. #42
	      _warning2['default'](false, '[history] Unable to save state; sessionStorage is not available in Safari private mode');
	
	      return;
	    }
	
	    throw error;
	  }
	}
	
	function readState(key) {
	  var json = window.sessionStorage.getItem(createKey(key));
	
	  if (json) {
	    try {
	      return JSON.parse(json);
	    } catch (error) {
	      // Ignore invalid JSON.
	    }
	  }
	
	  return null;
	}

/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _invariant = __webpack_require__(291);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _ExecutionEnvironment = __webpack_require__(293);
	
	var _DOMUtils = __webpack_require__(294);
	
	var _createHistory = __webpack_require__(297);
	
	var _createHistory2 = _interopRequireDefault(_createHistory);
	
	function createDOMHistory(options) {
	  var history = _createHistory2['default'](_extends({
	    getUserConfirmation: _DOMUtils.getUserConfirmation
	  }, options, {
	    go: _DOMUtils.go
	  }));
	
	  function listen(listener) {
	    _invariant2['default'](_ExecutionEnvironment.canUseDOM, 'DOM history needs a DOM');
	
	    return history.listen(listener);
	  }
	
	  return _extends({}, history, {
	    listen: listen
	  });
	}
	
	exports['default'] = createDOMHistory;
	module.exports = exports['default'];

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _deepEqual = __webpack_require__(298);
	
	var _deepEqual2 = _interopRequireDefault(_deepEqual);
	
	var _AsyncUtils = __webpack_require__(301);
	
	var _Actions = __webpack_require__(292);
	
	var _createLocation2 = __webpack_require__(302);
	
	var _createLocation3 = _interopRequireDefault(_createLocation2);
	
	var _runTransitionHook = __webpack_require__(304);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _deprecate = __webpack_require__(305);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	function createRandomKey(length) {
	  return Math.random().toString(36).substr(2, length);
	}
	
	function locationsAreEqual(a, b) {
	  return a.pathname === b.pathname && a.search === b.search &&
	  //a.action === b.action && // Different action !== location change.
	  a.key === b.key && _deepEqual2['default'](a.state, b.state);
	}
	
	var DefaultKeyLength = 6;
	
	function createHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	  var getCurrentLocation = options.getCurrentLocation;
	  var finishTransition = options.finishTransition;
	  var saveState = options.saveState;
	  var go = options.go;
	  var keyLength = options.keyLength;
	  var getUserConfirmation = options.getUserConfirmation;
	
	  if (typeof keyLength !== 'number') keyLength = DefaultKeyLength;
	
	  var transitionHooks = [];
	
	  function listenBefore(hook) {
	    transitionHooks.push(hook);
	
	    return function () {
	      transitionHooks = transitionHooks.filter(function (item) {
	        return item !== hook;
	      });
	    };
	  }
	
	  var allKeys = [];
	  var changeListeners = [];
	  var location = undefined;
	
	  function getCurrent() {
	    if (pendingLocation && pendingLocation.action === _Actions.POP) {
	      return allKeys.indexOf(pendingLocation.key);
	    } else if (location) {
	      return allKeys.indexOf(location.key);
	    } else {
	      return -1;
	    }
	  }
	
	  function updateLocation(newLocation) {
	    var current = getCurrent();
	
	    location = newLocation;
	
	    if (location.action === _Actions.PUSH) {
	      allKeys = [].concat(allKeys.slice(0, current + 1), [location.key]);
	    } else if (location.action === _Actions.REPLACE) {
	      allKeys[current] = location.key;
	    }
	
	    changeListeners.forEach(function (listener) {
	      listener(location);
	    });
	  }
	
	  function listen(listener) {
	    changeListeners.push(listener);
	
	    if (location) {
	      listener(location);
	    } else {
	      var _location = getCurrentLocation();
	      allKeys = [_location.key];
	      updateLocation(_location);
	    }
	
	    return function () {
	      changeListeners = changeListeners.filter(function (item) {
	        return item !== listener;
	      });
	    };
	  }
	
	  function confirmTransitionTo(location, callback) {
	    _AsyncUtils.loopAsync(transitionHooks.length, function (index, next, done) {
	      _runTransitionHook2['default'](transitionHooks[index], location, function (result) {
	        if (result != null) {
	          done(result);
	        } else {
	          next();
	        }
	      });
	    }, function (message) {
	      if (getUserConfirmation && typeof message === 'string') {
	        getUserConfirmation(message, function (ok) {
	          callback(ok !== false);
	        });
	      } else {
	        callback(message !== false);
	      }
	    });
	  }
	
	  var pendingLocation = undefined;
	
	  function transitionTo(nextLocation) {
	    if (location && locationsAreEqual(location, nextLocation)) return; // Nothing to do.
	
	    pendingLocation = nextLocation;
	
	    confirmTransitionTo(nextLocation, function (ok) {
	      if (pendingLocation !== nextLocation) return; // Transition was interrupted.
	
	      if (ok) {
	        if (finishTransition(nextLocation) !== false) updateLocation(nextLocation);
	      } else if (location && nextLocation.action === _Actions.POP) {
	        var prevIndex = allKeys.indexOf(location.key);
	        var nextIndex = allKeys.indexOf(nextLocation.key);
	
	        if (prevIndex !== -1 && nextIndex !== -1) go(prevIndex - nextIndex); // Restore the URL.
	      }
	    });
	  }
	
	  function pushState(state, path) {
	    transitionTo(createLocation(path, state, _Actions.PUSH, createKey()));
	  }
	
	  function replaceState(state, path) {
	    transitionTo(createLocation(path, state, _Actions.REPLACE, createKey()));
	  }
	
	  function goBack() {
	    go(-1);
	  }
	
	  function goForward() {
	    go(1);
	  }
	
	  function createKey() {
	    return createRandomKey(keyLength);
	  }
	
	  function createPath(path) {
	    if (path == null || typeof path === 'string') return path;
	
	    var pathname = path.pathname;
	    var search = path.search;
	    var hash = path.hash;
	
	    var result = pathname;
	
	    if (search) result += search;
	
	    if (hash) result += hash;
	
	    return result;
	  }
	
	  function createHref(path) {
	    return createPath(path);
	  }
	
	  function createLocation(path, state, action) {
	    var key = arguments.length <= 3 || arguments[3] === undefined ? createKey() : arguments[3];
	
	    return _createLocation3['default'](path, state, action, key);
	  }
	
	  // deprecated
	  function setState(state) {
	    if (location) {
	      updateLocationState(location, state);
	      updateLocation(location);
	    } else {
	      updateLocationState(getCurrentLocation(), state);
	    }
	  }
	
	  function updateLocationState(location, state) {
	    location.state = _extends({}, location.state, state);
	    saveState(location.key, location.state);
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (transitionHooks.indexOf(hook) === -1) transitionHooks.push(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    transitionHooks = transitionHooks.filter(function (item) {
	      return item !== hook;
	    });
	  }
	
	  return {
	    listenBefore: listenBefore,
	    listen: listen,
	    transitionTo: transitionTo,
	    pushState: pushState,
	    replaceState: replaceState,
	    go: go,
	    goBack: goBack,
	    goForward: goForward,
	    createKey: createKey,
	    createPath: createPath,
	    createHref: createHref,
	    createLocation: createLocation,
	
	    setState: _deprecate2['default'](setState, 'setState is deprecated; use location.key to save state instead'),
	    registerTransitionHook: _deprecate2['default'](registerTransitionHook, 'registerTransitionHook is deprecated; use listenBefore instead'),
	    unregisterTransitionHook: _deprecate2['default'](unregisterTransitionHook, 'unregisterTransitionHook is deprecated; use the callback returned from listenBefore instead')
	  };
	}
	
	exports['default'] = createHistory;
	module.exports = exports['default'];

/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	var pSlice = Array.prototype.slice;
	var objectKeys = __webpack_require__(299);
	var isArguments = __webpack_require__(300);
	
	var deepEqual = module.exports = function (actual, expected, opts) {
	  if (!opts) opts = {};
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	
	  } else if (actual instanceof Date && expected instanceof Date) {
	    return actual.getTime() === expected.getTime();
	
	  // 7.3. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
	    return opts.strict ? actual === expected : actual == expected;
	
	  // 7.4. For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected, opts);
	  }
	}
	
	function isUndefinedOrNull(value) {
	  return value === null || value === undefined;
	}
	
	function isBuffer (x) {
	  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
	  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
	    return false;
	  }
	  if (x.length > 0 && typeof x[0] !== 'number') return false;
	  return true;
	}
	
	function objEquiv(a, b, opts) {
	  var i, key;
	  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
	    return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  //~~~I've managed to break Object.keys through screwy arguments passing.
	  //   Converting to array solves the problem.
	  if (isArguments(a)) {
	    if (!isArguments(b)) {
	      return false;
	    }
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return deepEqual(a, b, opts);
	  }
	  if (isBuffer(a)) {
	    if (!isBuffer(b)) {
	      return false;
	    }
	    if (a.length !== b.length) return false;
	    for (i = 0; i < a.length; i++) {
	      if (a[i] !== b[i]) return false;
	    }
	    return true;
	  }
	  try {
	    var ka = objectKeys(a),
	        kb = objectKeys(b);
	  } catch (e) {//happens when one is a string literal and the other isn't
	    return false;
	  }
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!deepEqual(a[key], b[key], opts)) return false;
	  }
	  return typeof a === typeof b;
	}


/***/ },
/* 299 */
/***/ function(module, exports) {

	exports = module.exports = typeof Object.keys === 'function'
	  ? Object.keys : shim;
	
	exports.shim = shim;
	function shim (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}


/***/ },
/* 300 */
/***/ function(module, exports) {

	var supportsArgumentsClass = (function(){
	  return Object.prototype.toString.call(arguments)
	})() == '[object Arguments]';
	
	exports = module.exports = supportsArgumentsClass ? supported : unsupported;
	
	exports.supported = supported;
	function supported(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	};
	
	exports.unsupported = unsupported;
	function unsupported(object){
	  return object &&
	    typeof object == 'object' &&
	    typeof object.length == 'number' &&
	    Object.prototype.hasOwnProperty.call(object, 'callee') &&
	    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
	    false;
	};


/***/ },
/* 301 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports.loopAsync = loopAsync;
	
	function loopAsync(turns, work, callback) {
	  var currentTurn = 0;
	  var isDone = false;
	
	  function done() {
	    isDone = true;
	    callback.apply(this, arguments);
	  }
	
	  function next() {
	    if (isDone) return;
	
	    if (currentTurn < turns) {
	      work.call(this, currentTurn++, next, done);
	    } else {
	      done.apply(this, arguments);
	    }
	  }
	
	  next();
	}

/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _Actions = __webpack_require__(292);
	
	var _parsePath = __webpack_require__(303);
	
	var _parsePath2 = _interopRequireDefault(_parsePath);
	
	function createLocation() {
	  var path = arguments.length <= 0 || arguments[0] === undefined ? '/' : arguments[0];
	  var state = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	  var action = arguments.length <= 2 || arguments[2] === undefined ? _Actions.POP : arguments[2];
	  var key = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	
	  if (typeof path === 'string') path = _parsePath2['default'](path);
	
	  var pathname = path.pathname || '/';
	  var search = path.search || '';
	  var hash = path.hash || '';
	
	  return {
	    pathname: pathname,
	    search: search,
	    hash: hash,
	    state: state,
	    action: action,
	    key: key
	  };
	}
	
	exports['default'] = createLocation;
	module.exports = exports['default'];

/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(290);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function extractPath(string) {
	  var match = string.match(/^https?:\/\/[^\/]*/);
	
	  if (match == null) return string;
	
	  _warning2['default'](false, 'A path must be pathname + search + hash only, not a fully qualified URL like "%s"', string);
	
	  return string.substring(match[0].length);
	}
	
	function parsePath(path) {
	  var pathname = extractPath(path);
	  var search = '';
	  var hash = '';
	
	  var hashIndex = pathname.indexOf('#');
	  if (hashIndex !== -1) {
	    hash = pathname.substring(hashIndex);
	    pathname = pathname.substring(0, hashIndex);
	  }
	
	  var searchIndex = pathname.indexOf('?');
	  if (searchIndex !== -1) {
	    search = pathname.substring(searchIndex);
	    pathname = pathname.substring(0, searchIndex);
	  }
	
	  if (pathname === '') pathname = '/';
	
	  return {
	    pathname: pathname,
	    search: search,
	    hash: hash
	  };
	}
	
	exports['default'] = parsePath;
	module.exports = exports['default'];

/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(290);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function runTransitionHook(hook, location, callback) {
	  var result = hook(location, callback);
	
	  if (hook.length < 2) {
	    // Assume the hook runs synchronously and automatically
	    // call the callback with the return value.
	    callback(result);
	  } else {
	    _warning2['default'](result === undefined, 'You should not "return" in a transition hook with a callback argument; call the callback instead');
	  }
	}
	
	exports['default'] = runTransitionHook;
	module.exports = exports['default'];

/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(290);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function deprecate(fn, message) {
	  return function () {
	    _warning2['default'](false, '[history] ' + message);
	    return fn.apply(this, arguments);
	  };
	}
	
	exports['default'] = deprecate;
	module.exports = exports['default'];

/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * @providesModule ReactPicker
	 */
	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var PICKER = 'picker';
	
	var Picker = _react2['default'].createClass({
	  displayName: 'Picker',
	
	  propTypes: {
	    onValueChange: _react.PropTypes.func,
	    selectedValue: _react.PropTypes.any },
	
	  // string or integer basically
	  _onChange: function _onChange(event) {
	    // shim the native event
	    event.nativeEvent.newValue = this.refs[PICKER].value;
	
	    if (this.props.onChange) {
	      this.props.onChange(event);
	    }
	
	    if (this.props.onValueChange) {
	      this.props.onValueChange(event.nativeEvent.newValue);
	    }
	  },
	
	  render: function render() {
	    return _react2['default'].createElement(
	      'select',
	      {
	        ref: PICKER,
	        value: this.props.selectedValue,
	        style: _extends({
	          margin: 10,
	          color: 'inherit',
	          font: 'inherit'
	        }, this.props.style),
	        onChange: this._onChange
	      },
	      this.props.children
	    );
	  }
	});
	
	Picker.Item = _react2['default'].createClass({
	  displayName: 'Item',
	
	  propTypes: {
	    value: _react.PropTypes.any, // string or integer basically
	    label: _react.PropTypes.string
	  },
	
	  render: function render() {
	    return _react2['default'].createElement(
	      'option',
	      { value: this.props.value },
	      this.props.label
	    );
	  }
	});
	
	module.exports = Picker;

/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * @providesModule ReactProgressView
	 */
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _ReactView = __webpack_require__(164);
	
	var _ReactView2 = _interopRequireDefault(_ReactView);
	
	var _ReactStyleSheet = __webpack_require__(154);
	
	var _ReactStyleSheet2 = _interopRequireDefault(_ReactStyleSheet);
	
	var ProgressView = _react2['default'].createClass({
	  displayName: 'ProgressView',
	
	  render: function render() {
	
	    var specificStyle = {
	      progressTint: {},
	      progressTrack: {}
	    };
	
	    if (this.props.trackImage) {
	      specificStyle.progressTrack.background = 'url(' + this.props.trackImage.uri + ') no-repeat 0 0';
	      specificStyle.progressTrack.backgroundSize = '100% 100%';
	    }
	
	    if (this.props.trackTintColor) {
	      specificStyle.progressTrack.background = this.props.trackTintColor;
	    }
	
	    if (this.props.progressViewStyle == 'bar') {
	      specificStyle.progressTrack.background = 'transparent';
	    }
	
	    if (this.props.progressImage) {
	      specificStyle.progressTint.background = 'url(' + this.props.progressImage.uri + ') no-repeat 0 0';
	      specificStyle.progressTint.backgroundSize = '100% 100%';
	    }
	
	    if (this.props.progressTintColor) {
	      specificStyle.progressTint.background = this.props.progressTintColor;
	    }
	
	    // process progress
	    var progress = this.props.progress;
	    if (progress >= 1) {
	      progress = 1;
	    } else if (progress <= 0) {
	      progress = 0;
	    }
	
	    specificStyle.progressTint.width = 100 * progress + '%';
	
	    specificStyle = _ReactStyleSheet2['default'].create(specificStyle);
	
	    return _react2['default'].createElement(
	      _ReactView2['default'],
	      { style: [styles.progressView, this.props.style] },
	      _react2['default'].createElement(
	        _ReactView2['default'],
	        { style: [styles.progressTrack, specificStyle.progressTrack] },
	        _react2['default'].createElement(_ReactView2['default'], { style: [styles.progressTint, specificStyle.progressTint] })
	      )
	    );
	  }
	});
	
	var styles = _ReactStyleSheet2['default'].create({
	  progressView: {
	    display: 'block',
	    height: '2px',
	    width: '100%'
	  },
	  progressTint: {
	    position: 'absolute',
	    left: 0,
	    width: 0,
	    height: '100%',
	    background: '#0079fe'
	  },
	  progressTrack: {
	    position: 'relative',
	    width: '100%',
	    height: '100%',
	    background: '#b4b4b4'
	  }
	});
	
	module.exports = ProgressView;

/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015, Facebook, Inc.  All rights reserved.
	 *
	 * @providesModule ReactScrollView
	 */
	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(166);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _ReactScrollResponder = __webpack_require__(309);
	
	var _ReactScrollResponder2 = _interopRequireDefault(_ReactScrollResponder);
	
	var _ReactStyleSheet = __webpack_require__(154);
	
	var _ReactStyleSheet2 = _interopRequireDefault(_ReactStyleSheet);
	
	var _ReactView = __webpack_require__(164);
	
	var _ReactView2 = _interopRequireDefault(_ReactView);
	
	var _domkitThrottle = __webpack_require__(310);
	
	var _domkitThrottle2 = _interopRequireDefault(_domkitThrottle);
	
	var SCROLLVIEW = 'ScrollView';
	var INNERVIEW = 'InnerScrollView';
	
	/**
	 * Component that wraps platform ScrollView while providing
	 * integration with touch locking "responder" system.
	 *
	 * Keep in mind that ScrollViews must have a bounded height in order to work,
	 * since they contain unbounded-height children into a bounded container (via
	 * a scroll interaction). In order to bound the height of a ScrollView, either
	 * set the height of the view directly (discouraged) or make sure all parent
	 * views have bounded height. Forgetting to transfer `{flex: 1}` down the
	 * view stack can lead to errors here, which the element inspector makes
	 * easy to debug.
	 *
	 * Doesn't yet support other contained responders from blocking this scroll
	 * view from becoming the responder.
	 */
	var ScrollView = _react2['default'].createClass({
	  displayName: 'ScrollView',
	
	  propTypes: {
	    /**
	     * Controls whether iOS should automatically adjust the content inset
	     * for scroll views that are placed behind a navigation bar or
	     * tab bar/ toolbar. The default value is true.
	     * @platform ios
	     */
	    automaticallyAdjustContentInsets: _react.PropTypes.bool,
	    /**
	     * The amount by which the scroll view content is inset from the edges
	     * of the scroll view. Defaults to `{0, 0, 0, 0}`.
	     * @platform ios
	     */
	    // contentInset: EdgeInsetsPropType,
	    /**
	     * Used to manually set the starting scroll offset.
	     * The default value is `{x: 0, y: 0}`.
	     * @platform ios
	     */
	    // contentOffset: PointPropType,
	    /**
	     * When true, the scroll view bounces when it reaches the end of the
	     * content if the content is larger then the scroll view along the axis of
	     * the scroll direction. When false, it disables all bouncing even if
	     * the `alwaysBounce*` props are true. The default value is true.
	     * @platform ios
	     */
	    bounces: _react.PropTypes.bool,
	    /**
	     * When true, gestures can drive zoom past min/max and the zoom will animate
	     * to the min/max value at gesture end, otherwise the zoom will not exceed
	     * the limits.
	     * @platform ios
	     */
	    bouncesZoom: _react.PropTypes.bool,
	    /**
	     * When true, the scroll view bounces horizontally when it reaches the end
	     * even if the content is smaller than the scroll view itself. The default
	     * value is true when `horizontal={true}` and false otherwise.
	     * @platform ios
	     */
	    alwaysBounceHorizontal: _react.PropTypes.bool,
	    /**
	     * When true, the scroll view bounces vertically when it reaches the end
	     * even if the content is smaller than the scroll view itself. The default
	     * value is false when `horizontal={true}` and true otherwise.
	     * @platform ios
	     */
	    alwaysBounceVertical: _react.PropTypes.bool,
	    /**
	     * When true, the scroll view automatically centers the content when the
	     * content is smaller than the scroll view bounds; when the content is
	     * larger than the scroll view, this property has no effect. The default
	     * value is false.
	     * @platform ios
	     */
	    centerContent: _react.PropTypes.bool,
	    /**
	     * These styles will be applied to the scroll view content container which
	     * wraps all of the child views. Example:
	     *
	     *   return (
	     *     <ScrollView contentContainerStyle={styles.contentContainer}>
	     *     </ScrollView>
	     *   );
	     *   ...
	     *   var styles = StyleSheet.create({
	     *     contentContainer: {
	     *       paddingVertical: 20
	     *     }
	     *   });
	     */
	    // contentContainerStyle: StyleSheetPropType(ViewStylePropTypes),
	    /**
	     * A floating-point number that determines how quickly the scroll view
	     * decelerates after the user lifts their finger. Reasonable choices include
	     *   - Normal: 0.998 (the default)
	     *   - Fast: 0.9
	     * @platform ios
	     */
	    decelerationRate: _react.PropTypes.number,
	    /**
	     * When true, the scroll view's children are arranged horizontally in a row
	     * instead of vertically in a column. The default value is false.
	     */
	    horizontal: _react.PropTypes.bool,
	    /**
	     * When true, the ScrollView will try to lock to only vertical or horizontal
	     * scrolling while dragging.  The default value is false.
	     * @platform ios
	     */
	    directionalLockEnabled: _react.PropTypes.bool,
	    /**
	     * When false, once tracking starts, won't try to drag if the touch moves.
	     * The default value is true.
	     * @platform ios
	     */
	    canCancelContentTouches: _react.PropTypes.bool,
	    /**
	     * Determines whether the keyboard gets dismissed in response to a drag.
	     *   - 'none' (the default), drags do not dismiss the keyboard.
	     *   - 'on-drag', the keyboard is dismissed when a drag begins.
	     *   - 'interactive', the keyboard is dismissed interactively with the drag and moves in
	     *     synchrony with the touch; dragging upwards cancels the dismissal.
	     *     On android this is not supported and it will have the same behavior as 'none'.
	     */
	    keyboardDismissMode: _react.PropTypes.oneOf(['none', // default
	    'interactive', 'on-drag']),
	    /**
	     * When false, tapping outside of the focused text input when the keyboard
	     * is up dismisses the keyboard. When true, the scroll view will not catch
	     * taps, and the keyboard will not dismiss automatically. The default value
	     * is false.
	     */
	    keyboardShouldPersistTaps: _react.PropTypes.bool,
	    /**
	     * The maximum allowed zoom scale. The default value is 1.0.
	     * @platform ios
	     */
	    maximumZoomScale: _react.PropTypes.number,
	    /**
	     * The minimum allowed zoom scale. The default value is 1.0.
	     * @platform ios
	     */
	    minimumZoomScale: _react.PropTypes.number,
	    /**
	     * Fires at most once per frame during scrolling. The frequency of the
	     * events can be contolled using the `scrollEventThrottle` prop.
	     */
	    onScroll: _react.PropTypes.func,
	    /**
	     * Called when a scrolling animation ends.
	     * @platform ios
	     */
	    onScrollAnimationEnd: _react.PropTypes.func,
	    /**
	     * When true, the scroll view stops on multiples of the scroll view's size
	     * when scrolling. This can be used for horizontal pagination. The default
	     * value is false.
	     * @platform ios
	     */
	    pagingEnabled: _react.PropTypes.bool,
	    /**
	     * When false, the content does not scroll.
	     * The default value is true.
	     * @platform ios
	     */
	    scrollEnabled: _react.PropTypes.bool,
	    /**
	     * This controls how often the scroll event will be fired while scrolling
	     * (in events per seconds). A higher number yields better accuracy for code
	     * that is tracking the scroll position, but can lead to scroll performance
	     * problems due to the volume of information being send over the bridge.
	     * The default value is zero, which means the scroll event will be sent
	     * only once each time the view is scrolled.
	     * @platform ios
	     */
	    scrollEventThrottle: _react.PropTypes.number,
	    /**
	     * The amount by which the scroll view indicators are inset from the edges
	     * of the scroll view. This should normally be set to the same value as
	     * the `contentInset`. Defaults to `{0, 0, 0, 0}`.
	     * @platform ios
	     */
	    // scrollIndicatorInsets: EdgeInsetsPropType,
	    /**
	     * When true, the scroll view scrolls to top when the status bar is tapped.
	     * The default value is true.
	     * @platform ios
	     */
	    scrollsToTop: _react.PropTypes.bool,
	    /**
	     * When true, shows a horizontal scroll indicator.
	     */
	    showsHorizontalScrollIndicator: _react.PropTypes.bool,
	    /**
	     * When true, shows a vertical scroll indicator.
	     */
	    showsVerticalScrollIndicator: _react.PropTypes.bool,
	    /**
	     * An array of child indices determining which children get docked to the
	     * top of the screen when scrolling. For example, passing
	     * `stickyHeaderIndices={[0]}` will cause the first child to be fixed to the
	     * top of the scroll view. This property is not supported in conjunction
	     * with `horizontal={true}`.
	     * @platform ios
	     */
	    stickyHeaderIndices: _react.PropTypes.arrayOf(_react.PropTypes.number),
	    // style: StyleSheetPropType(ViewStylePropTypes),
	    /**
	     * When set, causes the scroll view to stop at multiples of the value of
	     * `snapToInterval`. This can be used for paginating through children
	     * that have lengths smaller than the scroll view. Used in combination
	     * with `snapToAlignment`.
	     * @platform ios
	     */
	    snapToInterval: _react.PropTypes.number,
	    /**
	     * When `snapToInterval` is set, `snapToAlignment` will define the relationship
	     * of the the snapping to the scroll view.
	     *   - `start` (the default) will align the snap at the left (horizontal) or top (vertical)
	     *   - `center` will align the snap in the center
	     *   - `end` will align the snap at the right (horizontal) or bottom (vertical)
	     * @platform ios
	     */
	    snapToAlignment: _react.PropTypes.oneOf(['start', // default
	    'center', 'end']),
	    /**
	     * Experimental: When true, offscreen child views (whose `overflow` value is
	     * `hidden`) are removed from their native backing superview when offscreen.
	     * This can improve scrolling performance on long lists. The default value is
	     * false.
	     */
	    removeClippedSubviews: _react.PropTypes.bool,
	    /**
	     * The current scale of the scroll view content. The default value is 1.0.
	     * @platform ios
	     */
	    zoomScale: _react.PropTypes.number
	  },
	
	  mixins: [_ReactScrollResponder2['default'].Mixin],
	
	  getInitialState: function getInitialState() {
	    return this.scrollResponderMixinGetInitialState();
	  },
	
	  /**
	   * Returns a reference to the underlying scroll responder, which supports
	   * operations like `scrollTo`. All ScrollView-like components should
	   * implement this method so that they can be composed while providing access
	   * to the underlying scroll responder's methods.
	   */
	  getScrollResponder: function getScrollResponder() {
	    return this;
	  },
	
	  getInnerViewNode: function getInnerViewNode() {
	    return this.refs[INNERVIEW];
	  },
	
	  scrollTo: function scrollTo(destY, destX) {
	    // $FlowFixMe - Don't know how to pass Mixin correctly. Postpone for now
	    // this.getScrollResponder().scrollResponderScrollTo(destX || 0, destY || 0);
	    this.scrollWithoutAnimationTo(destY, destX);
	  },
	
	  scrollWithoutAnimationTo: function scrollWithoutAnimationTo(destY, destX) {
	    // $FlowFixMe - Don't know how to pass Mixin correctly. Postpone for now
	    // this.getScrollResponder().scrollResponderScrollWithouthAnimationTo(
	    //   destX || 0,
	    //   destY || 0,
	    // );
	
	    var scrollView = _reactDom2['default'].findDOMNode(this.refs[SCROLLVIEW]);
	    scrollView.scrollTop = destY || 0;
	    scrollView.scrollLeft = destX || 0;
	  },
	
	  handleScroll: function handleScroll(e) {
	    // if (__DEV__) {
	    //   if (this.props.onScroll && !this.props.scrollEventThrottle) {
	    //     console.log(
	    //       'You specified `onScroll` on a <ScrollView> but not ' +
	    //       '`scrollEventThrottle`. You will only receive one event. ' +
	    //       'Using `16` you get all the events but be aware that it may ' +
	    //       'cause frame drops, use a bigger number if you don\'t need as ' +
	    //       'much precision.'
	    //     );
	    //   }
	    // }
	    // if (Platform.OS === 'android') {
	    //   if (this.props.keyboardDismissMode === 'on-drag') {
	    //     dismissKeyboard();
	    //   }
	    // }
	
	    this.props.onScroll && this.props.onScroll(e);
	  },
	
	  render: function render() {
	    var contentContainerStyle = [styles.contentContainer, this.props.horizontal && styles.contentContainerHorizontal, this.props.contentContainerStyle];
	    // if (__DEV__ && this.props.style) {
	    //   var style = flattenStyle(this.props.style);
	    //   var childLayoutProps = ['alignItems', 'justifyContent']
	    //     .filter((prop) => style && style[prop] !== undefined);
	    //   invariant(
	    //     childLayoutProps.length === 0,
	    //     'ScrollView child layout (' + JSON.stringify(childLayoutProps) +
	    //       ') must by applied through the contentContainerStyle prop.'
	    //   );
	    // }
	
	    var contentContainer = _react2['default'].createElement(
	      _ReactView2['default'],
	      {
	        ref: INNERVIEW,
	        style: contentContainerStyle,
	        removeClippedSubviews: this.props.removeClippedSubviews,
	        collapsable: false },
	      this.props.children
	    );
	
	    var alwaysBounceHorizontal = this.props.alwaysBounceHorizontal !== undefined ? this.props.alwaysBounceHorizontal : this.props.horizontal;
	
	    var alwaysBounceVertical = this.props.alwaysBounceVertical !== undefined ? this.props.alwaysBounceVertical : !this.props.horizontal;
	
	    if (this.props.scrollEventThrottle && this.props.onScroll) {
	      var handleScroll = (0, _domkitThrottle2['default'])(this.handleScroll, this.props.scrollEventThrottle);
	    }
	
	    var props = _extends({}, this.props, {
	      alwaysBounceHorizontal: alwaysBounceHorizontal,
	      alwaysBounceVertical: alwaysBounceVertical,
	      style: [styles.base, this.props.style],
	      onTouchStart: this.scrollResponderHandleTouchStart,
	      onTouchMove: this.scrollResponderHandleTouchMove,
	      onTouchEnd: this.scrollResponderHandleTouchEnd,
	      onScrollBeginDrag: this.scrollResponderHandleScrollBeginDrag,
	      onScrollEndDrag: this.scrollResponderHandleScrollEndDrag,
	      onMomentumScrollBegin: this.scrollResponderHandleMomentumScrollBegin,
	      onMomentumScrollEnd: this.scrollResponderHandleMomentumScrollEnd,
	      onStartShouldSetResponder: this.scrollResponderHandleStartShouldSetResponder,
	      onStartShouldSetResponderCapture: this.scrollResponderHandleStartShouldSetResponderCapture,
	      // onScrollShouldSetResponder: this.scrollResponderHandleScrollShouldSetResponder,
	      // onScroll: handleScroll,
	      onScrollShouldSetResponder: handleScroll,
	      // replace onScroll in the props
	      onScroll: function onScroll() {},
	      onResponderGrant: this.scrollResponderHandleResponderGrant,
	      onResponderTerminationRequest: this.scrollResponderHandleTerminationRequest,
	      onResponderTerminate: this.scrollResponderHandleTerminate,
	      onResponderRelease: this.scrollResponderHandleResponderRelease,
	      onResponderReject: this.scrollResponderHandleResponderReject
	    });
	
	    return _react2['default'].createElement(
	      _ReactView2['default'],
	      _extends({}, props, { ref: SCROLLVIEW }),
	      contentContainer
	    );
	  }
	});
	
	var styles = _ReactStyleSheet2['default'].create({
	  base: {
	    overflow: 'scroll',
	    WebkitOverflowScrolling: 'touch',
	    flex: 1
	  },
	  contentContainer: {
	    position: 'absolute',
	    minWidth: '100%'
	  },
	  contentContainerHorizontal: {
	    alignSelf: 'flex-start',
	    flexDirection: 'row'
	  }
	});
	
	module.exports = ScrollView;

/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * @providesModule ReactScrollResponder
	 * 
	 */
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(166);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _fbjsLibWarning = __webpack_require__(251);
	
	var _fbjsLibWarning2 = _interopRequireDefault(_fbjsLibWarning);
	
	/**
	 * Mixin that can be integrated in order to handle scrolling that plays well
	 * with `ResponderEventPlugin`. Integrate with your platform specific scroll
	 * views, or even your custom built (every-frame animating) scroll views so that
	 * all of these systems play well with the `ResponderEventPlugin`.
	 *
	 * iOS scroll event timing nuances:
	 * ===============================
	 *
	 *
	 * Scrolling without bouncing, if you touch down:
	 * -------------------------------
	 *
	 * 1. `onMomentumScrollBegin` (when animation begins after letting up)
	 *    ... physical touch starts ...
	 * 2. `onTouchStartCapture`   (when you press down to stop the scroll)
	 * 3. `onTouchStart`          (same, but bubble phase)
	 * 4. `onResponderRelease`    (when lifting up - you could pause forever before * lifting)
	 * 5. `onMomentumScrollEnd`
	 *
	 *
	 * Scrolling with bouncing, if you touch down:
	 * -------------------------------
	 *
	 * 1. `onMomentumScrollBegin` (when animation begins after letting up)
	 *    ... bounce begins ...
	 *    ... some time elapses ...
	 *    ... physical touch during bounce ...
	 * 2. `onMomentumScrollEnd`   (Makes no sense why this occurs first during bounce)
	 * 3. `onTouchStartCapture`   (immediately after `onMomentumScrollEnd`)
	 * 4. `onTouchStart`          (same, but bubble phase)
	 * 5. `onTouchEnd`            (You could hold the touch start for a long time)
	 * 6. `onMomentumScrollBegin` (When releasing the view starts bouncing back)
	 *
	 * So when we receive an `onTouchStart`, how can we tell if we are touching
	 * *during* an animation (which then causes the animation to stop)? The only way
	 * to tell is if the `touchStart` occurred immediately after the
	 * `onMomentumScrollEnd`.
	 *
	 * This is abstracted out for you, so you can just call this.scrollResponderIsAnimating() if
	 * necessary
	 *
	 * `ScrollResponder` also includes logic for blurring a currently focused input
	 * if one is focused while scrolling. The `ScrollResponder` is a natural place
	 * to put this logic since it can support not dismissing the keyboard while
	 * scrolling, unless a recognized "tap"-like gesture has occurred.
	 *
	 * The public lifecycle API includes events for keyboard interaction, responder
	 * interaction, and scrolling (among others). The keyboard callbacks
	 * `onKeyboardWill/Did/*` are *global* events, but are invoked on scroll
	 * responder's props so that you can guarantee that the scroll responder's
	 * internal state has been updated accordingly (and deterministically) by
	 * the time the props callbacks are invoke. Otherwise, you would always wonder
	 * if the scroll responder is currently in a state where it recognizes new
	 * keyboard positions etc. If coordinating scrolling with keyboard movement,
	 * *always* use these hooks instead of listening to your own global keyboard
	 * events.
	 *
	 * Public keyboard lifecycle API: (props callbacks)
	 *
	 * Standard Keyboard Appearance Sequence:
	 *
	 *   this.props.onKeyboardWillShow
	 *   this.props.onKeyboardDidShow
	 *
	 * `onScrollResponderKeyboardDismissed` will be invoked if an appropriate
	 * tap inside the scroll responder's scrollable region was responsible
	 * for the dismissal of the keyboard. There are other reasons why the
	 * keyboard could be dismissed.
	 *
	 *   this.props.onScrollResponderKeyboardDismissed
	 *
	 * Standard Keyboard Hide Sequence:
	 *
	 *   this.props.onKeyboardWillHide
	 *   this.props.onKeyboardDidHide
	 */
	
	var IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;
	
	var ScrollResponderMixin = {
	  // mixins: [Subscribable.Mixin],
	  // statics: RCTScrollViewConsts,
	  scrollResponderMixinGetInitialState: function scrollResponderMixinGetInitialState() {
	    return {
	      isTouching: false,
	      lastMomentumScrollBeginTime: 0,
	      lastMomentumScrollEndTime: 0,
	
	      // Reset to false every time becomes responder. This is used to:
	      // - Determine if the scroll view has been scrolled and therefore should
	      // refuse to give up its responder lock.
	      // - Determine if releasing should dismiss the keyboard when we are in
	      // tap-to-dismiss mode (!this.props.keyboardShouldPersistTaps).
	      observedScrollSinceBecomingResponder: false,
	      becameResponderWhileAnimating: false
	    };
	  },
	
	  /**
	   * Invoke this from an `onScroll` event.
	   */
	  scrollResponderHandleScrollShouldSetResponder: function scrollResponderHandleScrollShouldSetResponder() {
	    return this.state.isTouching;
	  },
	
	  /**
	   * Merely touch starting is not sufficient for a scroll view to become the
	   * responder. Being the "responder" means that the very next touch move/end
	   * event will result in an action/movement.
	   *
	   * Invoke this from an `onStartShouldSetResponder` event.
	   *
	   * `onStartShouldSetResponder` is used when the next move/end will trigger
	   * some UI movement/action, but when you want to yield priority to views
	   * nested inside of the view.
	   *
	   * There may be some cases where scroll views actually should return `true`
	   * from `onStartShouldSetResponder`: Any time we are detecting a standard tap
	   * that gives priority to nested views.
	   *
	   * - If a single tap on the scroll view triggers an action such as
	   *   recentering a map style view yet wants to give priority to interaction
	   *   views inside (such as dropped pins or labels), then we would return true
	   *   from this method when there is a single touch.
	   *
	   * - Similar to the previous case, if a two finger "tap" should trigger a
	   *   zoom, we would check the `touches` count, and if `>= 2`, we would return
	   *   true.
	   *
	   */
	  scrollResponderHandleStartShouldSetResponder: function scrollResponderHandleStartShouldSetResponder() {
	    return false;
	  },
	
	  /**
	   * There are times when the scroll view wants to become the responder
	   * (meaning respond to the next immediate `touchStart/touchEnd`), in a way
	   * that *doesn't* give priority to nested views (hence the capture phase):
	   *
	   * - Currently animating.
	   * - Tapping anywhere that is not the focused input, while the keyboard is
	   *   up (which should dismiss the keyboard).
	   *
	   * Invoke this from an `onStartShouldSetResponderCapture` event.
	   */
	  scrollResponderHandleStartShouldSetResponderCapture: function scrollResponderHandleStartShouldSetResponderCapture(e) {
	    // First see if we want to eat taps while the keyboard is up
	    // var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();
	    // if (!this.props.keyboardShouldPersistTaps &&
	    //   currentlyFocusedTextInput != null &&
	    //   e.target !== currentlyFocusedTextInput) {
	    //   return true;
	    // }
	    return this.scrollResponderIsAnimating();
	  },
	
	  /**
	   * make sure responder is `listview` self
	   *
	   * Invoke this from an `onMoveShouldSetResponderCapture` event
	   */
	  scrollResponderHandleMoveShouldSetResponderCapture: function scrollResponderHandleMoveShouldSetResponderCapture(e) {
	    return true;
	  },
	
	  /**
	   * Invoke this from an `onResponderReject` event.
	   *
	   * Some other element is not yielding its role as responder. Normally, we'd
	   * just disable the `UIScrollView`, but a touch has already began on it, the
	   * `UIScrollView` will not accept being disabled after that. The easiest
	   * solution for now is to accept the limitation of disallowing this
	   * altogether. To improve this, find a way to disable the `UIScrollView` after
	   * a touch has already started.
	   */
	  scrollResponderHandleResponderReject: function scrollResponderHandleResponderReject() {
	    (0, _fbjsLibWarning2['default'])(false, "ScrollView doesn't take rejection well - scrolls anyway");
	  },
	
	  /**
	   * We will allow the scroll view to give up its lock iff it acquired the lock
	   * during an animation. This is a very useful default that happens to satisfy
	   * many common user experiences.
	   *
	   * - Stop a scroll on the left edge, then turn that into an outer view's
	   *   backswipe.
	   * - Stop a scroll mid-bounce at the top, continue pulling to have the outer
	   *   view dismiss.
	   * - However, without catching the scroll view mid-bounce (while it is
	   *   motionless), if you drag far enough for the scroll view to become
	   *   responder (and therefore drag the scroll view a bit), any backswipe
	   *   navigation of a swipe gesture higher in the view hierarchy, should be
	   *   rejected.
	   */
	  scrollResponderHandleTerminationRequest: function scrollResponderHandleTerminationRequest() {
	    return !this.state.observedScrollSinceBecomingResponder;
	  },
	
	  /**
	   * Invoke this from an `onTouchEnd` event.
	   *
	   * @param {SyntheticEvent} e Event.
	   */
	  scrollResponderHandleTouchEnd: function scrollResponderHandleTouchEnd(e) {
	    var nativeEvent = e.nativeEvent;
	    this.state.isTouching = nativeEvent.touches.length !== 0;
	    this.props.onTouchEnd && this.props.onTouchEnd(e);
	  },
	
	  /**
	   * Invoke this from an `onResponderRelease` event.
	   */
	  scrollResponderHandleResponderRelease: function scrollResponderHandleResponderRelease(e) {
	    this.props.onResponderRelease && this.props.onResponderRelease(e);
	
	    // By default scroll views will unfocus a textField
	    // if another touch occurs outside of it
	    // var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();
	    if (!this.props.keyboardShouldPersistTaps &&
	    // currentlyFocusedTextInput != null && e.target !== currentlyFocusedTextInput &&
	    !this.state.observedScrollSinceBecomingResponder && !this.state.becameResponderWhileAnimating) {
	      this.props.onScrollResponderKeyboardDismissed && this.props.onScrollResponderKeyboardDismissed(e);
	      // TextInputState.blurTextInput(currentlyFocusedTextInput);
	    }
	  },
	
	  scrollResponderHandleScroll: function scrollResponderHandleScroll(e) {
	    this.state.observedScrollSinceBecomingResponder = true;
	    this.props.onScroll && this.props.onScroll(e);
	  },
	
	  /**
	   * Invoke this from an `onResponderGrant` event.
	   */
	  scrollResponderHandleResponderGrant: function scrollResponderHandleResponderGrant(e) {
	    this.state.observedScrollSinceBecomingResponder = false;
	    this.props.onResponderGrant && this.props.onResponderGrant(e);
	    this.state.becameResponderWhileAnimating = this.scrollResponderIsAnimating();
	  },
	
	  /**
	   * Unfortunately, `onScrollBeginDrag` also fires when *stopping* the scroll
	   * animation, and there's not an easy way to distinguish a drag vs. stopping
	   * momentum.
	   *
	   * Invoke this from an `onScrollBeginDrag` event.
	   */
	  scrollResponderHandleScrollBeginDrag: function scrollResponderHandleScrollBeginDrag(e) {
	    this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);
	  },
	
	  /**
	   * Invoke this from an `onScrollEndDrag` event.
	   */
	  scrollResponderHandleScrollEndDrag: function scrollResponderHandleScrollEndDrag(e) {
	    this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);
	  },
	
	  /**
	   * Invoke this from an `onMomentumScrollBegin` event.
	   */
	  scrollResponderHandleMomentumScrollBegin: function scrollResponderHandleMomentumScrollBegin(e) {
	    this.state.lastMomentumScrollBeginTime = Date.now();
	    this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);
	  },
	
	  /**
	   * Invoke this from an `onMomentumScrollEnd` event.
	   */
	  scrollResponderHandleMomentumScrollEnd: function scrollResponderHandleMomentumScrollEnd(e) {
	    this.state.lastMomentumScrollEndTime = Date.now();
	    this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);
	  },
	
	  /**
	   * Invoke this from an `onTouchStart` event.
	   *
	   * Since we know that the `SimpleEventPlugin` occurs later in the plugin
	   * order, after `ResponderEventPlugin`, we can detect that we were *not*
	   * permitted to be the responder (presumably because a contained view became
	   * responder). The `onResponderReject` won't fire in that case - it only
	   * fires when a *current* responder rejects our request.
	   *
	   * @param {SyntheticEvent} e Touch Start event.
	   */
	  scrollResponderHandleTouchStart: function scrollResponderHandleTouchStart(e) {
	    this.state.isTouching = true;
	    this.props.onTouchStart && this.props.onTouchStart(e);
	  },
	
	  /**
	   * Invoke this from an `onTouchMove` event.
	   *
	   * Since we know that the `SimpleEventPlugin` occurs later in the plugin
	   * order, after `ResponderEventPlugin`, we can detect that we were *not*
	   * permitted to be the responder (presumably because a contained view became
	   * responder). The `onResponderReject` won't fire in that case - it only
	   * fires when a *current* responder rejects our request.
	   *
	   * @param {SyntheticEvent} e Touch Start event.
	   */
	  scrollResponderHandleTouchMove: function scrollResponderHandleTouchMove(e) {
	    this.props.onTouchMove && this.props.onTouchMove(e);
	  },
	
	  /**
	   * A helper function for this class that lets us quickly determine if the
	   * view is currently animating. This is particularly useful to know when
	   * a touch has just started or ended.
	   */
	  scrollResponderIsAnimating: function scrollResponderIsAnimating() {
	    var now = Date.now();
	    var timeSinceLastMomentumScrollEnd = now - this.state.lastMomentumScrollEndTime;
	    var isAnimating = timeSinceLastMomentumScrollEnd < IS_ANIMATING_TOUCH_START_THRESHOLD_MS || this.state.lastMomentumScrollEndTime < this.state.lastMomentumScrollBeginTime;
	    return isAnimating;
	  },
	
	  /**
	   * A helper function to scroll to a specific point  in the scrollview.
	   * This is currently used to help focus on child textview's, but this
	   * can also be used to quickly scroll to any element we want to focus
	   */
	  scrollResponderScrollTo: function scrollResponderScrollTo(offsetX, offsetY) {
	    // TODO: Add scroll animation
	    this.scrollResponderScrollWithouthAnimationTo(offsetX, offsetY);
	  },
	
	  /**
	   * Like `scrollResponderScrollTo` but immediately scrolls to the given
	   * position
	   */
	  scrollResponderScrollWithouthAnimationTo: function scrollResponderScrollWithouthAnimationTo(offsetX, offsetY) {
	
	    var node = _reactDom2['default'].findDOMNode(this);
	    node.offsetX = offsetX;
	    node.offsetY = offsetY;
	  },
	
	  /**
	   * A helper function to zoom to a specific rect in the scrollview.
	   * @param {object} rect Should have shape {x, y, width, height}
	   */
	  scrollResponderZoomTo: function scrollResponderZoomTo(rect) {
	    // RCTUIManager.zoomToRect(React.findNodeHandle(this), rect);
	    // TODO
	  },
	
	  /**
	   * This method should be used as the callback to onFocus in a TextInputs'
	   * parent view. Note that any module using this mixin needs to return
	   * the parent view's ref in getScrollViewRef() in order to use this method.
	   * @param {any} nodeHandle The TextInput node handle
	   * @param {number} additionalOffset The scroll view's top "contentInset".
	   *        Default is 0.
	   * @param {bool} preventNegativeScrolling Whether to allow pulling the content
	   *        down to make it meet the keyboard's top. Default is false.
	   */
	  scrollResponderScrollNativeHandleToKeyboard: function scrollResponderScrollNativeHandleToKeyboard(nodeHandle, additionalOffset, preventNegativeScrollOffset) {
	    this.additionalScrollOffset = additionalOffset || 0;
	    this.preventNegativeScrollOffset = !!preventNegativeScrollOffset;
	    // RCTUIManager.measureLayout(
	    //   nodeHandle,
	    //   React.findNodeHandle(this.getInnerViewNode()),
	    //   this.scrollResponderTextInputFocusError,
	    //   this.scrollResponderInputMeasureAndScrollToKeyboard
	    // );
	  },
	
	  /**
	   * The calculations performed here assume the scroll view takes up the entire
	   * screen - even if has some content inset. We then measure the offsets of the
	   * keyboard, and compensate both for the scroll view's "contentInset".
	   *
	   * @param {number} left Position of input w.r.t. table view.
	   * @param {number} top Position of input w.r.t. table view.
	   * @param {number} width Width of the text input.
	   * @param {number} height Height of the text input.
	   */
	  scrollResponderInputMeasureAndScrollToKeyboard: function scrollResponderInputMeasureAndScrollToKeyboard(left, top, width, height) {
	    if (this.keyboardWillOpenTo) {
	      var scrollOffsetY = top - this.keyboardWillOpenTo.endCoordinates.screenY + height + this.additionalScrollOffset;
	
	      // By default, this can scroll with negative offset, pulling the content
	      // down so that the target component's bottom meets the keyboard's top.
	      // If requested otherwise, cap the offset at 0 minimum to avoid content
	      // shifting down.
	      if (this.preventNegativeScrollOffset) {
	        scrollOffsetY = Math.max(0, scrollOffsetY);
	      }
	      this.scrollResponderScrollTo(0, scrollOffsetY);
	    }
	    this.additionalOffset = 0;
	    this.preventNegativeScrollOffset = false;
	  },
	
	  scrollResponderTextInputFocusError: function scrollResponderTextInputFocusError(e) {
	    console.error('Error measuring text field: ', e);
	  },
	
	  /**
	   * `componentWillMount` is the closest thing to a  standard "constructor" for
	   * React components.
	   *
	   * The `keyboardWillShow` is called before input focus.
	   */
	  componentWillMount: function componentWillMount() {
	    // this.keyboardWillOpenTo = null;
	    // this.additionalScrollOffset = 0;
	    // this.addListenerOn(RCTDeviceEventEmitter, 'keyboardWillShow', this.scrollResponderKeyboardWillShow);
	    // this.addListenerOn(RCTDeviceEventEmitter, 'keyboardWillHide', this.scrollResponderKeyboardWillHide);
	    // this.addListenerOn(RCTDeviceEventEmitter, 'keyboardDidShow', this.scrollResponderKeyboardDidShow);
	    // this.addListenerOn(RCTDeviceEventEmitter, 'keyboardDidHide', this.scrollResponderKeyboardDidHide);
	    // warning(this.getInnerViewNode, 'You need to implement getInnerViewNode in '
	    //    + this.constructor.displayName + ' to get full'
	    //    + 'functionality from ScrollResponder mixin. See example of ListView and'
	    //    + ' ScrollView.');
	  },
	
	  /**
	   * Warning, this may be called several times for a single keyboard opening.
	   * It's best to store the information in this method and then take any action
	   * at a later point (either in `keyboardDidShow` or other).
	   *
	   * Here's the order that events occur in:
	   * - focus
	   * - willShow {startCoordinates, endCoordinates} several times
	   * - didShow several times
	   * - blur
	   * - willHide {startCoordinates, endCoordinates} several times
	   * - didHide several times
	   *
	   * The `ScrollResponder` providesModule callbacks for each of these events.
	   * Even though any user could have easily listened to keyboard events
	   * themselves, using these `props` callbacks ensures that ordering of events
	   * is consistent - and not dependent on the order that the keyboard events are
	   * subscribed to. This matters when telling the scroll view to scroll to where
	   * the keyboard is headed - the scroll responder better have been notified of
	   * the keyboard destination before being instructed to scroll to where the
	   * keyboard will be. Stick to the `ScrollResponder` callbacks, and everything
	   * will work.
	   *
	   * WARNING: These callbacks will fire even if a keyboard is displayed in a
	   * different navigation pane. Filter out the events to determine if they are
	   * relevant to you. (For example, only if you receive these callbacks after
	   * you had explicitly focused a node etc).
	   */
	  scrollResponderKeyboardWillShow: function scrollResponderKeyboardWillShow(e) {
	    this.keyboardWillOpenTo = e;
	    this.props.onKeyboardWillShow && this.props.onKeyboardWillShow(e);
	  },
	
	  scrollResponderKeyboardWillHide: function scrollResponderKeyboardWillHide(e) {
	    this.keyboardWillOpenTo = null;
	    this.props.onKeyboardWillHide && this.props.onKeyboardWillHide(e);
	  },
	
	  scrollResponderKeyboardDidShow: function scrollResponderKeyboardDidShow(e) {
	    // TODO(7693961): The event for DidShow is not available on iOS yet.
	    // Use the one from WillShow and do not assign.
	    if (e) {
	      this.keyboardWillOpenTo = e;
	    }
	    this.props.onKeyboardDidShow && this.props.onKeyboardDidShow(e);
	  },
	
	  scrollResponderKeyboardDidHide: function scrollResponderKeyboardDidHide() {
	    this.keyboardWillOpenTo = null;
	    this.props.onKeyboardDidHide && this.props.onKeyboardDidHide();
	  }
	
	};
	
	var ScrollResponder = {
	  Mixin: ScrollResponderMixin
	};
	
	module.exports = ScrollResponder;

/***/ },
/* 310 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function(fn, delay) {
	  var allowSample = true;
	  return function(e) {
	    if (allowSample) {
	      allowSample = false;
	      setTimeout(function() { allowSample = true; }, delay);
	      fn(e);
	    }
	  };
	}


/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015, Facebook, Inc.  All rights reserved.
	 *
	 * @providesModule ReactSegmentedControl
	 */
	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _ReactView = __webpack_require__(164);
	
	var _ReactView2 = _interopRequireDefault(_ReactView);
	
	var _ReactText = __webpack_require__(236);
	
	var _ReactText2 = _interopRequireDefault(_ReactText);
	
	var _ReactStyleSheet = __webpack_require__(154);
	
	var _ReactStyleSheet2 = _interopRequireDefault(_ReactStyleSheet);
	
	var SegmentedControl = _react2['default'].createClass({
	  displayName: 'SegmentedControl',
	
	  propTypes: {
	    /**
	     * The labels for the control's segment buttons, in order.
	     */
	    values: _react.PropTypes.arrayOf(_react.PropTypes.string),
	
	    /**
	     * The index in `props.values` of the segment to be pre-selected
	     */
	    selectedIndex: _react.PropTypes.number,
	
	    /**
	     * Callback that is called when the user taps a segment;
	     * passes the segment's value as an argument
	     */
	    onValueChange: _react.PropTypes.func,
	
	    /**
	     * Callback that is called when the user taps a segment;
	     * passes the event as an argument
	     */
	    onChange: _react.PropTypes.func,
	
	    /**
	     * If false the user won't be able to interact with the control.
	     * Default value is true.
	     */
	    enabled: _react.PropTypes.bool,
	
	    /**
	     * Accent color of the control.
	     */
	    tintColor: _react.PropTypes.string,
	
	    /**
	     * If true, then selecting a segment won't persist visually.
	     * The `onValueChange` callback will still work as expected.
	     */
	    momentary: _react.PropTypes.bool
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      values: [],
	      enabled: true
	    };
	  },
	
	  getInitialState: function getInitialState() {
	    return {
	      selectedIndex: this.props.selectedIndex,
	      momentary: false
	    };
	  },
	
	  _onChange: function _onChange(value, index, event) {
	    var _this = this;
	
	    if (this.state.selectedIndex == index) return;
	
	    this.setState({
	      selectedIndex: index
	    });
	
	    if (!event) {
	      event = {
	        nativeEvent: {}
	      };
	    }
	    // shim the value
	    event.nativeEvent.value = value;
	    event.nativeEvent.selectedSegmentIndex = index;
	    this.props.onChange && this.props.onChange(event);
	    this.props.onValueChange && this.props.onValueChange(event.nativeEvent.value);
	
	    if (this.props.momentary) {
	      setTimeout(function () {
	        return _this.setState({
	          selectedIndex: null
	        });
	      }, 300);
	    }
	  },
	
	  render: function render() {
	    var _this2 = this;
	
	    var props = this.props;
	
	    var items = props.values.map(function (value, index) {
	      return _react2['default'].createElement(
	        _ReactView2['default'],
	        { key: index, style: [styles.segmentedControlItem, props.tintColor ? { borderColor: props.tintColor } : null, _this2.state.selectedIndex === index ? [styles.segmentedControlItemSelected, props.tintColor ? { backgroundColor: props.tintColor } : null] : null, index === 0 ? styles.firstChild : styles.otherChild, index === props.values.length - 1 ? styles.lastChild : null] },
	        _react2['default'].createElement(
	          _ReactText2['default'],
	          { style: [styles.segmentedControlText, props.tintColor ? {
	              color: props.tintColor
	            } : null, _this2.state.selectedIndex === index ? styles.segmentedControlTextSelected : null],
	            onPress: props.enabled ? _this2._onChange.bind(_this2, value, index) : null },
	          ' ',
	          value,
	          ' '
	        )
	      );
	    });
	
	    return _react2['default'].createElement(
	      _ReactView2['default'],
	      _extends({}, this.props, { style: [styles.segmentedControl, props.enabled ? null : styles.disable, this.props.style] }),
	      items
	    );
	  }
	});
	
	var defaultColor = '#007AFF';
	
	var styles = _ReactStyleSheet2['default'].create({
	  segmentedControl: {
	    height: 28,
	    justifyContent: 'center',
	    flexDirection: 'row'
	  },
	  segmentedControlItem: {
	    flex: 1,
	    backgroundColor: 'white',
	    borderColor: defaultColor,
	    borderStyle: 'solid',
	    borderTopWidth: 1,
	    borderBottomWidth: 1,
	    borderRightWidth: 1,
	    borderLeftWidth: 1
	  },
	  segmentedControlItemSelected: {
	    backgroundColor: defaultColor
	  },
	  segmentedControlText: {
	    color: defaultColor,
	    fontSize: 12,
	    lineHeight: 12,
	    padding: '7 0',
	    textAlign: 'center'
	  },
	  segmentedControlTextSelected: {
	    color: 'white'
	  },
	  disable: {
	    opacity: 0.5
	  },
	  firstChild: {
	    borderTopLeftRadius: 3,
	    borderBottomLeftRadius: 3,
	    borderRightWidth: 0
	  },
	  otherChild: {
	    borderRightWidth: 0
	  },
	  lastChild: {
	    borderTopRightRadius: 3,
	    borderBottomRightRadius: 3,
	    borderRightWidth: 1
	  }
	});
	
	module.exports = SegmentedControl;

/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * @providesModule ReactSlider
	 */
	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(166);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _ReactStyleSheet = __webpack_require__(154);
	
	var _ReactStyleSheet2 = _interopRequireDefault(_ReactStyleSheet);
	
	var _ReactView = __webpack_require__(164);
	
	var _ReactView2 = _interopRequireDefault(_ReactView);
	
	var _ReactImage = __webpack_require__(233);
	
	var _ReactImage2 = _interopRequireDefault(_ReactImage);
	
	var _ReactPanResponder = __webpack_require__(240);
	
	var _ReactPanResponder2 = _interopRequireDefault(_ReactPanResponder);
	
	var TRACK_SIZE = 4;
	var THUMB_SIZE = 20;
	
	function noop() {}
	
	var Slider = (function (_Component) {
	  _inherits(Slider, _Component);
	
	  function Slider(props) {
	    _classCallCheck(this, Slider);
	
	    _get(Object.getPrototypeOf(Slider.prototype), 'constructor', this).call(this, props);
	    this.state = {
	      value: props.value
	    };
	  }
	
	  _createClass(Slider, [{
	    key: 'componentWillMount',
	    value: function componentWillMount() {
	      this._panResponder = _ReactPanResponder2['default'].create({
	        onStartShouldSetPanResponder: this._handleStartShouldSetPanResponder.bind(this),
	        onMoveShouldSetPanResponder: this._handleMoveShouldSetPanResponder.bind(this),
	        onPanResponderGrant: this._handlePanResponderGrant.bind(this),
	        onPanResponderMove: this._handlePanResponderMove.bind(this),
	        onPanResponderRelease: this._handlePanResponderEnd.bind(this),
	        onPanResponderTerminate: this._handlePanResponderEnd.bind(this)
	      });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _props = this.props;
	      var minimumTrackTintColor = _props.minimumTrackTintColor;
	      var maximumTrackTintColor = _props.maximumTrackTintColor;
	      var styles = _props.styles;
	      var style = _props.style;
	      var trackStyle = _props.trackStyle;
	      var thumbStyle = _props.thumbStyle;
	      var thumbTintColor = _props.thumbTintColor;
	      var thumbImage = _props.thumbImage;
	      var disabled = _props.disabled;
	
	      var other = _objectWithoutProperties(_props, ['minimumTrackTintColor', 'maximumTrackTintColor', 'styles', 'style', 'trackStyle', 'thumbStyle', 'thumbTintColor', 'thumbImage', 'disabled']);
	
	      var mainStyles = styles || defaultStyles;
	      var trackHeight = trackStyle && trackStyle.height || defaultStyles.track.height;
	      var thumbHeight = thumbStyle && thumbStyle.height || defaultStyles.thumb.height;
	      var minTrackWidth = this._getMinTrackWidth();
	      var minimumTrackStyle = {
	        width: minTrackWidth,
	        marginTop: -trackHeight,
	        backgroundColor: minimumTrackTintColor
	      };
	      return _react2['default'].createElement(
	        _ReactView2['default'],
	        { style: [mainStyles.container, style] },
	        _react2['default'].createElement(_ReactView2['default'], { ref: 'totalTrack',
	          style: [{ backgroundColor: maximumTrackTintColor }, mainStyles.track, trackStyle, disabled && { backgroundColor: mainStyles.disabled.backgroundColor }] }),
	        _react2['default'].createElement(_ReactView2['default'], { ref: 'minTrack', style: [mainStyles.track, trackStyle, minimumTrackStyle] }),
	        thumbImage && thumbImage.uri && _react2['default'].createElement(_ReactImage2['default'], _extends({ ref: 'thumb', source: thumbImage, style: [{ width: mainStyles.thumb.width, height: mainStyles.thumb.height }, thumbStyle, { left: minTrackWidth, position: 'relative', display: 'block' }, { marginLeft: -thumbHeight / 2, marginTop: -(thumbHeight + trackHeight) / 2 }]
	        }, this._panResponder.panHandlers)) || _react2['default'].createElement(_ReactView2['default'], _extends({ ref: 'thumb', style: [{ backgroundColor: thumbTintColor, left: minTrackWidth }, mainStyles.thumb, thumbStyle, { marginLeft: -thumbHeight / 2, marginTop: -(thumbHeight + trackHeight) / 2 }, disabled && { boxShadow: mainStyles.disabled.boxShadow }]
	        }, this._panResponder.panHandlers))
	      );
	    }
	  }, {
	    key: '_handleStartShouldSetPanResponder',
	    value: function _handleStartShouldSetPanResponder() {
	      return !this.props.disabled;
	    }
	  }, {
	    key: '_handleMoveShouldSetPanResponder',
	    value: function _handleMoveShouldSetPanResponder() {
	      return false;
	    }
	  }, {
	    key: '_handlePanResponderGrant',
	    value: function _handlePanResponderGrant(e, gestureState) {
	      this.previousLeft = this._getWidth('minTrack');
	      this.previousValue = this.state.value;
	      this._fireProcessEvent('onSlidingStart');
	    }
	  }, {
	    key: '_handlePanResponderMove',
	    value: function _handlePanResponderMove(e, gestureState) {
	      this.setState({ value: this._getValue(gestureState) });
	      this._fireProcessEvent('onValueChange');
	    }
	  }, {
	    key: '_handlePanResponderEnd',
	    value: function _handlePanResponderEnd(e, gestureState) {
	      this.setState({ value: this._getValue(gestureState) });
	      this._fireProcessEvent('onSlidingComplete');
	    }
	  }, {
	    key: '_fireProcessEvent',
	    value: function _fireProcessEvent(event) {
	      if (this.props[event]) {
	        this.props[event](this.state.value);
	      }
	    }
	  }, {
	    key: '_getValue',
	    value: function _getValue(gestureState) {
	      var _props2 = this.props;
	      var step = _props2.step;
	      var maximumValue = _props2.maximumValue;
	      var minimumValue = _props2.minimumValue;
	
	      var totalWidth = this._getWidth('totalTrack');
	      var thumbLeft = Math.min(totalWidth, Math.max(0, this.previousLeft + gestureState.dx)),
	          ratio = thumbLeft / totalWidth,
	          newValue = ratio * (maximumValue - minimumValue) + minimumValue;
	      if (step > 0) {
	        return Math.round(newValue / step) * step;
	      } else {
	        return newValue;
	      }
	    }
	  }, {
	    key: '_getWidth',
	    value: function _getWidth(ref) {
	      if (this.refs[ref]) {
	        var node = _reactDom2['default'].findDOMNode(this.refs[ref]),
	            rect = node.getBoundingClientRect();
	        return rect.width;
	      }
	    }
	  }, {
	    key: '_getMinTrackWidth',
	    value: function _getMinTrackWidth() {
	      var value = this.state.value;
	      return 100 * (value - this.props.minimumValue) / (this.props.maximumValue - this.props.minimumValue) + '%';
	    }
	  }]);
	
	  return Slider;
	})(_react.Component);
	
	Slider.propTypes = {
	  /**
	   * Used to style and layout the `Slider`.  See `StyleSheet.js` and
	   * `ViewStylePropTypes.js` for more info.
	   */
	  style: _ReactView2['default'].propTypes.style,
	  /**
	   * Initial value of the slider. The value should be between minimumValue
	   * and maximumValue, which default to 0 and 1 respectively.
	   * Default value is 0.
	   *
	   * *This is not a controlled component*, e.g. if you don't update
	   * the value, the component won't be reset to its inital value.
	   */
	  value: _react.PropTypes.number,
	  /**
	   * Step value of the slider. The value should be
	   * between 0 and (maximumValue - minimumValue).
	   * Default value is 0.
	   */
	  step: _react.PropTypes.number,
	  /**
	   * Initial minimum value of the slider. Default value is 0.
	   */
	  minimumValue: _react.PropTypes.number,
	  /**
	   * Initial maximum value of the slider. Default value is 1.
	   */
	  maximumValue: _react.PropTypes.number,
	  /**
	   * The color used for the track to the left of the button. Overrides the
	   * default blue gradient image.
	   */
	  minimumTrackTintColor: _react.PropTypes.string,
	  /**
	   * The color used for the track to the right of the button. Overrides the
	   * default blue gradient image.
	   */
	  maximumTrackTintColor: _react.PropTypes.string,
	  /**
	   * If true the user won't be able to move the slider.
	   * Default value is false.
	   */
	  disabled: _react.PropTypes.bool,
	  /**
	   * Sets an image for the track. It only supports images that are included as assets
	   */
	  trackImage: _react.PropTypes.any,
	  /**
	   * Sets an image for the thumb. It only supports static images.
	   */
	  thumbImage: _react.PropTypes.any,
	  /**
	   * Callback continuously called while the user is dragging the slider.
	   */
	  onValueChange: _react.PropTypes.func,
	  /**
	   * Callback called when the user finishes changing the value (e.g. when
	   * the slider is released).
	   */
	  onSlidingComplete: _react.PropTypes.func
	};
	
	Slider.defaultProps = {
	  value: 0,
	  step: 0,
	  minimumValue: 0,
	  maximumValue: 1,
	  minimumTrackTintColor: '#0f85fb',
	  maximumTrackTintColor: '#b3b3b3',
	  thumbTintColor: '#fff',
	  disabled: false,
	  onValueChange: noop,
	  onSlidingComplete: noop
	};
	
	var defaultStyles = _ReactStyleSheet2['default'].create({
	  container: {
	    height: 40,
	    justifyContent: 'center',
	    position: 'relative'
	  },
	  track: {
	    height: TRACK_SIZE,
	    borderRadius: TRACK_SIZE / 2
	  },
	  thumb: {
	    width: THUMB_SIZE,
	    height: THUMB_SIZE,
	    borderRadius: THUMB_SIZE / 2,
	    boxShadow: '2px 3px 10px rgba(0,0,0,0.75)'
	  },
	  disabled: {
	    backgroundColor: '#dadada',
	    boxShadow: '2px 3px 10px rgba(0,0,0,0.25)'
	  }
	});
	
	module.exports = Slider;

/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * @providesModule ReactSwitch
	 */
	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var Switch = _react2['default'].createClass({
	  displayName: 'Switch',
	
	  propTypes: {
	    value: _react.PropTypes.bool,
	    disabled: _react.PropTypes.bool,
	    onValueChange: _react.PropTypes.func,
	    onTintColor: _react.PropTypes.string,
	    thumbTintColor: _react.PropTypes.string,
	    tintColor: _react.PropTypes.string
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      onTintColor: '#00e158',
	      thumbTintColor: '#fff',
	      tintColor: '#fff'
	    };
	  },
	
	  getInitialState: function getInitialState() {
	    return {
	      value: this.props.value,
	      disabled: this.props.disabled
	    };
	  },
	
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    this.setState({
	      value: nextProps.value,
	      disabled: nextProps.disabled
	    });
	  },
	
	  getStyles: function getStyles() {
	    return {
	      span: {
	        position: 'relative',
	        display: 'inline-block',
	        margin: 2,
	        height: 30,
	        width: 50,
	        cursor: 'default', // pointer will cause a grey background color on chrome
	        verticalAlign: 'middle',
	        borderRadius: 20,
	        borderColor: '#dfdfdf',
	        borderWidth: 1,
	        borderStyle: 'solid',
	        WebkitUserSelect: 'none',
	        WebkitBoxSizing: 'content-box',
	        WebkitBackfaceVisibility: 'hidden'
	      },
	      checkedSpan: {
	        borderColor: this.props.onTintColor,
	        backgroundColor: this.props.onTintColor,
	        boxShadow: this.props.onTintColor + ' 0 0 0 16px inset',
	        WebkitTransition: 'border 0.2s, box-shadow 0.2s, background-color 1s'
	      },
	      uncheckedSpan: {
	        borderColor: '#dfdfdf',
	        backgroundColor: this.props.tintColor,
	        boxShadow: '#dfdfdf 0 0 0 0 inset',
	        WebkitTransition: 'border 0.2s, box-shadow 0.2s'
	      },
	      disabledSpan: {
	        opacity: 0.5,
	        cursor: 'not-allowed',
	        boxShadow: 'none'
	      },
	      small: {
	        position: 'absolute',
	        top: 0,
	        width: 30,
	        height: 30,
	        backgroundColor: this.props.thumbTintColor,
	        borderRadius: '100%',
	        boxShadow: '0 1px 3px rgba(0,0,0,0.4)',
	        WebkitTransition: '-webkit-transform 0.2s ease-in'
	      },
	      checkedSmall: {
	        WebkitTransform: 'translateX(20px)'
	      },
	      uncheckedSmall: {
	        WebkitTransform: 'translateX(0)'
	      }
	    };
	  },
	
	  handleClick: function handleClick(e) {
	    if (this.state.disabled) {
	      return null;
	    }
	
	    var newVal = !this.state.value;
	    this.props.onValueChange && this.props.onValueChange.call(this, newVal);
	    this.setState({
	      value: newVal
	    });
	
	    var oldValue = this.props.value;
	    setTimeout((function () {
	      if (this.props.value == oldValue) {
	        this.setState({
	          value: this.props.value
	        });
	      }
	    }).bind(this), 200);
	  },
	
	  render: function render() {
	    var styles = this.getStyles();
	    var spancss = this.state.value ? _extends({}, styles.span, styles.checkedSpan) : _extends({}, styles.span, styles.uncheckedSpan);
	    var smallcss = this.state.value ? _extends({}, styles.small, styles.checkedSmall) : _extends({}, styles.small, styles.uncheckedSmall);
	    spancss = this.state.disabled ? _extends({}, spancss, styles.disabledSpan) : spancss;
	
	    return _react2['default'].createElement(
	      'span',
	      { onClick: this.handleClick, style: spancss },
	      _react2['default'].createElement('small', { style: smallcss })
	    );
	  }
	
	});
	module.exports = Switch;

/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * @providesModule ReactTabBar
	 */
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _ReactView = __webpack_require__(164);
	
	var _ReactView2 = _interopRequireDefault(_ReactView);
	
	var _TabBarItemWeb = __webpack_require__(315);
	
	var _TabBarItemWeb2 = _interopRequireDefault(_TabBarItemWeb);
	
	var _TabBarContentsWeb = __webpack_require__(316);
	
	var _TabBarContentsWeb2 = _interopRequireDefault(_TabBarContentsWeb);
	
	var _objectAssign = __webpack_require__(317);
	
	var _objectAssign2 = _interopRequireDefault(_objectAssign);
	
	var TabBar = _react2['default'].createClass({
	  displayName: 'TabBar',
	
	  getInitialState: function getInitialState() {
	    return {
	      selectedIndex: 0
	    };
	  },
	
	  statics: {
	    Item: _TabBarItemWeb2['default']
	  },
	
	  propTypes: {
	    style: _react2['default'].PropTypes.object,
	    /**
	     * Color of the currently selected tab icon
	     */
	    tintColor: _react2['default'].PropTypes.string,
	    /**
	     * Background color of the tab bar
	     */
	    barTintColor: _react2['default'].PropTypes.string,
	
	    clientHeight: _react2['default'].PropTypes.number
	  },
	
	  getStyles: function getStyles() {
	    return {
	      container: {
	        width: '100%',
	        height: this.props.clientHeight || document.documentElement.clientHeight,
	        position: 'relative',
	        overflow: 'hidden'
	      },
	      content: {
	        width: '100%',
	        height: '100%'
	      },
	      bar: {
	        width: '100%',
	        position: 'absolute',
	        padding: 0,
	        margin: 0,
	        listStyle: 'none',
	        left: 0,
	        bottom: 0,
	        // borderTop: '1px solid #e1e1e1',
	        backgroundColor: 'rgba(250,250,250,.96)',
	        display: 'table'
	      }
	    };
	  },
	
	  handleTouchTap: function handleTouchTap(index) {
	    this.setState({
	      selectedIndex: index
	    });
	  },
	
	  render: function render() {
	    var self = this;
	    var styles = self.getStyles();
	    var barStyle = (0, _objectAssign2['default'])(styles.bar, this.props.style || {}, this.props.barTintColor ? {
	      backgroundColor: this.props.barTintColor
	    } : {});
	
	    var tabContent = [];
	
	    var tabs = _react2['default'].Children.map(this.props.children, function (tab, index) {
	      if (tab.type.displayName === 'TabBarItem') {
	        if (tab.props.children) {
	          tabContent.push(_react2['default'].createElement(_TabBarContentsWeb2['default'], {
	            key: index,
	            selected: self.state.selectedIndex === index
	          }, tab.props.children));
	        } else {
	          tabContent.push(undefined);
	        }
	
	        return _react2['default'].cloneElement(tab, {
	          index: index,
	          selected: self.state.selectedIndex === index,
	          selectedColor: self.props.tintColor,
	          handleTouchTap: self.handleTouchTap
	        });
	      } else {
	        var type = tab.type.displayName || tab.type;
	        throw 'Tabbar only accepts TabBar.Item Components as children. Found ' + type + ' as child number ' + (index + 1) + ' of Tabbar';
	      }
	    });
	
	    return _react2['default'].createElement(
	      _ReactView2['default'],
	      { style: styles.container },
	      _react2['default'].createElement(
	        _ReactView2['default'],
	        { style: styles.content },
	        tabContent
	      ),
	      _react2['default'].createElement(
	        'ul',
	        { style: barStyle },
	        tabs
	      )
	    );
	  }
	});
	
	module.exports = TabBar;

/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 */
	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _ReactImage = __webpack_require__(233);
	
	var _ReactImage2 = _interopRequireDefault(_ReactImage);
	
	var _ReactText = __webpack_require__(236);
	
	var _ReactText2 = _interopRequireDefault(_ReactText);
	
	var _ReactView = __webpack_require__(164);
	
	var _ReactView2 = _interopRequireDefault(_ReactView);
	
	var TabBarItem = _react2['default'].createClass({
	  displayName: 'TabBarItem',
	
	  propTypes: {
	    /**
	     * Little red bubble that sits at the top right of the icon.
	     */
	    badge: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number]),
	    /**
	     * A custom icon for the tab. It is ignored when a system icon is defined.
	     */
	    icon: _react.PropTypes.object,
	    /**
	     * A custom icon when the tab is selected. It is ignored when a system
	     * icon is defined. If left empty, the icon will be tinted in blue.
	     */
	    selectedIcon: _react.PropTypes.string,
	    /**
	     * Callback when this tab is being selected, you should change the state of your
	     * component to set selected={true}.
	     */
	    onPress: _react.PropTypes.func,
	    /**
	     * It specifies whether the children are visible or not. If you see a
	     * blank content, you probably forgot to add a selected one.
	     */
	    selected: _react.PropTypes.bool,
	    /**
	     * React style object.
	     */
	    style: _react.PropTypes.object,
	    /**
	     * Text that appears under the icon. It is ignored when a system icon
	     * is defined.
	     */
	    title: _react.PropTypes.string,
	    /**
	     * Color of the currently selected tab icon
	     */
	    selectedColor: _react.PropTypes.string
	  },
	
	  getStyles: function getStyles() {
	    return {
	      tab: {
	        display: 'table-cell',
	        textAlign: 'center',
	        position: 'relative'
	      },
	      link: {
	        display: 'block',
	        padding: '0.3em 0'
	      },
	      badge: {
	        display: 'inline-block',
	        position: 'absolute',
	        top: 0,
	        left: '52%',
	        color: '#FFF',
	        backgroundColor: '#FF0000',
	        height: '1.6em',
	        lineHeight: '1.6em',
	        minWidth: '1.6em',
	        fontSize: '0.7em',
	        borderRadius: '0.8em',
	        fontStyle: 'normal'
	      },
	      icon: {
	        width: '1.875em',
	        height: '1.875em'
	      },
	      title: {
	        fontSize: 12
	      }
	    };
	  },
	
	  _onClick: function _onClick() {
	    if (this.props.onPress) {
	      this.props.onPress();
	    }
	    if (this.props.handleTouchTap) {
	      this.props.handleTouchTap(this.props.index);
	    }
	  },
	
	  render: function render() {
	    var styles = this.getStyles();
	
	    var tabStyle = _extends({}, styles.tab, this.props.style || {}, { color: this.props.selectedColor && this.props.selected ? this.props.selectedColor : null });
	
	    return _react2['default'].createElement(
	      'li',
	      { style: tabStyle },
	      _react2['default'].createElement(
	        'a',
	        { onClick: this._onClick, style: styles.link },
	        this.props.badge ? _react2['default'].createElement(
	          'em',
	          { style: styles.badge },
	          this.props.badge
	        ) : '',
	        _react2['default'].createElement(_ReactImage2['default'], { source: this.props.selected && this.props.selectedIcon ? this.props.selectedIcon : this.props.icon, style: styles.icon }),
	        _react2['default'].createElement(
	          _ReactView2['default'],
	          { style: { marginTop: 4 } },
	          _react2['default'].createElement(
	            _ReactText2['default'],
	            { style: styles.title },
	            this.props.title
	          )
	        )
	      )
	    );
	  }
	});
	
	module.exports = TabBarItem;

/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 */
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _ReactView = __webpack_require__(164);
	
	var _ReactView2 = _interopRequireDefault(_ReactView);
	
	var TabBarContents = _react2['default'].createClass({
	  displayName: 'TabBarContents',
	
	  getInitialState: function getInitialState() {
	    return {
	      hasBeenSelected: false
	    };
	  },
	
	  componentWillMount: function componentWillMount() {
	    if (this.props.selected) {
	      this.setState({
	        hasBeenSelected: true
	      });
	    }
	  },
	
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    if (this.state.hasBeenSelected || nextProps.selected) {
	      this.setState({
	        hasBeenSelected: true
	      });
	    }
	  },
	
	  render: function render() {
	    var styles = {
	      'display': 'none',
	      'width': '100%',
	      'height': '100%',
	      'position': 'relative'
	    };
	
	    if (this.props.selected) {
	      delete styles.display;
	    }
	
	    var tabContents = null;
	
	    // if the tab has already been shown once, always continue to show it so we
	    // preserve state between tab transitions
	    if (this.state.hasBeenSelected) {
	      tabContents = _react2['default'].createElement(
	        _ReactView2['default'],
	        { style: styles },
	        this.props.children
	      );
	    }
	
	    return tabContents;
	  }
	});
	
	module.exports = TabBarContents;

/***/ },
/* 317 */
/***/ function(module, exports) {

	'use strict';
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function ToObject(val) {
		if (val == null) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}
	
		return Object(val);
	}
	
	function ownEnumerableKeys(obj) {
		var keys = Object.getOwnPropertyNames(obj);
	
		if (Object.getOwnPropertySymbols) {
			keys = keys.concat(Object.getOwnPropertySymbols(obj));
		}
	
		return keys.filter(function (key) {
			return propIsEnumerable.call(obj, key);
		});
	}
	
	module.exports = Object.assign || function (target, source) {
		var from;
		var keys;
		var to = ToObject(target);
	
		for (var s = 1; s < arguments.length; s++) {
			from = arguments[s];
			keys = ownEnumerableKeys(Object(from));
	
			for (var i = 0; i < keys.length; i++) {
				to[keys[i]] = from[keys[i]];
			}
		}
	
		return to;
	};


/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015, Facebook, Inc.  All rights reserved.
	 *
	 * @providesModule ReactTextInput
	 */
	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(166);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _ReactView = __webpack_require__(164);
	
	var _ReactView2 = _interopRequireDefault(_ReactView);
	
	var typeMap = {
	  'default': 'text',
	  'ascii-capable': 'text',
	  'numbers-and-punctuation': 'number',
	  'url': 'url',
	  'number-pad': 'number',
	  'phone-pad': 'tel',
	  'name-phone-pad': 'text',
	  'email-address': 'email',
	  'decimal-pad': 'number',
	  'twitter': 'text',
	  'web-search': 'search',
	  'numeric': 'number'
	};
	
	var TextInput = _react2['default'].createClass({
	  displayName: 'TextInput',
	
	  propTypes: {
	    /**
	     * Can tell TextInput to automatically capitalize certain characters.
	     *
	     * - characters: all characters,
	     * - words: first letter of each word
	     * - sentences: first letter of each sentence (default)
	     * - none: don't auto capitalize anything
	     */
	    autoCapitalize: _react.PropTypes.oneOf(['none', 'sentences', 'words', 'characters']),
	    /**
	     * If false, disables auto-correct. The default value is true.
	     */
	    autoCorrect: _react.PropTypes.bool,
	    /**
	     * If true, focuses the input on componentDidMount.
	     * The default value is false.
	     */
	    autoFocus: _react.PropTypes.bool,
	    /**
	     * Set the position of the cursor from where editing will begin.
	     * @platorm android
	     */
	    textAlign: _react.PropTypes.oneOf(['start', 'center', 'end']),
	    /**
	     * Aligns text vertically within the TextInput.
	     * @platform android
	     */
	    textAlignVertical: _react.PropTypes.oneOf(['top', 'center', 'bottom']),
	    /**
	     * If false, text is not editable. The default value is true.
	     */
	    editable: _react.PropTypes.bool,
	    /**
	     * Determines which keyboard to open, e.g.`numeric`.
	     *
	     * The following values work across platforms:
	     * - default
	     * - numeric
	     * - email-address
	     */
	    keyboardType: _react.PropTypes.oneOf([
	    // Cross-platform
	    'default', 'numeric', 'email-address',
	    // iOS-only
	    'ascii-capable', 'numbers-and-punctuation', 'url', 'number-pad', 'phone-pad', 'name-phone-pad', 'decimal-pad', 'twitter', 'web-search']),
	    /**
	     * Determines how the return key should look.
	     * @platform ios
	     */
	    returnKeyType: _react.PropTypes.oneOf(['default', 'go', 'google', 'join', 'next', 'route', 'search', 'send', 'yahoo', 'done', 'emergency-call']),
	    /**
	     * Limits the maximum number of characters that can be entered. Use this
	     * instead of implementing the logic in JS to avoid flicker.
	     * @platform ios
	     */
	    maxLength: _react.PropTypes.number,
	    /**
	     * Sets the number of lines for a TextInput. Use it with multiline set to
	     * true to be able to fill the lines.
	     * @platform android
	     */
	    numberOfLines: _react.PropTypes.number,
	    /**
	     * If true, the keyboard disables the return key when there is no text and
	     * automatically enables it when there is text. The default value is false.
	     * @platform ios
	     */
	    enablesReturnKeyAutomatically: _react.PropTypes.bool,
	    /**
	     * If true, the text input can be multiple lines.
	     * The default value is false.
	     */
	    multiline: _react.PropTypes.bool,
	    /**
	     * Callback that is called when the text input is blurred
	     */
	    onBlur: _react.PropTypes.func,
	    /**
	     * Callback that is called when the text input is focused
	     */
	    onFocus: _react.PropTypes.func,
	    /**
	     * Callback that is called when the text input's text changes.
	     */
	    onChange: _react.PropTypes.func,
	    /**
	     * Callback that is called when the text input's text changes.
	     * Changed text is passed as an argument to the callback handler.
	     */
	    onChangeText: _react.PropTypes.func,
	    /**
	     * Callback that is called when text input ends.
	     */
	    onEndEditing: _react.PropTypes.func,
	    /**
	     * Callback that is called when the text input's submit button is pressed.
	     */
	    onSubmitEditing: _react.PropTypes.func,
	    /**
	     * Invoked on mount and layout changes with `{x, y, width, height}`.
	     */
	    onLayout: _react.PropTypes.func,
	    /**
	     * The string that will be rendered before text input has been entered
	     */
	    placeholder: _react.PropTypes.string,
	    /**
	     * The text color of the placeholder string
	     */
	    placeholderTextColor: _react.PropTypes.string,
	    /**
	     * If true, the text input obscures the text entered so that sensitive text
	     * like passwords stay secure. The default value is false.
	     */
	    secureTextEntry: _react.PropTypes.bool,
	
	    /**
	     * The value to show for the text input. TextInput is a controlled
	     * component, which means the native value will be forced to match this
	     * value prop if provided. For most uses this works great, but in some
	     * cases this may cause flickering - one common cause is preventing edits
	     * by keeping value the same. In addition to simply setting the same value,
	     * either set `editable={false}`, or set/update `maxLength` to prevent
	     * unwanted edits without flicker.
	     */
	    value: _react.PropTypes.string,
	    /**
	     * Provides an initial value that will change when the user starts typing.
	     * Useful for simple use-cases where you don't want to deal with listening
	     * to events and updating the value prop to keep the controlled state in sync.
	     */
	    defaultValue: _react.PropTypes.string,
	    /**
	     * When the clear button should appear on the right side of the text view
	     * @platform ios
	     */
	    clearButtonMode: _react.PropTypes.oneOf(['never', 'while-editing', 'unless-editing', 'always']),
	    /**
	     * If true, clears the text field automatically when editing begins
	     * @platform ios
	     */
	    clearTextOnFocus: _react.PropTypes.bool,
	    /**
	     * If true, all text will automatically be selected on focus
	     * @platform ios
	     */
	    selectTextOnFocus: _react.PropTypes.bool
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      editable: true,
	      multiline: false,
	      secureTextEntry: false,
	      keyboardType: 'default',
	      autoFocus: false
	    };
	  },
	
	  _onBlur: function _onBlur(e) {
	    var onBlur = this.props.onBlur;
	
	    if (onBlur) {
	      e.nativeEvent.text = e.target.value;
	      onBlur(e);
	    }
	  },
	
	  _onChange: function _onChange(e) {
	    var _props = this.props;
	    var onChange = _props.onChange;
	    var onChangeText = _props.onChangeText;
	
	    if (onChangeText) onChangeText(e.target.value);
	    if (onChange) {
	      e.nativeEvent.text = e.target.value;
	      onChange(e);
	    }
	  },
	
	  _onFocus: function _onFocus(e) {
	    var _props2 = this.props;
	    var clearTextOnFocus = _props2.clearTextOnFocus;
	    var onFocus = _props2.onFocus;
	    var selectTextOnFocus = _props2.selectTextOnFocus;
	
	    var node = _reactDom2['default'].findDOMNode(this);
	    if (clearTextOnFocus) node.value = '';
	    if (selectTextOnFocus) node.select();
	    if (onFocus) {
	      e.nativeEvent.text = e.target.value;
	      onFocus(e);
	    }
	  },
	
	  _onSelectionChange: function _onSelectionChange(e) {
	    var onSelectionChange = this.props.onSelectionChange;
	
	    if (onSelectionChange) {
	      var _e$target = e.target;
	      var selectionDirection = _e$target.selectionDirection;
	      var selectionEnd = _e$target.selectionEnd;
	      var selectionStart = _e$target.selectionStart;
	
	      e.nativeEvent.text = e.target.value;
	      var _event = {
	        selectionDirection: selectionDirection,
	        selectionEnd: selectionEnd,
	        selectionStart: selectionStart,
	        nativeEvent: e.nativeEvent
	      };
	      onSelectionChange(_event);
	    }
	  },
	
	  componentDidMount: function componentDidMount() {
	    if (this.props.autoFocus) {
	      _reactDom2['default'].findDOMNode(this.refs.input).focus();
	    }
	  },
	
	  render: function render() {
	    var _props3 = this.props;
	    var accessibilityLabel = _props3.accessibilityLabel;
	    var autoComplete = _props3.autoComplete;
	    var autoFocus = _props3.autoFocus;
	    var defaultValue = _props3.defaultValue;
	    var editable = _props3.editable;
	    var keyboardType = _props3.keyboardType;
	    var maxLength = _props3.maxLength;
	    var maxNumberOfLines = _props3.maxNumberOfLines;
	    var multiline = _props3.multiline;
	    var numberOfLines = _props3.numberOfLines;
	    var onBlur = _props3.onBlur;
	    var onChange = _props3.onChange;
	    var onChangeText = _props3.onChangeText;
	    var onSelectionChange = _props3.onSelectionChange;
	    var placeholder = _props3.placeholder;
	    var password = _props3.password;
	    var secureTextEntry = _props3.secureTextEntry;
	    var style = _props3.style;
	    var testID = _props3.testID;
	    var value = _props3.value;
	
	    var propsCommon = {
	      ref: 'input',
	      'aria-label': accessibilityLabel,
	      autoComplete: autoComplete && 'on',
	      autoFocus: autoFocus,
	      defaultValue: defaultValue,
	      maxLength: maxLength,
	      onBlur: onBlur && this._onBlur,
	      onChange: (onChange || onChangeText) && this._onChange,
	      onFocus: this._onFocus,
	      onSelect: onSelectionChange && this._onSelectionChange,
	      placeholder: placeholder,
	      readOnly: !editable,
	      style: _extends({}, styles.initial, style),
	      testID: testID,
	      value: value
	    };
	
	    var input;
	    if (multiline) {
	      var propsMultiline = _extends({}, propsCommon, {
	        maxRows: maxNumberOfLines || numberOfLines,
	        minRows: numberOfLines
	      });
	
	      input = _react2['default'].createElement('textarea', propsMultiline);
	    } else {
	
	      var type = typeMap[keyboardType];
	
	      if (password || secureTextEntry) {
	        type = 'password';
	      }
	
	      var propsSingleline = _extends({}, propsCommon, {
	        type: type
	      });
	
	      input = _react2['default'].createElement('input', propsSingleline);
	    }
	
	    if (this.props.children) {
	      return _react2['default'].createElement(
	        _ReactView2['default'],
	        null,
	        input,
	        this.props.children
	      );
	    } else {
	      return input;
	    }
	  }
	});
	
	var styles = {
	  initial: {
	    appearance: 'none',
	    backgroundColor: 'transparent',
	    borderColor: 'black',
	    borderWidth: 0,
	    boxSizing: 'border-box',
	    color: 'inherit',
	    font: 'inherit',
	    padding: 0,
	    height: 30 }
	};
	
	// default height
	module.exports = TextInput;

/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * @providesModule ReactToast
	 */
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _ReactPortal = __webpack_require__(320);
	
	var _ReactPortal2 = _interopRequireDefault(_ReactPortal);
	
	var _ReactText = __webpack_require__(236);
	
	var _ReactText2 = _interopRequireDefault(_ReactText);
	
	var _ReactStyleSheet = __webpack_require__(154);
	
	var _ReactStyleSheet2 = _interopRequireDefault(_ReactStyleSheet);
	
	var LONG_DELAY = 3500; // 3.5 seconds
	var SHORT_DELAY = 2000; // 2 seconds
	
	var Toast = {
	
	  SHORT: SHORT_DELAY,
	  LONG: LONG_DELAY,
	
	  show: function show(message, duration) {
	    _ReactPortal2['default'].showModal('toast', _react2['default'].createElement(
	      _ReactText2['default'],
	      { style: styles.container },
	      message
	    ));
	    setTimeout(function () {
	      return _ReactPortal2['default'].closeModal('toast');
	    }, duration);
	  }
	};
	
	var styles = _ReactStyleSheet2['default'].create({
	  container: {
	    backgroundColor: 'rgba(0,0,0,.65)',
	    color: '#ffffff',
	    padding: '4 8',
	    position: 'absolute',
	    left: '50%',
	    bottom: '50%',
	    fontSize: 14,
	    lineHeight: 18,
	    borderRadius: 2,
	    transform: 'translateX(-50%)'
	  }
	});
	
	module.exports = Toast;

/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * @providesModule ReactPortal
	 * 
	 */
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _ReactPlatform = __webpack_require__(278);
	
	var _ReactPlatform2 = _interopRequireDefault(_ReactPlatform);
	
	var _ReactStyleSheet = __webpack_require__(154);
	
	var _ReactStyleSheet2 = _interopRequireDefault(_ReactStyleSheet);
	
	var _ReactView = __webpack_require__(164);
	
	var _ReactView2 = _interopRequireDefault(_ReactView);
	
	var _portalRef;
	
	// Unique identifiers for modals.
	var lastUsedTag = 0;
	
	/*
	 * Note: Only intended for Android at the moment.  Just use Modal in your iOS
	 * code.
	 *
	 * A container that renders all the modals on top of everything else in the application.
	 *
	 * Portal makes it possible for application code to pass modal views all the way up to
	 * the root element created in `renderApplication`.
	 *
	 * Never use `<Portal>` in your code. There is only one Portal instance rendered
	 * by the top-level `renderApplication`.
	 */
	var Portal = _react2['default'].createClass({
	  displayName: 'Portal',
	
	  statics: {
	    /**
	     * Use this to create a new unique tag for your component that renders
	     * modals. A good place to allocate a tag is in `componentWillMount`
	     * of your component.
	     * See `showModal` and `closeModal`.
	     */
	    allocateTag: function allocateTag() {
	      return '__modal_' + ++lastUsedTag;
	    },
	
	    /**
	     * Render a new modal.
	     * @param tag A unique tag identifying the React component to render.
	     * This tag can be later used in `closeModal`.
	     * @param component A React component to be rendered.
	     */
	    showModal: function showModal(tag, component) {
	      if (!_portalRef) {
	        console.error('Calling showModal but no Portal has been rendered.');
	        return;
	      }
	      _portalRef._showModal(tag, component);
	    },
	
	    /**
	     * Remove a modal from the collection of modals to be rendered.
	     * @param tag A unique tag identifying the React component to remove.
	     * Must exactly match the tag previously passed to `showModal`.
	     */
	    closeModal: function closeModal(tag) {
	      if (!_portalRef) {
	        console.error('Calling closeModal but no Portal has been rendered.');
	        return;
	      }
	      _portalRef._closeModal(tag);
	    },
	
	    /**
	     * Get an array of all the open modals, as identified by their tag string.
	     */
	    getOpenModals: function getOpenModals() {
	      if (!_portalRef) {
	        console.error('Calling getOpenModals but no Portal has been rendered.');
	        return [];
	      }
	      return _portalRef._getOpenModals();
	    }
	  },
	
	  getInitialState: function getInitialState() {
	    return { modals: {} };
	  },
	
	  _showModal: function _showModal(tag, component) {
	    // We are about to open first modal, so Portal will appear.
	    // Let's disable accessibility for background view on Android.
	    if (this._getOpenModals().length === 0 && this.props.onModalVisibilityChanged) {
	      this.props.onModalVisibilityChanged(true);
	    }
	    // This way state is chained through multiple calls to
	    // _showModal, _closeModal correctly.
	    this.setState(function (state) {
	      var modals = state.modals;
	      modals[tag] = component;
	      return { modals: modals };
	    });
	  },
	
	  _closeModal: function _closeModal(tag) {
	    if (!this.state.modals.hasOwnProperty(tag)) {
	      return;
	    }
	    // We are about to close last modal, so Portal will disappear.
	    // Let's enable accessibility for application view on Android.
	    if (this._getOpenModals().length === 1 && this.props.onModalVisibilityChanged) {
	      this.props.onModalVisibilityChanged(false);
	    }
	    // This way state is chained through multiple calls to
	    // _showModal, _closeModal correctly.
	    this.setState(function (state) {
	      var modals = state.modals;
	      delete modals[tag];
	      return { modals: modals };
	    });
	  },
	
	  _getOpenModals: function _getOpenModals() {
	    return Object.keys(this.state.modals);
	  },
	
	  render: function render() {
	    _portalRef = this;
	    if (!this.state.modals) {
	      return null;
	    }
	    var modals = [];
	    for (var tag in this.state.modals) {
	      modals.push(this.state.modals[tag]);
	    }
	    if (modals.length === 0) {
	      return null;
	    }
	    return _react2['default'].createElement(
	      _ReactView2['default'],
	      {
	        style: styles.modalsContainer },
	      modals
	    );
	  }
	});
	
	var styles = _ReactStyleSheet2['default'].create({
	  modalsContainer: {
	    position: 'absolute',
	    left: 0,
	    top: 0,
	    right: 0,
	    bottom: 0
	  }
	});
	
	module.exports = Portal;

/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015, Facebook, Inc.  All rights reserved.
	 *
	 * @providesModule ReactTouchableHighlight
	 */
	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _ReactView = __webpack_require__(164);
	
	var _ReactView2 = _interopRequireDefault(_ReactView);
	
	var _reactTimerMixin = __webpack_require__(284);
	
	var _reactTimerMixin2 = _interopRequireDefault(_reactTimerMixin);
	
	var _ReactTouchableWithoutFeedback = __webpack_require__(322);
	
	var _ReactTouchableWithoutFeedback2 = _interopRequireDefault(_ReactTouchableWithoutFeedback);
	
	var _ReactTouchable = __webpack_require__(237);
	
	var _ReactStyleSheet = __webpack_require__(154);
	
	var _ReactStyleSheet2 = _interopRequireDefault(_ReactStyleSheet);
	
	var DEFAULT_PROPS = {
	  activeOpacity: 0.8,
	  underlayColor: 'black'
	};
	
	var PRESS_RECT_OFFSET = { top: 20, left: 20, right: 20, bottom: 30 };
	var CHILD_REF = 'childRef';
	var UNDERLAY_REF = 'underlayRef';
	// var INACTIVE_CHILD_PROPS = {
	//   style: StyleSheet.create({x: {opacity: 1.0}}).x,
	// };
	var INACTIVE_UNDERLAY_PROPS = {
	  style: _ReactStyleSheet2['default'].create({ x: { backgroundColor: 'transparent' } }).x
	};
	
	var TouchableHighlight = _react2['default'].createClass({
	  displayName: 'TouchableHighlight',
	
	  propTypes: _extends({}, _ReactTouchableWithoutFeedback2['default'].propTypes, {
	    /**
	     * Determines what the opacity of the wrapped view should be when touch is
	     * active.
	     */
	    activeOpacity: _react2['default'].PropTypes.number,
	    /**
	     * The color of the underlay that will show through when the touch is
	     * active.
	     */
	    underlayColor: _react2['default'].PropTypes.string,
	    /**
	     * Called immediately after the underlay is shown
	     */
	    onShowUnderlay: _react2['default'].PropTypes.func,
	    /**
	     * Called immediately after the underlay is hidden
	     */
	    onHideUnderlay: _react2['default'].PropTypes.func
	  }),
	
	  mixins: [_reactTimerMixin2['default'], _ReactTouchable.Mixin],
	
	  getDefaultProps: function getDefaultProps() {
	    return DEFAULT_PROPS;
	  },
	
	  // Performance optimization to avoid constantly re-generating these objects.
	  computeSyntheticState: function computeSyntheticState(props) {
	    return {
	      activeProps: {
	        style: {
	          opacity: props.activeOpacity
	        }
	      },
	      activeUnderlayProps: {
	        style: {
	          backgroundColor: props.underlayColor
	        }
	      },
	      underlayStyle: [INACTIVE_UNDERLAY_PROPS.style, props.style]
	    };
	  },
	
	  getInitialState: function getInitialState() {
	    return _extends({}, this.touchableGetInitialState(), this.computeSyntheticState(this.props));
	  },
	
	  componentDidMount: function componentDidMount() {
	    // ensurePositiveDelayProps(this.props);
	    // ensureComponentIsNative(this.refs[CHILD_REF]);
	  },
	
	  componentDidUpdate: function componentDidUpdate() {
	    // ensureComponentIsNative(this.refs[CHILD_REF]);
	  },
	
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    // ensurePositiveDelayProps(nextProps);
	    if (nextProps.activeOpacity !== this.props.activeOpacity || nextProps.underlayColor !== this.props.underlayColor || nextProps.style !== this.props.style) {
	      this.setState(this.computeSyntheticState(nextProps));
	    }
	  },
	
	  /**
	   * `Touchable.Mixin` self callbacks. The mixin will invoke these if they are
	   * defined on your component.
	   */
	  touchableHandleActivePressIn: function touchableHandleActivePressIn(e) {
	    this.clearTimeout(this._hideTimeout);
	    this._hideTimeout = null;
	    this._showUnderlay();
	    this.props.onPressIn && this.props.onPressIn(e);
	  },
	
	  touchableHandleActivePressOut: function touchableHandleActivePressOut(e) {
	    if (!this._hideTimeout) {
	      this._hideUnderlay();
	    }
	    this.props.onPressOut && this.props.onPressOut(e);
	  },
	
	  touchableHandlePress: function touchableHandlePress(e) {
	    this.clearTimeout(this._hideTimeout);
	    this._showUnderlay();
	    this._hideTimeout = this.setTimeout(this._hideUnderlay, this.props.delayPressOut || 100);
	    this.props.onPress && this.props.onPress(e);
	  },
	
	  touchableHandleLongPress: function touchableHandleLongPress(e) {
	    this.props.onLongPress && this.props.onLongPress(e);
	  },
	
	  touchableGetPressRectOffset: function touchableGetPressRectOffset() {
	    return PRESS_RECT_OFFSET; // Always make sure to predeclare a constant!
	  },
	
	  touchableGetHighlightDelayMS: function touchableGetHighlightDelayMS() {
	    return this.props.delayPressIn;
	  },
	
	  touchableGetLongPressDelayMS: function touchableGetLongPressDelayMS() {
	    return this.props.delayLongPress;
	  },
	
	  touchableGetPressOutDelayMS: function touchableGetPressOutDelayMS() {
	    return this.props.delayPressOut;
	  },
	
	  _showUnderlay: function _showUnderlay() {
	    if (!this.isMounted()) {
	      return;
	    }
	
	    // this.refs[UNDERLAY_REF].setNativeProps(this.state.activeUnderlayProps);
	    // this.refs[CHILD_REF].setNativeProps(this.state.activeProps);
	    this.props.onShowUnderlay && this.props.onShowUnderlay();
	  },
	
	  _hideUnderlay: function _hideUnderlay() {
	    this.clearTimeout(this._hideTimeout);
	    this._hideTimeout = null;
	    if (this.refs[UNDERLAY_REF]) {
	      // this.refs[CHILD_REF].setNativeProps(INACTIVE_CHILD_PROPS);
	      // this.refs[UNDERLAY_REF].setNativeProps({
	      //  ...INACTIVE_UNDERLAY_PROPS,
	      //  style: this.state.underlayStyle,
	      // });
	      this.props.onHideUnderlay && this.props.onHideUnderlay();
	    }
	  },
	
	  render: function render() {
	
	    return _react2['default'].createElement(
	      _ReactView2['default'],
	      {
	        accessible: true,
	        accessibilityComponentType: this.props.accessibilityComponentType,
	        accessibilityTraits: this.props.accessibilityTraits,
	        ref: UNDERLAY_REF,
	        style: this.state.underlayStyle,
	        onLayout: this.props.onLayout,
	        onStartShouldSetResponder: this.touchableHandleStartShouldSetResponder,
	        onResponderTerminationRequest: this.touchableHandleResponderTerminationRequest,
	        onResponderGrant: this.touchableHandleResponderGrant,
	        onResponderMove: this.touchableHandleResponderMove,
	        onResponderRelease: this.touchableHandleResponderRelease,
	        onResponderTerminate: this.touchableHandleResponderTerminate,
	        testID: this.props.testID },
	      _react2['default'].cloneElement(_react2['default'].Children.only(this.props.children), {
	        ref: CHILD_REF
	      })
	    );
	  }
	});
	
	module.exports = TouchableHighlight;

/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015, Facebook, Inc.  All rights reserved.
	 *
	 * @providesModule ReactTouchableWithoutFeedback
	 */
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	__webpack_require__(240);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _ReactTouchable = __webpack_require__(237);
	
	var _ReactTouchable2 = _interopRequireDefault(_ReactTouchable);
	
	/**
	 * When the scroll view is disabled, this defines how far your touch may move
	 * off of the button, before deactivating the button. Once deactivated, try
	 * moving it back and you'll see that the button is once again reactivated!
	 * Move it back and forth several times while the scroll view is disabled.
	 */
	var PRESS_RECT_OFFSET = {
	  top: 20,
	  left: 20,
	  right: 20,
	  bottom: 30
	};
	
	/**
	 * Do not use unless you have a very good reason. All the elements that
	 * respond to press should have a visual feedback when touched. This is
	 * one of the primary reason a "web" app doesn't feel "native".
	 */
	var TouchableWithoutFeedback = _react2['default'].createClass({
	  displayName: 'TouchableWithoutFeedback',
	
	  mixins: [_ReactTouchable2['default'].Mixin],
	
	  propTypes: {
	    /**
	     * Called when the touch is released, but not if cancelled (e.g. by a scroll
	     * that steals the responder lock).
	     */
	    onPress: _react2['default'].PropTypes.func,
	    onPressIn: _react2['default'].PropTypes.func,
	    onPressOut: _react2['default'].PropTypes.func,
	
	    onLongPress: _react2['default'].PropTypes.func,
	
	    /**
	     * Delay in ms, from the start of the touch, before onPressIn is called.
	     */
	    delayPressIn: _react2['default'].PropTypes.number,
	    /**
	     * Delay in ms, from the release of the touch, before onPressOut is called.
	     */
	    delayPressOut: _react2['default'].PropTypes.number,
	    /**
	     * Delay in ms, from onPressIn, before onLongPress is called.
	     */
	    delayLongPress: _react2['default'].PropTypes.number
	  },
	
	  getInitialState: function getInitialState() {
	    return this.touchableGetInitialState();
	  },
	
	  componentDidMount: function componentDidMount() {
	    // ensurePositiveDelayProps(this.props);
	  },
	
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    // ensurePositiveDelayProps(nextProps);
	  },
	
	  /**
	   * `Touchable.Mixin` self callbacks. The mixin will invoke these if they are
	   * defined on your component.
	   */
	  touchableHandlePress: function touchableHandlePress(e) {
	    this.props.onPress && this.props.onPress(e);
	  },
	
	  touchableHandleActivePressIn: function touchableHandleActivePressIn(e) {
	    this.props.onPressIn && this.props.onPressIn(e);
	  },
	
	  touchableHandleActivePressOut: function touchableHandleActivePressOut(e) {
	    this.props.onPressOut && this.props.onPressOut(e);
	  },
	
	  touchableHandleLongPress: function touchableHandleLongPress(e) {
	    this.props.onLongPress && this.props.onLongPress(e);
	  },
	
	  touchableGetPressRectOffset: function touchableGetPressRectOffset() {
	    return PRESS_RECT_OFFSET; // Always make sure to predeclare a constant!
	  },
	
	  touchableGetHighlightDelayMS: function touchableGetHighlightDelayMS() {
	    return this.props.delayPressIn || 0;
	  },
	
	  touchableGetLongPressDelayMS: function touchableGetLongPressDelayMS() {
	    return this.props.delayLongPress === 0 ? 0 : this.props.delayLongPress || 500;
	  },
	
	  touchableGetPressOutDelayMS: function touchableGetPressOutDelayMS() {
	    return this.props.delayPressOut || 0;
	  },
	
	  render: function render() {
	    // Note(avik): remove dynamic typecast once Flow has been upgraded
	    return _react2['default'].cloneElement(_react2['default'].Children.only(this.props.children), {
	      onStartShouldSetResponder: this.touchableHandleStartShouldSetResponder,
	      onResponderTerminationRequest: this.touchableHandleResponderTerminationRequest,
	      onResponderGrant: this.touchableHandleResponderGrant,
	      onResponderMove: this.touchableHandleResponderMove,
	      onResponderRelease: this.touchableHandleResponderRelease,
	      onResponderTerminate: this.touchableHandleResponderTerminate
	    });
	  }
	});
	
	module.exports = TouchableWithoutFeedback;

/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015, Facebook, Inc.  All rights reserved.
	 *
	 * @providesModule ReactTouchableOpacity
	 */
	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _ReactAnimated = __webpack_require__(173);
	
	var _ReactAnimated2 = _interopRequireDefault(_ReactAnimated);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactTimerMixin = __webpack_require__(284);
	
	var _reactTimerMixin2 = _interopRequireDefault(_reactTimerMixin);
	
	var _ReactTouchable = __webpack_require__(237);
	
	var _ReactTouchableWithoutFeedback = __webpack_require__(322);
	
	var _ReactTouchableWithoutFeedback2 = _interopRequireDefault(_ReactTouchableWithoutFeedback);
	
	// var ensurePositiveDelayProps = require('ensurePositiveDelayProps');
	var flattenStyle = __webpack_require__(162);
	
	/**
	 * A wrapper for making views respond properly to touches.
	 * On press down, the opacity of the wrapped view is decreased, dimming it.
	 * This is done without actually changing the view hierarchy, and in general is
	 * easy to add to an app without weird side-effects.
	 *
	 * Example:
	 *
	 * ```
	 * renderButton: function() {
	 *   return (
	 *     <TouchableOpacity onPress={this._onPressButton}>
	 *       <Image
	 *         style={styles.button}
	 *         source={require('image!myButton')}
	 *       />
	 *     </TouchableOpacity>
	 *   );
	 * },
	 * ```
	 */
	
	var TouchableOpacity = _react2['default'].createClass({
	  displayName: 'TouchableOpacity',
	
	  mixins: [_reactTimerMixin2['default'], _ReactTouchable.Mixin],
	
	  propTypes: _extends({}, _ReactTouchableWithoutFeedback2['default'].propTypes, {
	    /**
	     * Determines what the opacity of the wrapped view should be when touch is
	     * active.
	     */
	    activeOpacity: _react2['default'].PropTypes.number
	  }),
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      activeOpacity: 0.2
	    };
	  },
	
	  getInitialState: function getInitialState() {
	    return _extends({}, this.touchableGetInitialState(), {
	      anim: new _ReactAnimated2['default'].Value(1)
	    });
	  },
	
	  componentDidMount: function componentDidMount() {
	    // ensurePositiveDelayProps(this.props);
	  },
	
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    // ensurePositiveDelayProps(nextProps);
	  },
	
	  setOpacityTo: function setOpacityTo(value) {
	    _ReactAnimated2['default'].timing(this.state.anim, { toValue: value, duration: 150 }).start();
	  },
	
	  /**
	   * `Touchable.Mixin` self callbacks. The mixin will invoke these if they are
	   * defined on your component.
	   */
	  touchableHandleActivePressIn: function touchableHandleActivePressIn(e) {
	    this.clearTimeout(this._hideTimeout);
	    this._hideTimeout = null;
	    this._opacityActive();
	    this.props.onPressIn && this.props.onPressIn(e);
	  },
	
	  touchableHandleActivePressOut: function touchableHandleActivePressOut(e) {
	    if (!this._hideTimeout) {
	      this._opacityInactive();
	    }
	    this.props.onPressOut && this.props.onPressOut(e);
	  },
	
	  touchableHandlePress: function touchableHandlePress(e) {
	    this.clearTimeout(this._hideTimeout);
	    this._opacityActive();
	    this._hideTimeout = this.setTimeout(this._opacityInactive, this.props.delayPressOut || 100);
	    this.props.onPress && this.props.onPress(e);
	  },
	
	  touchableHandleLongPress: function touchableHandleLongPress(e) {
	    this.props.onLongPress && this.props.onLongPress(e);
	  },
	
	  touchableGetPressRectOffset: function touchableGetPressRectOffset() {
	    return PRESS_RECT_OFFSET; // Always make sure to predeclare a constant!
	  },
	
	  touchableGetHighlightDelayMS: function touchableGetHighlightDelayMS() {
	    return this.props.delayPressIn || 0;
	  },
	
	  touchableGetLongPressDelayMS: function touchableGetLongPressDelayMS() {
	    return this.props.delayLongPress === 0 ? 0 : this.props.delayLongPress || 500;
	  },
	
	  touchableGetPressOutDelayMS: function touchableGetPressOutDelayMS() {
	    return this.props.delayPressOut;
	  },
	
	  _opacityActive: function _opacityActive() {
	    this.setOpacityTo(this.props.activeOpacity);
	  },
	
	  _opacityInactive: function _opacityInactive() {
	    this.clearTimeout(this._hideTimeout);
	    this._hideTimeout = null;
	    var childStyle = flattenStyle(this.props.style) || {};
	    this.setOpacityTo(childStyle.opacity === undefined ? 1 : childStyle.opacity);
	  },
	
	  render: function render() {
	    return _react2['default'].createElement(
	      _ReactAnimated2['default'].View,
	      {
	        accessible: true,
	        accessibilityComponentType: this.props.accessibilityComponentType,
	        accessibilityTraits: this.props.accessibilityTraits,
	        style: [this.props.style, { opacity: this.state.anim }],
	        testID: this.props.testID,
	        onLayout: this.props.onLayout,
	        onStartShouldSetResponder: this.touchableHandleStartShouldSetResponder,
	        onResponderTerminationRequest: this.touchableHandleResponderTerminationRequest,
	        onResponderGrant: this.touchableHandleResponderGrant,
	        onResponderMove: this.touchableHandleResponderMove,
	        onResponderRelease: this.touchableHandleResponderRelease,
	        onResponderTerminate: this.touchableHandleResponderTerminate },
	      this.props.children
	    );
	  }
	});
	
	/**
	 * When the scroll view is disabled, this defines how far your touch may move
	 * off of the button, before deactivating the button. Once deactivated, try
	 * moving it back and you'll see that the button is once again reactivated!
	 * Move it back and forth several times while the scroll view is disabled.
	 */
	var PRESS_RECT_OFFSET = { top: 20, left: 20, right: 20, bottom: 30 };
	
	module.exports = TouchableOpacity;

/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * @providesModule ReactViewPager
	 *
	 */
	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _objectAssign = __webpack_require__(317);
	
	var _objectAssign2 = _interopRequireDefault(_objectAssign);
	
	var _ReactView = __webpack_require__(164);
	
	var _ReactView2 = _interopRequireDefault(_ReactView);
	
	var _ReactAnimated = __webpack_require__(173);
	
	var _ReactAnimated2 = _interopRequireDefault(_ReactAnimated);
	
	var _ReactDimensions = __webpack_require__(247);
	
	var _ReactDimensions2 = _interopRequireDefault(_ReactDimensions);
	
	var _ReactPanResponder = __webpack_require__(240);
	
	var _ReactPanResponder2 = _interopRequireDefault(_ReactPanResponder);
	
	var _ReactDismissKeyboard = __webpack_require__(325);
	
	var _ReactDismissKeyboard2 = _interopRequireDefault(_ReactDismissKeyboard);
	
	var deviceSize = _ReactDimensions2['default'].get('window');
	var VIEWPAGER_REF = 'viewpager';
	
	var ViewPager = _react2['default'].createClass({
	  displayName: 'ViewPager',
	
	  propTypes: {
	    /**
	     * Index of initial page that should be selected. Use `setPage` method to
	     * update the page, and `onPageSelected` to monitor page changes
	     */
	    initialPage: _react.PropTypes.number,
	
	    /**
	     * Executed when transitioning between pages (ether because of animation for
	     * the requested page change or when user is swiping/dragging between pages)
	     * The `event.nativeEvent` object for this callback will carry following data:
	     *  - position - index of first page from the left that is currently visible
	     *  - offset - value from range [0,1) describing stage between page transitions.
	     *    Value x means that (1 - x) fraction of the page at "position" index is
	     *    visible, and x fraction of the next page is visible.
	     */
	    onPageScroll: _react.PropTypes.func,
	
	    /**
	     * This callback will be caleld once ViewPager finish navigating to selected page
	     * (when user swipes between pages). The `event.nativeEvent` object passed to this
	     * callback will have following fields:
	     *  - position - index of page that has been selected
	     */
	    onPageSelected: _react.PropTypes.func,
	
	    /**
	     * Determines whether the keyboard gets dismissed in response to a drag.
	     *   - 'none' (the default), drags do not dismiss the keyboard.
	     *   - 'on-drag', the keyboard is dismissed when a drag begins.
	     */
	    keyboardDismissMode: _react.PropTypes.oneOf(['none', // default
	    'on-drag'])
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      initialPage: 0
	    };
	  },
	
	  getInitialState: function getInitialState() {
	    return {
	      selectedPage: this.props.initialPage,
	      pageWidth: deviceSize.width,
	      pageCount: this.props.children.length,
	      offsetLeft: new _ReactAnimated2['default'].Value(0)
	    };
	  },
	
	  getInnerViewNode: function getInnerViewNode() {
	    return this.refs[VIEWPAGER_REF].childNodes[0];
	  },
	
	  componentWillMount: function componentWillMount() {
	    // let { offsetLeft, selectedPage } = this.state;
	
	    // offsetLeft.addListener(({value}) => {
	    // bad performance
	    // this._onPageScroll({
	    //  nativeEvent: {
	    //    position: selectedPage,
	    //    offset: value - selectedPage
	    //  }
	    // });
	    // });
	
	    this._panResponder = _ReactPanResponder2['default'].create({
	      onStartShouldSetResponder: function onStartShouldSetResponder() {
	        return true;
	      },
	      onMoveShouldSetPanResponder: this._shouldSetPanResponder,
	      onPanResponderGrant: function onPanResponderGrant() {},
	      onPanResponderMove: this._panResponderMove,
	      onPanResponderTerminationRequest: function onPanResponderTerminationRequest() {
	        return true;
	      },
	      onPanResponderRelease: this._panResponderRelease,
	      onPanResponderTerminate: function onPanResponderTerminate() {}
	    });
	  },
	
	  componentDidMount: function componentDidMount() {
	    this.setPage(this.state.selectedPage);
	  },
	
	  _childrenWithOverridenStyle: function _childrenWithOverridenStyle() {
	    // Override styles so that each page will fill the parent. Native component
	    // will handle positioning of elements, so it's not important to offset
	    // them correctly.
	    return _react2['default'].Children.map(this.props.children, function (child) {
	      var newProps = {
	        style: [child.props.style, {
	          width: deviceSize.width
	        }],
	        collapsable: false
	      };
	      return (0, _react.cloneElement)(child, (0, _objectAssign2['default'])({}, child.props, newProps));
	    });
	  },
	  render: function render() {
	    var children = this._childrenWithOverridenStyle();
	
	    var _state = this.state;
	    var offsetLeft = _state.offsetLeft;
	    var pageWidth = _state.pageWidth;
	    var pageCount = _state.pageCount;
	
	    var width = pageWidth * pageCount;
	    var count = pageCount - 1;
	
	    var translateX = offsetLeft.interpolate({
	      inputRange: [0, count],
	      outputRange: [0, -(pageWidth * count)],
	      extrapolate: 'clamp'
	    });
	
	    return _react2['default'].createElement(
	      _ReactView2['default'],
	      _extends({ ref: VIEWPAGER_REF,
	        style: this.props.style
	      }, this._panResponder.panHandlers),
	      _react2['default'].createElement(
	        _ReactAnimated2['default'].View,
	        { style: {
	            width: width,
	            position: 'absolute',
	            top: 0,
	            left: translateX,
	            bottom: 0,
	            flexDirection: 'row'
	          } },
	        children
	      )
	    );
	  },
	
	  _onPageScroll: function _onPageScroll(event) {
	    if (this.props.onPageScroll) {
	      this.props.onPageScroll(event);
	    }
	    if (this.props.keyboardDismissMode === 'on-drag') {
	      (0, _ReactDismissKeyboard2['default'])();
	    }
	  },
	
	  _shouldSetPanResponder: function _shouldSetPanResponder() {
	    var _this = this;
	
	    if (this._scrolling) {
	      this.state.offsetLeft.stopAnimation(function () {
	        _this._scrolling = false;
	      });
	      return false;
	    }
	
	    return true;
	  },
	
	  _panResponderMove: function _panResponderMove(ev, _ref) {
	    var dx = _ref.dx;
	
	    var val = this.state.selectedPage + dx / this.state.pageWidth * -1;
	    this.state.offsetLeft.setValue(val);
	  },
	
	  _panResponderRelease: function _panResponderRelease(ev, _ref2) {
	    var dx = _ref2.dx;
	    var _state2 = this.state;
	    var selectedPage = _state2.selectedPage;
	    var pageWidth = _state2.pageWidth;
	
	    var range = Math.abs(dx) / pageWidth;
	    var threshold = 1 / 5;
	
	    if (range > threshold) {
	      if (dx > 0) {
	        selectedPage -= 1; // TODO step?
	      } else {
	          selectedPage += 1;
	        }
	    }
	
	    this.setPage(selectedPage);
	  },
	
	  setPage: function setPage(index) {
	    var _this2 = this;
	
	    if (index < 0) {
	      index = 0;
	    } else if (index >= this.state.pageCount) {
	      index = this.state.pageCount - 1;
	    }
	
	    this._scrolling = true;
	
	    _ReactAnimated2['default'].spring(this.state.offsetLeft, {
	      toValue: index,
	      bounciness: 0,
	      restSpeedThreshold: 1
	    }).start(function () {
	
	      _this2._onPageScroll({
	        nativeEvent: {
	          position: index,
	          offset: 0
	        }
	      });
	
	      _this2._scrolling = false;
	
	      _this2.setState({
	        selectedPage: index
	      }, function () {
	        _this2.props.onPageSelected && _this2.props.onPageSelected({ nativeEvent: { position: index } });
	      });
	    });
	  }
	});
	
	module.exports = ViewPager;

/***/ },
/* 325 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * @providesModule ReactDismissKeyboard
	 */
	'use strict';
	
	function dismissKeyboard() {
	  document.activeElement.blur();
	}
	
	module.exports = dismissKeyboard;

/***/ },
/* 326 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * @providesModule ReactAlert
	 */
	'use strict';
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var DEFAULT_BUTTON_TEXT = 'OK';
	var DEFAULT_BUTTON = {
	  text: DEFAULT_BUTTON_TEXT,
	  onPress: null
	};
	
	/**
	 * Launches an alert dialog with the specified title and message.
	 *
	 * Optionally provide a list of buttons. Tapping any button will fire the
	 * respective onPress callback and dismiss the alert. By default, the only
	 * button will be an 'OK' button
	 *
	 * The last button in the list will be considered the 'Primary' button and
	 * it will appear bold.
	 *
	 * ```
	 * AlertIOS.alert(
	 *   'Foo Title',
	 *   'My Alert Msg',
	 *   [
	 *     {text: 'Foo', onPress: () => console.log('Foo Pressed!')},
	 *     {text: 'Bar', onPress: () => console.log('Bar Pressed!')},
	 *   ]
	 * )
	 * ```
	 */
	
	var AlertIOS = (function () {
	  function AlertIOS() {
	    _classCallCheck(this, AlertIOS);
	  }
	
	  _createClass(AlertIOS, null, [{
	    key: 'alert',
	    value: (function (_alert) {
	      function alert(_x, _x2, _x3, _x4) {
	        return _alert.apply(this, arguments);
	      }
	
	      alert.toString = function () {
	        return _alert.toString();
	      };
	
	      return alert;
	    })(function (title, message, buttons, type) {
	      var callbacks = [];
	      var buttonsSpec = [];
	      title = title || '';
	      message = message || '';
	      buttons = buttons || [DEFAULT_BUTTON];
	      type = type || '';
	
	      buttons.forEach(function (btn, index) {
	        callbacks[index] = btn.onPress;
	        var btnDef = {};
	        btnDef[index] = btn.text || DEFAULT_BUTTON_TEXT;
	        buttonsSpec.push(btnDef);
	      });
	
	      alert(title);
	    })
	  }, {
	    key: 'prompt',
	    value: (function (_prompt) {
	      function prompt(_x5, _x6, _x7, _x8) {
	        return _prompt.apply(this, arguments);
	      }
	
	      prompt.toString = function () {
	        return _prompt.toString();
	      };
	
	      return prompt;
	    })(function (title, value, buttons, callback) {
	      if (arguments.length === 2) {
	        if (typeof value === 'object') {
	          buttons = value;
	          value = undefined;
	        } else if (typeof value === 'function') {
	          callback = value;
	          value = undefined;
	        }
	      } else if (arguments.length === 3 && typeof buttons === 'function') {
	        callback = buttons;
	        buttons = undefined;
	      }
	
	      if (!buttons) {
	        buttons = [{
	          text: 'Cancel'
	        }, {
	          text: 'OK',
	          onPress: callback
	        }];
	      }
	
	      var ret = prompt(title);
	      if (ret && callback) {
	        callback();
	      }
	    })
	  }]);
	
	  return AlertIOS;
	})();
	
	module.exports = AlertIOS;

/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * @providesModule ReactAppRegistry
	 */
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _ReactRenderApplication = __webpack_require__(328);
	
	var _ReactRenderApplication2 = _interopRequireDefault(_ReactRenderApplication);
	
	var runnables = {};
	
	/**
	 * `AppRegistry` is the JS entry point to running all React Native apps.  App
	 * root components should register themselves with
	 * `AppRegistry.registerComponent`, then the native system can load the bundle
	 * for the app and then actually run the app when it's ready by invoking
	 * `AppRegistry.runApplication`.
	 *
	 * `AppRegistry` should be `require`d early in the `require` sequence to make
	 * sure the JS execution environment is setup before other modules are
	 * `require`d.
	 */
	var AppRegistry = {
	  registerConfig: function registerConfig(config) {
	    for (var i = 0; i < config.length; ++i) {
	      var appConfig = config[i];
	      if (appConfig.run) {
	        AppRegistry.registerRunnable(appConfig.appKey, appConfig.run);
	      } else {
	        AppRegistry.registerComponent(appConfig.appKey, appConfig.component);
	      }
	    }
	  },
	
	  registerComponent: function registerComponent(appKey, getComponentFunc) {
	    runnables[appKey] = {
	      run: function run(appParameters) {
	        return (0, _ReactRenderApplication2['default'])(getComponentFunc(), appParameters.initialProps, appParameters.rootTag);
	      }
	    };
	    return appKey;
	  },
	
	  registerRunnable: function registerRunnable(appKey, func) {
	    runnables[appKey] = {
	      run: func
	    };
	    return appKey;
	  },
	
	  getAppKeys: function getAppKeys() {
	    return Object.keys(runnables);
	  },
	
	  runApplication: function runApplication(appKey, appParameters) {
	    runnables[appKey].run(appParameters);
	  }
	};
	
	module.exports = AppRegistry;

/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * @providesModule ReactRenderApplication
	 */
	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(166);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _ReactStyleSheet = __webpack_require__(154);
	
	var _ReactStyleSheet2 = _interopRequireDefault(_ReactStyleSheet);
	
	var _ReactView = __webpack_require__(164);
	
	var _ReactView2 = _interopRequireDefault(_ReactView);
	
	var _ReactPortal = __webpack_require__(320);
	
	var _ReactPortal2 = _interopRequireDefault(_ReactPortal);
	
	var AppContainer = _react2['default'].createClass({
	  displayName: 'AppContainer',
	
	  render: function render() {
	    var RootComponent = this.props.rootComponent;
	    var appView = _react2['default'].createElement(
	      _ReactView2['default'],
	      {
	        id: 'app',
	        ref: 'main',
	        className: _ReactStyleSheet2['default'].rootClassName,
	        style: styles.appContainer },
	      _react2['default'].createElement(RootComponent, _extends({}, this.props.initialProps, {
	        rootTag: this.props.rootTag })),
	      _react2['default'].createElement(_ReactPortal2['default'], null)
	    );
	
	    return appView;
	  }
	});
	
	function renderApplication(RootComponent, initialProps, rootTag) {
	
	  _reactDom2['default'].render(_react2['default'].createElement(AppContainer, {
	    rootComponent: RootComponent,
	    initialProps: initialProps,
	    rootTag: rootTag }), rootTag);
	}
	
	var styles = _ReactStyleSheet2['default'].create({
	  // This is needed so the application covers the whole screen
	  // and therefore the contents of the React are not clipped.
	  appContainer: {
	    position: 'absolute',
	    left: 0,
	    top: 0,
	    right: 0,
	    bottom: 0,
	    height: '100vh',
	    width: '100vw'
	  }
	});
	
	module.exports = renderApplication;

/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * Copyright (c) 2015, Facebook, Inc.  All rights reserved.
	 *
	 * @providesModule ReactAsyncStorage
	 */
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _ReactPromise = __webpack_require__(330);
	
	var _ReactPromise2 = _interopRequireDefault(_ReactPromise);
	
	var localStorage = window.localStorage;
	
	/**
	 * Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1
	 *
	 * @returns obj3 a new object based on obj1 and obj2
	 */
	function merge(obj1, obj2) {
	  var obj3 = {};
	  for (var attrname in obj1) {
	    obj3[attrname] = obj1[attrname];
	  }
	  for (var attrname in obj2) {
	    obj3[attrname] = obj2[attrname];
	  }
	  return obj3;
	}
	
	// AsyncStorage Object
	var AsyncStorage = {};
	
	// both methods in localStorage and AsyncStorage
	var bothMethods = ['getItem', 'setItem', 'removeItem', 'clear'];
	
	/**
	 * Add 'getItem', 'setItem', 'removeItem', 'clear' to AsyncStorage
	 *
	 * Every method returns a `Promise` object.
	 */
	bothMethods.forEach(function (item) {
	
	  var promiseMethod = function promiseMethod() {
	
	    var args = arguments;
	
	    return new _ReactPromise2['default'](function (resolve, reject) {
	
	      try {
	
	        var result = localStorage[item].apply(localStorage, args);
	        resolve(result);
	      } catch (err) {
	
	        // Maybe in the browser private mode will cause this problem
	        reject(err);
	      }
	    });
	  };
	  AsyncStorage[item] = promiseMethod;
	});
	
	/**
	 * Merges existing value with input value, assuming they are stringified json. Returns a `Promise` object.
	 */
	AsyncStorage.mergeItem = function (key, value) {
	
	  return new _ReactPromise2['default'](function (resolve, reject) {
	
	    try {
	      var oldValue = localStorage.getItem(key);
	      var oldObj = JSON.parse(oldValue);
	      var newObj = JSON.parse(value);
	
	      // merge define in the file end
	      var mergedObj = merge(oldObj, newObj);
	
	      localStorage.setItem(key, JSON.stringify(mergedObj));
	      resolve();
	    } catch (err) {
	      reject(err);
	    }
	  });
	};
	
	/**
	 * Gets *all* keys known to the system, for all callers, libraries, etc. Returns a `Promise` object.
	 */
	AsyncStorage.getAllKeys = function () {
	
	  var keys = [];
	
	  for (var i = 0, len = localStorage.length; i < len; ++i) {
	    keys.push(localStorage.key(i));
	  }
	
	  return new _ReactPromise2['default'](function (resolve, reject) {
	    resolve(keys);
	  });
	};
	
	/**
	 * The following batched functions are useful for executing a lot of
	 * operations at once, allowing for native optimizations and provide the
	 * convenience of a single callback after all operations are complete.
	 *
	 * These functions return arrays of errors, potentially one for every key.
	 * For key-specific errors, the Error object will have a key property to
	 * indicate which key caused the error.
	 */
	
	/**
	 * multiGet invokes callback with an array of key-value pair arrays that
	 * matches the input format of multiSet. Returns a `Promise` object.
	 *
	 *   multiGet(['k1', 'k2'], cb) -> cb([['k1', 'val1'], ['k2', 'val2']])
	 */
	AsyncStorage.multiGet = function () {
	
	  var keys = [].splice.call(arguments);
	  var results = null;
	
	  return new _ReactPromise2['default'](function (resolve, reject) {
	
	    try {
	
	      results = keys.map(function (key) {
	        return [key, localStorage.getItem(key)];
	      });
	
	      resolve(results);
	    } catch (err) {
	      reject(err);
	    }
	  });
	};
	
	/**
	 * multiSet and multiMerge take arrays of key-value array pairs that match
	 * the output of multiGet, e.g. Returns a `Promise` object.
	 *
	 *   multiSet([['k1', 'val1'], ['k2', 'val2']], cb);
	 */
	AsyncStorage.multiSet = function () {
	
	  var args = [].splice.call(arguments);
	
	  return new _ReactPromise2['default'](function (resolve, reject) {
	
	    try {
	
	      args.forEach(function (item) {
	        return localStorage.setItem(item[0], item[1]);
	      });
	
	      resolve();
	    } catch (err) {
	      reject(err);
	    }
	  });
	};
	
	/**
	 * Delete all the keys in the `keys` array. Returns a `Promise` object.
	 */
	AsyncStorage.multiRemove = function () {
	
	  var keys = [].splice.call(arguments);
	
	  return new _ReactPromise2['default'](function (resolve, reject) {
	
	    try {
	
	      keys.forEach(function (key) {
	        return localStorage.removeItem(key);
	      });
	
	      resolve();
	    } catch (err) {
	      reject(err);
	    }
	  });
	};
	
	/**
	 * Merges existing values with input values, assuming they are stringified
	 * json. Returns a `Promise` object.
	 *
	 * Not supported by all native implementations.
	 */
	AsyncStorage.multiMerge = function () {
	
	  var self = this;
	  var args = [].splice.call(arguments);
	
	  return new _ReactPromise2['default'](function (resolve, reject) {
	    try {
	      var promiseQueue = args.map(function (arg) {
	        return self.mergeItem(arg[0], arg[1]);
	      });
	      resolve(_ReactPromise2['default'].all(promiseQueue));
	    } catch (err) {
	      reject(err);
	    }
	  });
	};
	
	module.exports = AsyncStorage;

/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * @providesModule ReactPromise
	 */
	
	'use strict';
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _promiseLibEs6Extensions = __webpack_require__(331);
	
	var _promiseLibEs6Extensions2 = _interopRequireDefault(_promiseLibEs6Extensions);
	
	__webpack_require__(334);
	
	/**
	 * Handle either fulfillment or rejection with the same callback.
	 */
	_promiseLibEs6Extensions2['default'].prototype['finally'] = function (onSettled) {
	  return this.then(onSettled, onSettled);
	};
	
	module.exports = _promiseLibEs6Extensions2['default'];

/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	//This file contains the ES6 extensions to the core Promises/A+ API
	
	var Promise = __webpack_require__(332);
	
	module.exports = Promise;
	
	/* Static Functions */
	
	var TRUE = valuePromise(true);
	var FALSE = valuePromise(false);
	var NULL = valuePromise(null);
	var UNDEFINED = valuePromise(undefined);
	var ZERO = valuePromise(0);
	var EMPTYSTRING = valuePromise('');
	
	function valuePromise(value) {
	  var p = new Promise(Promise._99);
	  p._37 = 1;
	  p._12 = value;
	  return p;
	}
	Promise.resolve = function (value) {
	  if (value instanceof Promise) return value;
	
	  if (value === null) return NULL;
	  if (value === undefined) return UNDEFINED;
	  if (value === true) return TRUE;
	  if (value === false) return FALSE;
	  if (value === 0) return ZERO;
	  if (value === '') return EMPTYSTRING;
	
	  if (typeof value === 'object' || typeof value === 'function') {
	    try {
	      var then = value.then;
	      if (typeof then === 'function') {
	        return new Promise(then.bind(value));
	      }
	    } catch (ex) {
	      return new Promise(function (resolve, reject) {
	        reject(ex);
	      });
	    }
	  }
	  return valuePromise(value);
	};
	
	Promise.all = function (arr) {
	  var args = Array.prototype.slice.call(arr);
	
	  return new Promise(function (resolve, reject) {
	    if (args.length === 0) return resolve([]);
	    var remaining = args.length;
	    function res(i, val) {
	      if (val && (typeof val === 'object' || typeof val === 'function')) {
	        if (val instanceof Promise && val.then === Promise.prototype.then) {
	          while (val._37 === 3) {
	            val = val._12;
	          }
	          if (val._37 === 1) return res(i, val._12);
	          if (val._37 === 2) reject(val._12);
	          val.then(function (val) {
	            res(i, val);
	          }, reject);
	          return;
	        } else {
	          var then = val.then;
	          if (typeof then === 'function') {
	            var p = new Promise(then.bind(val));
	            p.then(function (val) {
	              res(i, val);
	            }, reject);
	            return;
	          }
	        }
	      }
	      args[i] = val;
	      if (--remaining === 0) {
	        resolve(args);
	      }
	    }
	    for (var i = 0; i < args.length; i++) {
	      res(i, args[i]);
	    }
	  });
	};
	
	Promise.reject = function (value) {
	  return new Promise(function (resolve, reject) {
	    reject(value);
	  });
	};
	
	Promise.race = function (values) {
	  return new Promise(function (resolve, reject) {
	    values.forEach(function(value){
	      Promise.resolve(value).then(resolve, reject);
	    });
	  });
	};
	
	/* Prototype Methods */
	
	Promise.prototype['catch'] = function (onRejected) {
	  return this.then(null, onRejected);
	};


/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var asap = __webpack_require__(333);
	
	function noop() {}
	
	// States:
	//
	// 0 - pending
	// 1 - fulfilled with _value
	// 2 - rejected with _value
	// 3 - adopted the state of another promise, _value
	//
	// once the state is no longer pending (0) it is immutable
	
	// All `_` prefixed properties will be reduced to `_{random number}`
	// at build time to obfuscate them and discourage their use.
	// We don't use symbols or Object.defineProperty to fully hide them
	// because the performance isn't good enough.
	
	
	// to avoid using try/catch inside critical functions, we
	// extract them to here.
	var LAST_ERROR = null;
	var IS_ERROR = {};
	function getThen(obj) {
	  try {
	    return obj.then;
	  } catch (ex) {
	    LAST_ERROR = ex;
	    return IS_ERROR;
	  }
	}
	
	function tryCallOne(fn, a) {
	  try {
	    return fn(a);
	  } catch (ex) {
	    LAST_ERROR = ex;
	    return IS_ERROR;
	  }
	}
	function tryCallTwo(fn, a, b) {
	  try {
	    fn(a, b);
	  } catch (ex) {
	    LAST_ERROR = ex;
	    return IS_ERROR;
	  }
	}
	
	module.exports = Promise;
	
	function Promise(fn) {
	  if (typeof this !== 'object') {
	    throw new TypeError('Promises must be constructed via new');
	  }
	  if (typeof fn !== 'function') {
	    throw new TypeError('not a function');
	  }
	  this._37 = 0;
	  this._12 = null;
	  this._59 = [];
	  if (fn === noop) return;
	  doResolve(fn, this);
	}
	Promise._99 = noop;
	
	Promise.prototype.then = function(onFulfilled, onRejected) {
	  if (this.constructor !== Promise) {
	    return safeThen(this, onFulfilled, onRejected);
	  }
	  var res = new Promise(noop);
	  handle(this, new Handler(onFulfilled, onRejected, res));
	  return res;
	};
	
	function safeThen(self, onFulfilled, onRejected) {
	  return new self.constructor(function (resolve, reject) {
	    var res = new Promise(noop);
	    res.then(resolve, reject);
	    handle(self, new Handler(onFulfilled, onRejected, res));
	  });
	};
	function handle(self, deferred) {
	  while (self._37 === 3) {
	    self = self._12;
	  }
	  if (self._37 === 0) {
	    self._59.push(deferred);
	    return;
	  }
	  asap(function() {
	    var cb = self._37 === 1 ? deferred.onFulfilled : deferred.onRejected;
	    if (cb === null) {
	      if (self._37 === 1) {
	        resolve(deferred.promise, self._12);
	      } else {
	        reject(deferred.promise, self._12);
	      }
	      return;
	    }
	    var ret = tryCallOne(cb, self._12);
	    if (ret === IS_ERROR) {
	      reject(deferred.promise, LAST_ERROR);
	    } else {
	      resolve(deferred.promise, ret);
	    }
	  });
	}
	function resolve(self, newValue) {
	  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
	  if (newValue === self) {
	    return reject(
	      self,
	      new TypeError('A promise cannot be resolved with itself.')
	    );
	  }
	  if (
	    newValue &&
	    (typeof newValue === 'object' || typeof newValue === 'function')
	  ) {
	    var then = getThen(newValue);
	    if (then === IS_ERROR) {
	      return reject(self, LAST_ERROR);
	    }
	    if (
	      then === self.then &&
	      newValue instanceof Promise
	    ) {
	      self._37 = 3;
	      self._12 = newValue;
	      finale(self);
	      return;
	    } else if (typeof then === 'function') {
	      doResolve(then.bind(newValue), self);
	      return;
	    }
	  }
	  self._37 = 1;
	  self._12 = newValue;
	  finale(self);
	}
	
	function reject(self, newValue) {
	  self._37 = 2;
	  self._12 = newValue;
	  finale(self);
	}
	function finale(self) {
	  for (var i = 0; i < self._59.length; i++) {
	    handle(self, self._59[i]);
	  }
	  self._59 = null;
	}
	
	function Handler(onFulfilled, onRejected, promise){
	  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
	  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
	  this.promise = promise;
	}
	
	/**
	 * Take a potentially misbehaving resolver function and make sure
	 * onFulfilled and onRejected are only called once.
	 *
	 * Makes no guarantees about asynchrony.
	 */
	function doResolve(fn, promise) {
	  var done = false;
	  var res = tryCallTwo(fn, function (value) {
	    if (done) return;
	    done = true;
	    resolve(promise, value);
	  }, function (reason) {
	    if (done) return;
	    done = true;
	    reject(promise, reason);
	  })
	  if (!done && res === IS_ERROR) {
	    done = true;
	    reject(promise, LAST_ERROR);
	  }
	}


/***/ },
/* 333 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	// Use the fastest means possible to execute a task in its own turn, with
	// priority over other events including IO, animation, reflow, and redraw
	// events in browsers.
	//
	// An exception thrown by a task will permanently interrupt the processing of
	// subsequent tasks. The higher level `asap` function ensures that if an
	// exception is thrown by a task, that the task queue will continue flushing as
	// soon as possible, but if you use `rawAsap` directly, you are responsible to
	// either ensure that no exceptions are thrown from your task, or to manually
	// call `rawAsap.requestFlush` if an exception is thrown.
	module.exports = rawAsap;
	function rawAsap(task) {
	    if (!queue.length) {
	        requestFlush();
	        flushing = true;
	    }
	    // Equivalent to push, but avoids a function call.
	    queue[queue.length] = task;
	}
	
	var queue = [];
	// Once a flush has been requested, no further calls to `requestFlush` are
	// necessary until the next `flush` completes.
	var flushing = false;
	// `requestFlush` is an implementation-specific method that attempts to kick
	// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
	// the event queue before yielding to the browser's own event loop.
	var requestFlush;
	// The position of the next task to execute in the task queue. This is
	// preserved between calls to `flush` so that it can be resumed if
	// a task throws an exception.
	var index = 0;
	// If a task schedules additional tasks recursively, the task queue can grow
	// unbounded. To prevent memory exhaustion, the task queue will periodically
	// truncate already-completed tasks.
	var capacity = 1024;
	
	// The flush function processes all tasks that have been scheduled with
	// `rawAsap` unless and until one of those tasks throws an exception.
	// If a task throws an exception, `flush` ensures that its state will remain
	// consistent and will resume where it left off when called again.
	// However, `flush` does not make any arrangements to be called again if an
	// exception is thrown.
	function flush() {
	    while (index < queue.length) {
	        var currentIndex = index;
	        // Advance the index before calling the task. This ensures that we will
	        // begin flushing on the next task the task throws an error.
	        index = index + 1;
	        queue[currentIndex].call();
	        // Prevent leaking memory for long chains of recursive calls to `asap`.
	        // If we call `asap` within tasks scheduled by `asap`, the queue will
	        // grow, but to avoid an O(n) walk for every task we execute, we don't
	        // shift tasks off the queue after they have been executed.
	        // Instead, we periodically shift 1024 tasks off the queue.
	        if (index > capacity) {
	            // Manually shift all values starting at the index back to the
	            // beginning of the queue.
	            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
	                queue[scan] = queue[scan + index];
	            }
	            queue.length -= index;
	            index = 0;
	        }
	    }
	    queue.length = 0;
	    index = 0;
	    flushing = false;
	}
	
	// `requestFlush` is implemented using a strategy based on data collected from
	// every available SauceLabs Selenium web driver worker at time of writing.
	// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593
	
	// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
	// have WebKitMutationObserver but not un-prefixed MutationObserver.
	// Must use `global` instead of `window` to work in both frames and web
	// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.
	var BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;
	
	// MutationObservers are desirable because they have high priority and work
	// reliably everywhere they are implemented.
	// They are implemented in all modern browsers.
	//
	// - Android 4-4.3
	// - Chrome 26-34
	// - Firefox 14-29
	// - Internet Explorer 11
	// - iPad Safari 6-7.1
	// - iPhone Safari 7-7.1
	// - Safari 6-7
	if (typeof BrowserMutationObserver === "function") {
	    requestFlush = makeRequestCallFromMutationObserver(flush);
	
	// MessageChannels are desirable because they give direct access to the HTML
	// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
	// 11-12, and in web workers in many engines.
	// Although message channels yield to any queued rendering and IO tasks, they
	// would be better than imposing the 4ms delay of timers.
	// However, they do not work reliably in Internet Explorer or Safari.
	
	// Internet Explorer 10 is the only browser that has setImmediate but does
	// not have MutationObservers.
	// Although setImmediate yields to the browser's renderer, it would be
	// preferrable to falling back to setTimeout since it does not have
	// the minimum 4ms penalty.
	// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
	// Desktop to a lesser extent) that renders both setImmediate and
	// MessageChannel useless for the purposes of ASAP.
	// https://github.com/kriskowal/q/issues/396
	
	// Timers are implemented universally.
	// We fall back to timers in workers in most engines, and in foreground
	// contexts in the following browsers.
	// However, note that even this simple case requires nuances to operate in a
	// broad spectrum of browsers.
	//
	// - Firefox 3-13
	// - Internet Explorer 6-9
	// - iPad Safari 4.3
	// - Lynx 2.8.7
	} else {
	    requestFlush = makeRequestCallFromTimer(flush);
	}
	
	// `requestFlush` requests that the high priority event queue be flushed as
	// soon as possible.
	// This is useful to prevent an error thrown in a task from stalling the event
	// queue if the exception handled by Node.js’s
	// `process.on("uncaughtException")` or by a domain.
	rawAsap.requestFlush = requestFlush;
	
	// To request a high priority event, we induce a mutation observer by toggling
	// the text of a text node between "1" and "-1".
	function makeRequestCallFromMutationObserver(callback) {
	    var toggle = 1;
	    var observer = new BrowserMutationObserver(callback);
	    var node = document.createTextNode("");
	    observer.observe(node, {characterData: true});
	    return function requestCall() {
	        toggle = -toggle;
	        node.data = toggle;
	    };
	}
	
	// The message channel technique was discovered by Malte Ubl and was the
	// original foundation for this library.
	// http://www.nonblocking.io/2011/06/windownexttick.html
	
	// Safari 6.0.5 (at least) intermittently fails to create message ports on a
	// page's first load. Thankfully, this version of Safari supports
	// MutationObservers, so we don't need to fall back in that case.
	
	// function makeRequestCallFromMessageChannel(callback) {
	//     var channel = new MessageChannel();
	//     channel.port1.onmessage = callback;
	//     return function requestCall() {
	//         channel.port2.postMessage(0);
	//     };
	// }
	
	// For reasons explained above, we are also unable to use `setImmediate`
	// under any circumstances.
	// Even if we were, there is another bug in Internet Explorer 10.
	// It is not sufficient to assign `setImmediate` to `requestFlush` because
	// `setImmediate` must be called *by name* and therefore must be wrapped in a
	// closure.
	// Never forget.
	
	// function makeRequestCallFromSetImmediate(callback) {
	//     return function requestCall() {
	//         setImmediate(callback);
	//     };
	// }
	
	// Safari 6.0 has a problem where timers will get lost while the user is
	// scrolling. This problem does not impact ASAP because Safari 6.0 supports
	// mutation observers, so that implementation is used instead.
	// However, if we ever elect to use timers in Safari, the prevalent work-around
	// is to add a scroll event listener that calls for a flush.
	
	// `setTimeout` does not call the passed callback if the delay is less than
	// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
	// even then.
	
	function makeRequestCallFromTimer(callback) {
	    return function requestCall() {
	        // We dispatch a timeout with a specified delay of 0 for engines that
	        // can reliably accommodate that request. This will usually be snapped
	        // to a 4 milisecond delay, but once we're flushing, there's no delay
	        // between events.
	        var timeoutHandle = setTimeout(handleTimer, 0);
	        // However, since this timer gets frequently dropped in Firefox
	        // workers, we enlist an interval handle that will try to fire
	        // an event 20 times per second until it succeeds.
	        var intervalHandle = setInterval(handleTimer, 50);
	
	        function handleTimer() {
	            // Whichever timer succeeds will cancel both timers and
	            // execute the callback.
	            clearTimeout(timeoutHandle);
	            clearInterval(intervalHandle);
	            callback();
	        }
	    };
	}
	
	// This is for `asap.js` only.
	// Its name will be periodically randomized to break any code that depends on
	// its existence.
	rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;
	
	// ASAP was originally a nextTick shim included in Q. This was factored out
	// into this ASAP package. It was later adapted to RSVP which made further
	// amendments. These decisions, particularly to marginalize MessageChannel and
	// to capture the MutationObserver implementation in a closure, were integrated
	// back into ASAP proper.
	// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Promise = __webpack_require__(332);
	
	module.exports = Promise;
	Promise.prototype.done = function (onFulfilled, onRejected) {
	  var self = arguments.length ? this.then.apply(this, arguments) : this;
	  self.then(null, function (err) {
	    setTimeout(function () {
	      throw err;
	    }, 0);
	  });
	};


/***/ },
/* 335 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * @providesModule ReactNativeModules
	 */
	'use strict';
	
	module.exports = {};

/***/ },
/* 336 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2015-present, Alibaba Group Holding Limited.
	 * All rights reserved.
	 *
	 * @providesModule ReactProcessColor
	 */
	'use strict';
	
	function processColor(color) {
	  return color;
	}
	
	module.exports = processColor;

/***/ },
/* 337 */,
/* 338 */,
/* 339 */,
/* 340 */,
/* 341 */,
/* 342 */,
/* 343 */,
/* 344 */,
/* 345 */,
/* 346 */,
/* 347 */,
/* 348 */,
/* 349 */,
/* 350 */,
/* 351 */,
/* 352 */,
/* 353 */,
/* 354 */,
/* 355 */,
/* 356 */,
/* 357 */,
/* 358 */,
/* 359 */,
/* 360 */,
/* 361 */,
/* 362 */,
/* 363 */,
/* 364 */,
/* 365 */,
/* 366 */,
/* 367 */,
/* 368 */,
/* 369 */,
/* 370 */,
/* 371 */,
/* 372 */,
/* 373 */,
/* 374 */,
/* 375 */,
/* 376 */,
/* 377 */,
/* 378 */,
/* 379 */,
/* 380 */,
/* 381 */,
/* 382 */,
/* 383 */,
/* 384 */,
/* 385 */,
/* 386 */,
/* 387 */,
/* 388 */,
/* 389 */,
/* 390 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule keyMirror
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(__webpack_module_template_argument_0__);
	
	/**
	 * Constructs an enumeration with keys equal to their value.
	 *
	 * For example:
	 *
	 *   var COLORS = keyMirror({blue: null, red: null});
	 *   var myColor = COLORS.blue;
	 *   var isColorValid = !!COLORS[myColor];
	 *
	 * The last line could not be performed if the values of the generated enum were
	 * not equal to their keys.
	 *
	 *   Input:  {key1: val1, key2: val2}
	 *   Output: {key1: key1, key2: key2}
	 *
	 * @param {object} obj
	 * @return {object}
	 */
	var keyMirror = function (obj) {
	  var ret = {};
	  var key;
	  !(obj instanceof Object && !Array.isArray(obj)) ?  false ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : undefined;
	  for (key in obj) {
	    if (!obj.hasOwnProperty(key)) {
	      continue;
	    }
	    ret[key] = key;
	  }
	  return ret;
	};
	
	module.exports = keyMirror;

/***/ }
/******/ ])));
//# sourceMappingURL=react-native-winjs.js.map